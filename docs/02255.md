# 得墨忒耳定律:不要接受陌生人的糖果

> 原文:[https://dev . to/mrnipunarora/the-law-of-Demeter-do-accept-candy-from-strangers-3d0p](https://dev.to/mrnipunarora/the-law-of-demeter-do-not-accept-candy-from-strangers-3d0p)

得墨忒耳定律是另一个如此令人着迷的定律，尽管它不是 5 个基本坚实原理的一部分，但几乎可以被认为是它们的附件。

这条法律的思想看起来很简单明了:“不要接受陌生人的糖果。”它的应用很麻烦，这就是为什么我今天想在这里解释它。

### [](#the-problem)问题

很多时候，我们有一个类，而这个类又由其他类的对象组成，而这些对象又来自其他对象。面向对象很正常，没问题。这似乎意味着我们正在从相互交互的小类中创建我们的代码。

到目前为止一切顺利。当其中一个类需要使用下面几层的一些对象时，问题就出现了。我们把毯子卷到头上，开始制造吸气剂，就好像没有明天一样。这可能很危险。

闻起来很糟糕的典型代码是这样的:

getX().getY().getZ().doSomething()

这里的问题是什么？基本上，我们将代码耦合到构成调用链的类的结构中。

如果这种结构明天在任何相关的类中发生了变化，那么这段代码就会受到影响。很糟糕吗？这要视情况而定，但一般来说是可以的，因为这段代码很容易被修改:一次重构就可能导致代码发生变化。

这是代码做得不好的明显症状。

### [](#what-is-the-law-of-demeter)德米特里定律是什么？

根据 Peter Van Rooijen 对得墨忒耳定律的解释:

你可以自己玩。你可以玩自己的玩具(但不能拆开)。你可以玩别人给你的玩具。
你可以玩自己做的玩具。
得墨忒耳定律基本上是一种耦合检测机制，它告诉我们，我们的物体不应该知道与之相互作用的其他物体的内脏。如果我们想让你做什么，为什么不直接问它而不是浏览它的结构？

德米特里定律说，一个物体不应该知道与它互动的其他物体的内脏，以利于卖弄学问。我会说，当有一个 C 类的函数 f，而这个函数只调用下列函数时，德米特定律就成立了:

C.
由 f.
创建的对象作为参数传递给 f.
的对象存储在 C 字段中的对象。
(定义的灵感来源于罗伯特·c·马丁的《干净的代码》)。

在我看来，你不必对这些规则非常严格，但你必须看到我们何时真正利用系统来加载规则。

如果你使用了一个优雅的类封装，但是你用 getters 填充了它，你就破坏了这个封装。

一个简单的方法来检测这个定律何时被违反，那就是你最终得到了许多串联的调用，但这不是一个 100%可靠的原因(一直读到最后，你就会明白为什么)，也不是唯一的原因。

这段代码可以写成如下形式，但仍然是无效的:

val x = getX()
val y = getY()
val z = getZ()
z . do something()
所以基本上，这个想法是，如果你正在访问另一个类的内部结构来调用你的方法，你可能违反了法律。

### [](#how-do-i-solve-the-violations-of-the-law-of-demeter)我如何解决违反德米特里定律的问题？

有时我会觉得我只给出了坏消息，但这个问题没有单一的解决方案。对我来说，这条法律更像是一个“代码气味”警报，它告诉我们有些东西不是很好地建立在那里。

如果你需要访问你所依赖的一个类的结构，很可能是因为职责分配不好。

这并不总是适用的，取决于我们的班级类型。我们可以区分两种不同的类:对象和数据结构。第一个定义行为和第二个存储状态。前者要求他们做事是正常的，而后者更常见的是要求他们给我们东西。

这就是为什么这个定律对第二类的应用失去了足够的有效性，一般来说，我们不必太担心它。

知道如何解决这个问题没有唯一的答案，你有什么选择？

#### [](#1-add-extra-methods)1。添加额外方法

这是最明显的选择，也是我最不推荐的。您让每个对象进行相应的子调用，而不是进行多次调用。你可以有这样的东西:

getX()。doSomething()

这又会调用:

getY().doSomething()

诸如此类。在某些情况下，这可能是值得的，但通常你所做的是隐藏问题，而不是解决问题。

#### [](#2-architecture)2。体系结构

一个好的架构在软件不同模块的解耦中起着非常重要的作用，因此会大大降低违反这个规律的可能性。

通常在一个架构中，每一层都有一系列的接口来进行通信，当考虑那些隐藏其实现的层时，我们将会避免类似我们以前看到的问题。

#### [](#3-better-understand-your-domain)3。更好地理解你的领域

领域的概念，尤其是领域驱动的设计，非常简单。它告诉我们，我们的问题可以基于定义它的一些关键概念，如果它们非常清楚，整个开发过程就会大大简化。没有很好地理解我们的领域很容易导致没有很好地对应用程序建模，因此会出现许多这种类型的问题。

此外，领域驱动设计非常强调不同类型的元素，这些元素可以帮助我们对软件进行建模，因此我们将会更加清楚和详细地讨论我们之前讨论的关于类类型的主题。

像这个世界上的一切一样，理解这个定律背后的概念是有趣的，但不要把它当作我们不能跳过或忽略的东西。如果它有意义和为什么，它将必须在每个案例中被研究。

作为一个小规则，如果你发现你需要访问一个包含逻辑的对象的结构，肯定有一个更优雅的方法来做这件事。

在做决定的时候，一定要想清楚将来是否会产生耦合问题，但是不要忘记过度思考和完全没有思考一样糟糕。

你知道这条法律吗？你知道任何其他系统来检测和解决它吗？请在评论中告诉我们。