# 为什么要学习递归

> 原文:[https://dev.to/itnext/why-you-should-learn-recursion-3dao](https://dev.to/itnext/why-you-should-learn-recursion-3dao)

在 [Twitter](https://twitter.com/chris_noring) 上关注我，很乐意接受您对主题或改进的建议/Chris

> 好了，羊的大图。现在他真的失去了它还是？实际上，这类似于递归，许多相似的函数调用，几乎*相同但不同*；)如果你继续读下去，你会看到递归得到了解释，甚至一些问题得到了解决。

我正在写一个关于计算机科学主题的基础系列。为什么要问，为什么不是最新的 JS 框架或者类似的？

嗯，原因不止一个，了解基础知识是一项永恒的技能，无论你学习什么框架、语言或库，**基础知识将永远存在**。

> 好吧，这听起来像教科书上的答案，我们应该相信吗？

当然还有更多。我已经在 IT 行业工作了十多年，在使用了大量的库和语言之后，你会发现，过一段时间后，你会努力扩展你的思维，解决你以前没有见过的问题，甚至解决同样的老问题，但是是以一种新的方式。

> 可以说你一直在解决问题，有时是以一种粗暴的方式，这公平吗？

是的，我想我们都可以证明这一点，有时我们的解决方案是好的，有时则不那么好。

如果我完全诚实的话，我在大学里不是最专心的学生，我对大 O 符号、算法、递归、编译器等东西看得越多，当我最终理解它并欣赏它的优雅时，感觉就越好。

因此，出于这个原因，我将从覆盖*递归*开始这个系列，递归是*大鲸鱼*之一，是需要征服的大概念之一。我希望展示以下内容:

*   什么是递归
*   为什么是递归，它可以用于什么问题，为什么它是一个真正优雅的方法
*   我们将展示一系列递归真正发挥作用的问题以及如何解决它们

## [](#what-is-recursion)什么是递归

递归的一个笑话是:

> 如果你想知道什么是递归，请看递归

简而言之，递归是一种多次调用自身的方法。

> 这听起来像是一个循环，就像我们将耗尽内存一样

是的，这是递归的陷阱之一，如果你做错了，你会看到这样的错误信息:

[![](../Images/2de265c77487f58cbb1228a4bfa72c13.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--_2x0Mkc9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/4tkedt2vx9rmkq2vg6ap.png)

## [](#%C2%A0why)为什么

> 我到底为什么要叫自己 x 次？

这是关于你问题的本质。有些问题可以被视为一种重复出现的模式，你可以一遍又一遍地应用相同的解决方案。

> 好吧，你得解释清楚。

当然，我们会通过解决一系列问题来说明我们的意思。

> 好吧，很公平，但是你还是没有解释为什么？

总之，优雅(通常是递归解决方案)只包含很少几行代码。这意味着我们理解甚至修改代码的*认知负荷*大幅降低。

> 我明白了，每个人都喜欢简单，还有什么？

递归经常被用来代替`for-loops`和`while`语句。这是循环的本质，或者说*重新应用*这是逻辑。我认为公平地说，它有一个*分而治之*的方法。不要和实际的[分而治之](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm)混淆。我在这里想说的是，我们慢慢地克服了我们的问题，意识到我们正在看一个充满看起来相似的模式的数据集，自相似性。这种*自相似性*使得反复应用相同的算法成为可能。

> 你真的需要解释一下

嗯，你开始处理一组逐渐减少的数据，这意味着我们朝着一个点努力。一旦我们达到这一点，我们就认为问题解决了。

## [](#what-type-of-problems-can-we-solve)我们能解决什么类型的问题？

这里有一个不完整的列表，所以你可以对它有个大概的了解:

*   **求和**，我们可以很容易地对一个列表中的所有条目求和
*   **幂**，计算某物的幂等于将一个数乘以它本身的 x 倍
*   阶乘是将所有的数字以降序相乘
*   树在计算机科学中有很多用途，比如编译器，像计算器这样的后置处理。
*   **转换**，例如，将一个字符串转换成一个数字
*   **排序**，递归经常被用来实现排序算法，例如*合并排序*。

这只是我们可以解决的问题的一小部分，是的，你可以用 *for loops* 和*while*construction 来解决上面的大部分问题，但是这通常会导致混乱的代码。

## [](#solving-some-problems)解决一些问题

你现在一定渴望看到一些代码，所以让我们首先展示一个典型的递归是什么样子的:

```
function recursion(data) {
  if(condition) {
    return 'something'
  } else {
   recursion(data)
  }
} 
```

正如你在上面看到的，我们从 IF 子句开始，这也被称为**基本情况**或*终止*条件。为了不陷入*而真实*的情况，你需要确保这个条件被满足。

我们的 ELSE 语句是我们再次调用自己的地方，正如你看到的，我们再次调用了方法`recursion()`。这里的想法是稍微修改一下，这样我们最终会到达我们的**基础案例**。

接下来我们来看一些现实问题。

### [](#factorial)阶乘

在阶乘中，我们的想法是将所有的数字相乘，包括数字本身。对于数字`5`，这意味着我们需要这样计算它:

```
5 * 4 * 3 * 2 * 1 
```

正如我们在上面看到的，我们正在处理一系列缓慢下降到基本状态`1`的数字。我们来看一些代码:

```
function factorial(num) {
  if(num === 1) {
    return 1;
  } else {
    return num * factorial(num -1); 
  }
} 
```

我不得不承认，当我第一次看到这样的解决方案时，我的脑袋就爆炸了，我无法理解，我就想*这是有效的代码吗*或*如果使用这样的 for 循环，事情会简单得多* :

```
function factorial(num) {
  var sum = 1;
  for(var i = num; i > 0; i--) {
    sum *= i; 
  }
  return sum;
} 
```

我理解过去的自己，也理解正在阅读这篇文章的你们中的一些人。递归在你第一次看到它时会很痛，除非你的大脑以某种方式连接起来；).

那么为什么递归解决方案更好呢？至少对我来说，这是关于简单。如果我们看一个特定的行:

```
return num * factorial(num -1); 
```

我们在这里考虑的只是返回`num`，当我们再次调用`factorial()`时，我们把剩下的留给它自己的计算，这次是用调整后的值`num`。对我来说，难以理解的是这是有效的代码。我可以看到这将导致一个`5 * 4 * 3 * 2 * 1`场景。我只是不明白编译器是否同意。但事实如此，这就引出了我们的下一个问题。

### [](#conversion-string-to-number)转换，字符串到数字

这是一个有趣的问题。当我们将某物从`"234"`转换到`234`时，会发生什么。嗯，是加的。是`200 + 30 + 4`。那看起来像什么？

> 一个递减序列？

是的，没错，但让我们更详细一些，它看起来像下面这样:

`2 * 10^2 + 3 * 10 ^ 1 + 4 * 10 ^ 0`

给定我们从阶乘中学到的东西，我们可以开始在它上面画草图:

```
currentcharacter * Math.pow(10, pow) + convert(character) 
```

好了，我们大致了解了*如何*。下一个问题是我们的基本条件是什么样的？答案是我们只和一个角色合作，就像这样:

```
if (chars.length === 1) {
  return parseInt(chars[0]);
} 
```

上面告诉我们，我们将从左开始处理我们的数字，一旦我们处理了最左边的字符，它就被认为是已处理的，我们应该继续处理一个更小的数据集。关键是我们要缩小数据集，这样才能达到我们的基本条件。所以让我们看看剩下的代码:

```
function convert(num) {
  let chars = (num + '');

  if(chars.length === 1) {
    return parseInt(chars[0])
  } else {
    let pow = chars.length -1;
    return Math.pow(10, pow) * parseInt(chars[0]) + convert(num.substr(1));
  }
} 
```

放大我们的 else 条件:

```
else {
  let pow = chars.length -1;
  return Math.pow(10, pow) * parseInt(chars[0]) + convert(num.substr(1));
} 
```

我们可以看到，我们将`2* 10^2 + 3* 10^1 + 4`或`"234"`的下降模式转化为`234`。它下降的原因是我们这样做:

```
convert(num.substr(1)) 
```

我们从左边挑选一个字符，所以`234`，变成`34`，最后是`4`，这样我们就达到了基本条件。

## [](#summary)总结

我可以向您展示树和大量其他实现，但让我们就此打住。看看这个 [repo](https://github.com/softchris/recursion) ，我已经用递归解决了更多的问题。我想说的是什么是递归，为什么它对某些问题构成了一个更简单和更优雅的解决方案，当然我也想解释递归的组成部分，以及在解决这类问题时如何思考。

我希望它有教育意义。如果你想让我写一篇关于这个话题的后续文章，请在评论中告诉我。

到最后，你可能不相信递归适合你。我不是最长的时间。老实说，我喜欢递归带来的模式。如果你的部分工作是编写算法，或者你渴望成为下一个代码大战大师，或者申请一家著名科技公司的工作，这是你需要知道的事情。如果没有，继续，for 循环也是语言的一部分:)

或者像他们说的我住的地方:

> 保持冷静，继续前进:)