# 尽管编译器如此先进，为什么汇编程序比 HLL 程序快？

> 原文：<https://dev.to/johnfound/why-assembly-programs-are-faster-than-hll-programs-despite-that-the-compilers-are-so-advanced-51ha>

## 自相矛盾。

与用高级语言(HLL)编写的具有相同功能的程序相比，手写汇编语言程序速度更快，占用内存更少。

下面我会举一些现实生活中的例子。此外，我做了几个人工实验，显示相同的。

这看起来像是一个悖论，因为 HLL 编译器现在非常有效，对于大型程序来说，它比手写的汇编语言能生成更好的代码。

是的，可以正式证明以下定理:

> 手写的汇编语言代码总是比编译器生成的代码更优或更好。

事实很容易证明这种说法，程序员总是可以读取编译器的输出并进一步优化它，而编译器不能对程序员的代码做同样的事情。

但是这个定理在现实生活中并没有太大的帮助。仅仅是因为编译器生成了大量的代码，而这些代码不能被人工阅读、分析和优化。

幸运的是，汇编语言程序员不需要在平台特定的优化上与编译器竞争，就能打败它。

当今最快的汇编程序是 [FlatAssembler](https://flatassembler.net) 。它是用汇编语言编写的，并且是为 80386 CPU“优化”的，如果这可以被称为优化的话。竞争对手是用 C/C++编写的，速度较慢，尽管 C/C++编译器生成了更优化的代码。

我知道的最快的 OS 是用汇编语言写的 [KolibriOS](https://kolibrios.org/en/) 。它[引导不到 2 秒](https://youtu.be/j2KKkyBIXfA)到 GUI 桌面。甚至 BIOS 启动都比较慢。即使在非常慢的旧机器上，GUI 也能立即响应。

最快的 web 服务器是 RWASA，它是上面例子中唯一一个真正针对速度进行优化的。但它仍然比竞争对手使用更少的内存。(我的意思是，HLL 的速度优化通常会导致内存使用增加)

实际上，在大多数情况下，用汇编语言编写程序，程序员在编写更小和可读的代码上比在编写更快的代码上投入更多的精力。但结果是，这些程序总是比 HLL 的同类程序运行得更快。

## 为什么？

让我们看看所谓的[“杰文斯悖论”](https://en.wikipedia.org/wiki/Jevons_paradox)。这是一个经济学悖论，但实际上它也可以应用于编程。

> 在经济学中，当技术进步提高了资源的使用效率(减少了任何一次使用的必要数量)，但由于需求增加，资源的消耗率上升时，就会出现杰文斯悖论。

如果我们把这个定义应用到编程中，我们可以看到，直接的类比。编译器实际上提高了程序员使用计算机资源的效率。HLL 的一行代码比汇编语言的一行代码能使用更多的资源。

同样的道理，效率更高的汽车用一升燃料可以行驶更长的里程。

结果，计算机资源 CPU 和 RAM 的使用增加了。因为需求增加了。

同样的道理，效率越高的汽车，行驶公里数和总油耗也越多。

请注意，编译器效率的提高并不是 IT 效率的唯一提高。硬件的效率也随着时间而增加。现在 RAM 比以前更快更大，CPU 也非常高效。

但是所有这些改进只会导致资源消耗的增加。完全符合杰文斯悖论。

就这么简单。

## 如何中和？

在经济学中，有一些工具可以抵消杰文斯悖论。例如，如果目标是减少资源消耗，增加税收可以阻止需求增长并抵消这种影响。

所有其他可能的反制措施总是与一些强制限制有关。

但是对于“CPU 周期”或“RAM 使用”没有税收或其他规定。

对于程序员来说，唯一的方法就是有意识地限制自己使用 HLL 编译器和硬件改进所带来的更高的效率。

这里可能有人会问*“为什么我们要限制资源的使用？RAM 便宜，CPU 快。”*

答案简单明了:因为我们需要这些资源来进一步开发我们的项目。

此外，程序员的时间当然很重要，但程序员经常忘记程序只写了一次，但有时要执行几百万次。通过编写更快的程序节省一秒钟，可以为程序的用户节省数百万秒钟。

是的，程序需要维护和进一步开发，但是谁说，更优化的程序需要更多的维护工作呢？

开发汇编语言项目的经验清楚地表明，维护工作实际上并不依赖于编程语言。

例如，上面提到的平板组装机是由一个人开发和维护了将近 20 年。尽管这个程序完全是用汇编语言编写的，但我并没有注意到维护这个程序的巨大努力。有时候报告的 bug 会被修复几个小时甚至几分钟。

当然，HLL 的程序也可以用高效的方式编写。有许多这样编写的 C/C++项目的例子，它们确实表现出色。

但是语言水平越高，就越难写出高效的代码。对我来说，像 C++、Pascal 或 Fortran 这样的语言是更高级的语言，可以在某种程度上抵消杰文斯悖论。

像 Java、C#或 Python 这样的语言完全受到了悖论的影响，似乎任何抵消都是不可能的。

## 未来

幸运与否，但计算机性能的过度增长，实际上结束了。不会再有指数增长了。也不接近。我们可以预期计算机性能和资源会有一些缓慢的线性增长，甚至下降(移动设备、低能耗、最近发现的 CPU 和 DRAM 缺陷)。

所以，现在程序员有时间整理他们的代码，并开始偿还他们在硬件大爆炸期间积累的巨额技术债务。

如果在指数增长期间，技术进步为下一个程序版本提供了 RAM 和 CPU，现在这个时间结束了。

如果某人有一个使用计算机所有资源的程序，并想实现新的功能，他将被迫首先优化现有的功能，以使用更少的内存和 CPU，并将释放的资源用于程序的新功能。

我强烈怀疑这个过程已经在大多数软件公司和大型开源项目中悄悄的(可能是无意识的)运行了。

但是对于新项目来说，从第一天开始节约使用资源似乎是更好的策略，因为从一开始就编写资源友好的代码比以后重写更容易。

顺便说一句，越来越多的人开始呼吁更多的资源友好的代码。我每天都在不同的博客和社交网络上阅读这样的文章。

所以，有趣的时候来了。深度软件优化时代。