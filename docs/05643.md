# 佩格和普拉特一起玩得很好

> 原文：<https://dev.to/combinatorylogic/peg-and-pratt-play-well-together-2i20>

一个流行的基于 PEG 的解析很好，很简单，也很漂亮。直到你想用优先级和结合律定义二元表达式。然后很快就变丑了。

```
expr = { [expr1] "*" [expr] => ... }
     / { [expr1] "/" [expr] => ... }
     / [expr1];

expr1 = { [atom] "+" [expr1] => ... }
      / { [atom] "-" [expr1] => ... }
      / [atom];

... and so on 
```

当然，有一些方法可以用 PEG 处理左递归文法(特别是 Packrat)，参见[pemp 08 幻灯片](http://alexwarth.com/papers/pepm08-slides.pdf)快速介绍一种最实用的方法。是否足够？不完全是，语法仍然很笨拙，祝你好运以任何有意义的方式表达结合性。

上面的语法是右关联的，把它变成左关联的最简单的方法是注释你正在构造的 AST 并在以后转换它，而不触及语法本身。这显然是一种丑陋的做事方式。

作为这种偶然的右结合性有多糟糕的一个例子:一个表达式`x-1-1`将被解析为`x-(1-1)`，这显然不是我们想要的。

现在，有一个 PEG 实现供应商不想让您知道的小技巧。叫做[普拉特解析](http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/)。

它非常容易理解，甚至更容易实现。整个算法可以描述如下:

`prefix`解析器:

*   尝试解析一个`atom`
*   如果成功，存储为`Left`，否则返回失败
*   尝试解析一个`binary`操作符，一次一个(例如，“*”、“/”、“+”、“-”...)
*   如果所有尝试都失败，则返回`Left`，否则检查成功运算符的优先级；如果小于当前优先级，应用相应的`infix`解析器，否则返回`Left`

一个`infix`解析器:

*   尝试使用当前优先级解析右侧(使用`prefix`解析器)，如果是右关联的，使用当前优先级减一。
*   如果成功，返回当前结果(应用 AST 构造函数，无论如何)，否则，回溯到当前`prefix`条目的开始。

遗憾的是，这一切只对带有优先级和结合性的二进制表达式有意义，对你的语法的其余部分几乎没有用处。幸运的是，这个算法没有告诉我们关于*如何解析原子和二元运算符的任何事情。看起来是个机会！*

事实证明，Pratt 算法非常容易嵌入到几乎任何类型的 Packrat 或任何其他 PEG 实现中——您仍然可以做所有您想要的内存优化，整个 Pratt 只是 PEG 中的另一个解析顺序操作符。

上面的语法现在变得更好了:

```
binary expr = 
         (200) [expr] "*" [expr] => ...
       | (200) [expr] "/" [expr] => ...
       | (100) [expr] "+" [expr] => ...
       | (100) [expr] "-" [expr] => ...
       | [atom]
       ;

atom = { "(" [expr] ")" => ... }
     / ... all the other trivial entries ... 
```

这里，`200`是`*`和`/`操作的优先顺序，`100`是`+`和`-`的优先顺序。我们可以有任意多的优先级，适用于任何可以想象的语言。

我们不再关心拥有左递归语法的所有后果，并且我们免费获得了默认的左结合性。我们臭名昭著的`x-1-1`不再翻译成`x-0`了，不费吹灰之力！

这种方法在我的优化 [PEG 解析系统](https://github.com/combinatorylogic/mbase/tree/master/src/l/lib/parsing)中成功使用，它是 [PFront 语言](https://combinatorylogic.github.io/mbase-docs/)的核心部分，我强烈推荐任何实现 PEG 解析器的人也这样做。这会让你的生活更轻松，我保证。