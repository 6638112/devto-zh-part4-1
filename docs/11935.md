# P2P 网络的安全和信任问题

> 原文:[https://dev . to/solanav/P2P-network-security-and-trust-issues-pkg](https://dev.to/solanav/p2p-network-security-and-trust-issues-pkg)

在为我当前的项目编写 p2p 通信协议时，我面临着发现对等点及其真实性的问题。

第一个安全措施是对部署到网络上的每个客户端或对等体进行签名。服务器有一个 RSA 密钥对。它使用私钥对正在安装的客户端的 IP 进行签名。服务器的公钥也被提供给客户端，用于验证服务器指令。这似乎是一个好主意，因为它可以防止第三方渗透到网络中，除非服务器感染了攻击者的计算机。我们还确保来自服务器的指令来自服务器。

为了允许客户端在其他计算机上复制和安装自己，我们需要一种向服务器请求给定 IP 的证书的方法。为此，服务器必须验证请求新证书的客户端已经是网络的一部分。这是有问题的，因为如果攻击者感染了他们的计算机，他们现在可以创建任意多的对等机。

我没有试图将攻击者挡在网络之外，而是提出了让每个对等体为进入网络付出代价的想法。对等体应该从“不可信”状态开始，只有在它们向服务器提供了我们想要的东西之后才变成“可信”状态。例如，开采 monero 可能需要一定的时间。使用这个系统,“不可信”的对等体不能从其他对等体获得非常有限的信息。他们能够向其他同伴转发指令。这样，只有当攻击者帮助网络运行并可能为您赚钱时，您才允许他们获取信息。

我们如何知道对等体的状态？这可以以集中的方式解决，只需向服务器询问对等点。这是很好的，如果你想通过使他们成为我的加密来验证对等体。对等体可以将他们的工作证明发送到服务器，服务器验证它是有效的，并且在数据库中将对等体列为可信的。分散式解决方案是让每个节点决定一个新节点是否可信。这样，对等体只会将信息提供给已经信任的对等体。这只有在默认情况下信任一些对等体时才有效。对此的解决方案是，不被信任的对等体只能是那些不是由服务器直接创建的对等体。因此，如果一个对等点在另一台计算机上安装了该程序，新的对等点就不会被任何人信任。举个例子，假设你是网络中的一个对等体。您的已知对等方列表中有一个不可信的对等方。在这个不受信任的对等体从服务器向您发送了 10 条指令，并且您已经验证它们没有被修改之后，您可以将这个对等体的状态设置为受信任。
混合模型将首先询问服务器对等体是否可信，并相应地更新本地数据库。当一个对等体将另一个对等体的状态改变为可信时，这将被传送到服务器，并且当服务器接收到足够多的这些时，它将更新对等体的全局状态。
那么什么是足够的同龄人呢？我们应该设定一个最小的对等数，但是这个绝对值不好。我们还需要检查不信任它的对等体的数量。所以我们需要得到连接的对等体的列表。使用 DHT 和 XOR 来计算到对等体的距离应该是相当容易的。每个对等体的散列将是服务器给出的证书。所以你要计算有多少邻居信任它，并以这种方式判断它。