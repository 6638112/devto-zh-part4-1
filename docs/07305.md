# 使用 Pulumi 将基础设施作为代码

> 原文:[https://dev . to/code gram/infra structure-as-code-with-pulumi-4fbm](https://dev.to/codegram/infrastructure-as-code-with-pulumi-4fbm)

说到管理我们的基础设施，作为开发人员，我们经常面临双重标准。我们的代码是受版本控制的，接受代码审查，由测试工具定期检查。我们不冒这个险。

然而，运行我们代码的基础设施，通常是我们生产系统中最关键的部分，被区别对待。登录您的 AWS 帐户，点击几下，配置一台机器。随着 Docker 的出现，至少环境变得更具可复制性，但仍然有太多的人花时间点击他们的云超级用户帐户来改造世界。

## [](#declarative-dsls)声明式 DSL

说到这里，有...嗯， [Terraform](https://www.terraform.io) ！以及其他解决方案。代码为的*基础设施的概念刚刚开始成为 DevOps 思维模式中的新默认。以声明的方式定义您的基础设施，运行一些基本的健康检查，并让一切都受版本控制，这是一个巨大的进步。*

声明式 DSL 是一种改进，但我们可以做得更好。根据我们在 Codegram 的经验，通常你可以花 80%的时间来找出你的云提供商的模块的正确咒语，而几乎不需要工具的帮助。这意味着调试周期非常缓慢，并且经常令人沮丧。在无服务器的环境中更是如此，在这种环境中，大部分代码都是基础设施的粘合剂——队列、存储桶和 lambdas 都需要以正确的方式，使用正确的 ACL 权限相互通信。

构建 Pulumi 是为了利用通用编程语言的能力来解决这些缺点。

## [](#enter-pulumi)输入电池

**免责声明** : *Codegram 与 pulumi.com 没有任何关系。这篇文章中详细描述的好处都不需要订阅 pulumi.com——你可以直接使用开源库。*

Pulumi 是一个开源库，允许你使用通用编程语言在你选择的云提供商上构建你的基础设施。在 Codegram，我们通常选择 TypeScript 作为这项任务的语言。

作为一个例子，下面是创建一个 S3 桶和启动一个 AWS Lambda 所需的所有代码，它触发上传到它的每个文档:

```
import * as aws from "@pulumi/aws";

const docsBucket = new aws.s3.Bucket("docs");

docsBucket.onObjectCreated("docsHandler", (e) => {
   for (const rec of e.Records || []) {
      console.log(`Hello from Lambda -- got an S3 Object: ${rec.s3.object.key}`);
    }
});

export docsBucketName = docsBucket.bucketName; 
```

所有这些粘合代码都是由 Typescript 编译器进行类型检查的——从 S3 事件内部的记录，到所创建的 S3 桶的属性都应该是要检查它们的。它远远超出了无服务器的范畴——无论您是部署到 Kubernetes，还是普通的 Docker 容器，您都可以胜任。

在我看来，这种方法的优点不仅仅是方便。请继续阅读。

## [](#extensibility-via-terraform-providers)通过平台提供商的可扩展性

尽管 Pulumi 不依赖于 Terraform，但 Pulumi CLI 经常利用 Terraform 提供者，并且有很好的工具从现有的 Terraform 提供者生成 Pulumi 库。在我们的例子中，这非常有用，因为我们需要通过 Pulumi 用 DNSimple 管理 DNS。尽管这是我第一次使用代码生成工具，但仅仅一两个小时，我就让 [DNSimple integration](//github.com/pulumi/pulumi-dnsimple) 开始工作了。

## [](#repeatable-environments)可重复的环境

当您将所有的基础设施与代码放在一起时，在不同的云区域中构建一个阶段环境或测试环境是微不足道的。我们发现 Pulumi 帮助我们缩小了从开始*测试*一段代码到从我们的持续部署管道中提供一个已部署的、可重复的环境之间的差距。

对于像我们这样的机构来说，这变得更加重要——通常，项目从我们的云帐户开始，然后转移到客户的帐户——如果不确定环境是完全可重复的，并且没有留下任何指向和点击界面，那么确保平稳移交将是一项艰巨的任务(相信我，过去就是这样)。

## [](#avoiding-cloud-vendor-lockin)避免云厂商锁定

pulumi.cloud 现在以一种云不可知的方式实现了云服务的许多基本概念。

这让您可以抽象出许多特定于云的工具，以便于部署一个多云项目。然而，在当前的 API 无法到达的地方，它只是代码——您可以利用抽象来避免将您的基础设施锁定到特定的云供应商。

## [](#serverless-and-magic-functions)无服务器和魔法功能

普鲁米有一个神奇功能的概念。这是一个将被打包成 Lambda 或 cloud 函数的闭包，它可以引用基础设施的元素。这些元素是在配置时解析的，因此它们不是动态的，尽管它们看起来很灵活。

```
import * as aws from '@pulumi/aws'

const inputBucket = new aws.s3.Bucket('input')
const outputBucket = new aws.s3.Bucket('output')

input.onObjectCreated('process', e => {
  for (const rec of e.Records || []) {
    const processed = processFile(rec.s3.object.key)
    uploadFile(outputBucket.bucketName.get(), processed)
  }
}) 
```

在这个例子中，每次一个文件被上传到`inputBucket`时，我们调用一个 Lambda 来处理这个文件并上传到另一个 bucket。我们用来定义 lambda 的闭包在`outputBucket.bucketName`上关闭，并在其上调用`get()`。这段代码在供应时将被编译成一个 Lambda，它将静态地包含输出桶的字面名称。

我们获得了基础设施元素之间看似动态的引用的所有好处，而没有配置管理的麻烦——错误配置的环境变量等等。这些引用在*编译时*被检查，在供应时间之前，显然在运行时间之前。

神奇的功能有助于构建一种粘合代码，这种代码在无服务器、无缝的情况下编写起来非常乏味，并且完全由您使用编程语言和工具。

## [](#encoding-best-practices)编码最佳实践

说到团队管理基础架构，标准化最佳实践变得至关重要。我们对存储桶使用哪些设置？我们总是用队列来解耦生产和消费吗？什么耐久性设置是好的默认值？

通过在我们自己的公司库中抽象公共基础设施模式，这些问题被带到团队中，并以拉请求、代码审查和围绕真实、有形代码的技术讨论的形式得到回答。这样我们就从一个人*知道这里的事情是如何做的*转移到整个团队拥有的版本控制的最佳实践。

## [](#granular-security-by-default)默认粒度安全

在传统的基础设施管理中，人们通常默认先创建一个超级用户(T1)，然后当所有的部分都被定义和稳定后，T2 再考虑加强权限(T3)。听起来耳熟吗？

为了避免这种情况，在代码中使用基础设施模式意味着您可以围绕资源抽象出粒度权限。每当你创建一个队列时，这样做的代码可以确保只有特定的存储桶可以向它发布事件，或者只有特定的机器或 lambda 可以从中读取。

一旦它在库中，它的*用户*(团队成员)再也不用担心松散的权限了。写一次，不再担心。

## [](#bonus-points-type-safety)奖励点数:类型安全

在 Codegram，TypeScript 是我们管理基础设施的首选语言。每个云提供商在其广泛的产品中提供的无数选项，以及这些选项经常变化的事实，使得编译器的帮助非常宝贵。

原因是，云提供商的大多数参数验证是在特定资源的实际供应时间完成的，这意味着，对于 N 个资源，它很容易退化为一个非常长的反馈循环。

通过在编译时进行大部分参数验证，您甚至不需要运行代码来确保匹配。另外，在自动完成方面，您可以从工具中获得很多帮助。

最重要的是，TypeScript 的类型系统足够强大，可以支持参数多态性，这对于抽象出常见的模式非常有帮助，对于多云抽象也非常有帮助。

## [](#conclusion)结论

管理基础设施曾经是一项乏味的任务，很少有人喜欢做。自从我们开始使用 Pulumi，它就与开发项目的整个过程融为一体，并且它给了我们生产环境的可移植性和可重复性额外的信心。

现在，向前迈进，改造世界！双关语。

<small>里卡多·戈麦兹·Á·安吉尔在[Unsplash](https://unsplash.com/photos/PhrneXLSYis)T3 拍摄的封面照片</small>