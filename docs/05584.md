# 走向功能 3 -过滤和减少

> 原文：<https://dev.to/brunooliveira/going-functional-3-filter-and-reduce-aap>

欢迎来到#goingfunctional 系列的第 3 部分。

从我们停止的地方继续，我们将研究另外两个操作，它们对于行业程序员来说既重要(在某种意义上，它们可以被视为编写功能代码的构建块)又有用(因为它们可以很好地转化为业务需求)。它们是*还原*和*过滤*。

与 map 和 lambda 函数一起，它们几乎提供了一个“框架”来*功能化*你的代码库，这是非常值得了解的，因为它使你的代码库更可读，更现代，并且总体上更容易使用。

**过滤器**

顾名思义， *filter* 是一个构造，它允许用户基于特定的过滤器对 iterable 进行过滤。像这样:

```
 filter (\x -> x>3) ([1,2,3,4,5])
=> [4,5] 
```

我们可以看到它接收一个过滤函数和一个 iterable，并在应用过滤函数后返回一个新的 iterable。

在 Python(仅限 2 或更低版本)中，与上面相同的代码可以写成:

```
>>> filter(lambda x: x>3, [1,2,3,4,5])
[4, 5]
>>> 
```

在 Python 3+中，诸如 map、filter、reduce 等操作被定义为返回一个迭代器(参见这里的[了解它)，这意味着要得到相同的结果列表，你需要做:](https://stackoverflow.com/questions/33174276/why-does-foo-filter-return-a-filter-object-not-a-list) 

```
Python 3.7.4 (v3.7.4:e09359112e, Jul  8 2019, 14:54:52) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> list(filter(lambda x: x>3, [1,2,3,4,5]))
[4, 5]
>>> 
```

通过将结果迭代器包装在一个列表构造函数调用中，迭代器将被具体化为一个列表，我们将获得与 Python 2 中相同的行为。

过滤的思想是根据函数测试列表中的每个元素，只保留通过测试的元素。

用行话来说，这个函数叫做*谓词*，这是一个必须返回布尔值的函数的专用名称。

这对于我们的例子来说是有意义的，因为只有通过谓词测试的元素被保留在列表中，所以在过滤器构造中使用的函数的返回时间是**需要**是一个布尔值。

这包括所有可能的过滤器组合以及导致和/或组合以布尔结束的逻辑操作符:and、or、not、xor、这些操作符的任何组合，以及更专门的方法，例如，检查对象的属性是否匹配过滤标准(`getCarColor().contains("yellow")`)或者例如检查对象列表是否匹配特定的实例类型。任何事情都可以，只要我们得到一个布尔值作为结果。

这就是数学抽象的力量在起作用。

**减少**

我们要讨论的下一个概念是*减少*。在我看来，人们在这个特定的概念上挣扎了很久，例如，一个开发者成员花了[一整天来处理它](https://dev.to/phillipkent/i-spent-an-entire-saturday-trying-to-understand-reduce-27m2)，所以值得深入探讨它。让我们从一个真正的来源(:D)哈斯克尔维基的定义开始:

> 在函数式编程中，fold(或 reduce)是一系列高阶函数，以某种顺序处理数据结构并构建返回值。这与展开函数族相反，展开函数族采用起始值并将其应用于函数以生成数据结构。典型地，一个文件夹处理两件事:一个组合函数和一个数据结构，典型地是一个元素列表。然后，fold 继续以某种系统的方式使用函数来组合数据结构的元素。

之所以称之为 *reduce* ，是因为其思想是从一个种子值开始系统地应用一个函数，直到可迭代对象被穷尽，或者，**将**缩减为一个单一值。

典型的例子包括将列表中的所有元素相加，例如，将列表中的所有元素相乘。

**求和元素**

当用求和操作累加元素时，如果我们想得到一个 iterable 中所有元素的和，我们需要提供 0 作为恒等值来开始我们的归约。

对于每一个单独的元素，恒等式必须是相等的，很明显，对于任何整数 X，我们有:

`0+X = X+0 = X`

我们说 0 是累加器函数的单位值，它也是关联的。

我们可以将这与我们刚刚学习的`filter`操作结合起来，对一个列表中的所有偶数值求和，这在 Python 中非常简洁:

```
>>> reduce(lambda x,y: x+y, filter(lambda x: x%2==0,[1,2,3,4,5,6,7,8,9,10]), 0)
30
>>> 
```

Reduce 接收一个 lambda 函数、一个列表(在我们的例子中是过滤操作的结果)和一个起始值(如果省略，将默认为列表的第一个值)。我们来看看乘法。

**乘法元素**

当用乘法运算累加元素时，如果我们想得到一个 iterable 中所有元素的和，我们需要提供 1 作为恒等值来开始我们的归约。更有趣的是，让我们看看当乘法运算时**而不是**提供默认值:
会发生什么

```
>>> reduce(lambda x,y: x*y, [2,4,6])
48
>>> 
```

由于我们没有提供默认值，展开缩减看起来像:

`2*(4*(6))`

当提供一个缺省值作为标识时，我们得到相同的效果，除了标识乘以第一个元素来“开始”减少:

```
>>> reduce(lambda x,y: x*y, [2,4,6],2)
96
>>> 
```

`2*(2*(4*(6)))`

**现实世界中的应用**

这些操作非常有用，就像我们之前看到的一样，它们可以很好地与许多不同的业务领域相结合，例如:

*   合计在某公司工作超过一年的所有员工的薪金

*   统计某一天已经发出的订单数量

*   图中具有某一值的节点数

*   还有更多例子...

**结论**

希望您喜欢阅读和学习关于减少和过滤数据和对象的更多内容，以使您的代码更具可读性和可维护性。

下一次我们将更详细地研究归约运算的含义，关于 infinite(！！)数据结构、惰性评估以及它如何改变您查看数据的方式。