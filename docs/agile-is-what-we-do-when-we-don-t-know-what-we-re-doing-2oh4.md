# 敏捷是我们在不知道自己在做什么的时候做的事情

> 原文：<https://dev.to/visum/agile-is-what-we-do-when-we-don-t-know-what-we-re-doing-2oh4>

如今，在开发方法中，我们似乎有两个基本的选择。要么你是“敏捷的”，([无论那是什么意思](https://dev.to/theobendixson/agile-is-literally-meaningless-22d5))，要么你是“瀑布的”(显然是“不敏捷的”)。

就我在这里的目的而言，“敏捷”过程是那些被设计成在开发过程中接受和拥抱变化的过程。

当我在这里说“瀑布”时，我指的是任何试图通过遵循严格有序的步骤序列来创建项目的过程，其中每个步骤必须在下一个步骤开始之前结束。比如，只有写完需求，才能开始开发。

我不打算讨论谁是敏捷的，谁不是，也不打算讨论哪个过程和认证是最敏捷的或最不敏捷的。所有这些都在其他地方被提及，令人作呕。我想在这里指出的一点是，当我们不知道我们在构建什么时，我们会采用*敏捷*方法。

我并不是说敏捷是为白痴、无知、落后或类似的人准备的。敏捷思想是伟大的，并且给软件开发世界带来了很多理智和价值。我喜欢敏捷，真的！

## 敏捷

花点时间看看敏捷宣言的作者阐述的敏捷软件的十二个原则。这些原则中有许多是关于弄清楚要构建什么(“驾驭变化”、“业务人员和开发人员必须每天一起工作”等等)。)并确保您正在构建正确的东西(“工作软件是进步的主要衡量标准”，“有价值软件的早期和持续交付”)。其余的原则是关于产品的实际构建(“可持续发展”、“自组织团队”等等)。).

这些原则描述了一种发展哲学，这种哲学既是关于*发展*的，也是关于*发现*的。敏捷接受并接受这样一个事实，即企业说它想要的可能是不完整或不准确的。这些原则中公认的最伟大的创新之一是，企业绝对需要参与整个开发过程。这一点很重要，因为，首先，我们非常不擅长沟通，经常谈论非常小的片段有助于避免 I/O 错误。但更重要的是，在这些紧密的迭代周期中一起工作有助于企业发现它真正想要的是什么。敏捷教会了我们如何*同时发现*和*构建*。

真的，那真是太棒了。然而，如果我们一开始就知道我们在构建什么，我们就不必一路探索。换句话说，敏捷就是我们在不知道自己在做什么的时候做的事情。

## 瀑布

让我们花一分钟谈论瀑布。为什么我们这么讨厌它？理论上，业务有需求，它将其定义为一组软件需求。那些需求被交给实现它们的开发人员。测试结果被反馈给业务部门，一个小型开发团队被分配来修复、维护和增强产品，直到将来。

从某个层面上来说，接到一大堆需求，把自己锁在代码地牢里几个星期，拿出一个成品，而在此期间除了书呆子同事和送披萨的人之外，不用和任何人说话，这看起来确实不错。嗯，如果你知道需求是有意义的，它们不会改变，并且你正在构建的东西对任何人都有用，并且看到生产日的曙光，那就太好了。

正如我们已经提到的，问题在于企业很少真正知道自己需要什么。由于了解业务需求是一个漫长的连续过程的第一步，如果这一步做错了，就会导致我们很多人都很熟悉的慢动作火车事故。

事实上，瀑布可以很好地工作，但它严重依赖于理想的条件。只有当你确切地知道你在做什么时，它才会起作用。

我认为我们如此讨厌瀑布的原因并不是因为方法本身就有缺陷，而是因为我们和我们的业务在计划和沟通方面非常糟糕。然后，瀑布方法变成了“否认”方法，在这种方法中，我们欺骗自己，以为我们知道需要什么以及如何构建它，将令人不舒服的现实推迟到发布时(这可能很晚了，如果真的发生了的话)。

对于我们大多数人生活的现实来说，很大程度上是没有计划的，有时是不可计划的，敏捷哲学更有意义。

## 软件特殊吗？

为什么敏捷过程与软件联系如此紧密？当然，他们受到了像丰田生产系统这样的肉类空间实践的启发，但卡罗拉仍然是在瀑布过程中建造的。它被设计，然后建造，然后运输，最后出售。车身经过冲压焊接后，你不会发现后座腿部空间太小。TPS 是关于汽车生产过程的灵活性，而不是汽车本身。

我认为我们可以摆脱软件中的敏捷过程，因为我们的软件更软，更容易修改或废弃和重建。我想知道敏捷，尽管这个想法很酷，是否是对破碎的商业习惯的让步；对导入库中的一个错误的变通方法，它本身并不是真正正确的解决方案。

以皮克斯电影为例。我不在皮克斯工作，但我可以想象他们的作品必须遵循瀑布般的流程。即便如此，他们制作出如此伟大的电影，因为他们在制作过程的最前端投入了如此多的时间、精力和专业知识。因为建模、动画和灯光相对昂贵，故事(电影的定义)的散列发生在低 fi 故事板上。想想看——你需要动画才能渲染，你需要录制声音才能制作动画，你需要脚本才能录制声音，你需要故事才能编写脚本。等到渲染已经开始，再想起莱利的“悲剧吸血鬼浪漫岛”就来不及了。电影没有在整个过程中发现自我的奢侈。他们有时也有中游修正，但这些都很贵。

以强大的土星五号火箭为例，其主要部件由至少五个独立的承包商制造。虽然每个承包商在执行其分配的组件时都有一定的自由度，但改变发动机质量或推进剂箱高度的决定会对整个令人麻木的复杂项目产生影响，并且必须与数百人沟通，结果可能会“重构”数千个物理部件。你不可能在生产车间里站起来，身后装配着半辆 S-IVB，然后说:“昨天我试着用 7075-T6 铝合金做前裙，但今天我想看看 2319 怎么样。”在建造任何东西之前，这些东西都必须被计划好，非常详细。

如果软件行业知道如何在过程的最前端投入我们最大的努力会怎么样。如果软件工程师和业务人员坐在一起，通过比代码更软的媒介一起发现需求，会怎么样？软件有什么特殊之处可以防止这种情况吗？

## “树”法

我一直在考虑另一种方法，我称之为*树*过程。基本概念是一系列递归过程，将一个想法的各个部分分割成连续的小块。从根本想法开始:可行吗？它提供价值吗？它是由哪些部分组成的？这些组成部分可行吗？用什么样的小块来制作它们？

起泡，冲洗，重复。

当你这样做的时候，你将会生成一个树状结构，以最初的想法为根，并从中分支出使其工作所必需的东西。每个节点分解成自己的需求，直到在底部，您离实际的实现还差一层。在这个过程中，您将识别和测试假设——“客户会发现这个特性有用吗？”，或者“这个算法的性能含义是什么？”。通过这个练习，你应该已经回答了几乎所有的问题，这个树告诉你所有的事情是如何结合在一起的。然后开发从叶子开始，解析树上的每个节点，直到最终产品，根想法完成。

在开发过程中，你可能会学到计划中没有的东西，这没关系。只要回到树上，做必要的调整。由于仔细的预先计划，这些变化的影响应该是有限的，并且该树将向您确切地显示连锁反应将会是什么。

## 结论

根据我的经验，作为开发人员，我们实际上很少写代码。我们大部分的精神努力是弄清楚我们正在建立什么，以及我们将如何去做。代码是最简单的部分。如果我们和我们的业务同事能够集中纪律，将所有的努力前置，会怎么样？然后你真的可以把自己锁起来两个星期，不仅确切地知道你在建造什么，而且知道它为什么重要。

你怎么想呢?这个树的想法有意义吗？或者，敏捷真的是理想的过程吗，其他工程学科无助地受到物理或工具的限制？你还见过哪些成功的策略？