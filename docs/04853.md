# 寻找开源贡献者(和用户:-))

> 原文:[https://dev . to/johanneslichtenberger/寻找开源贡献者和用户-30la](https://dev.to/johanneslichtenberger/looking-for-open-source-contributors-and-users-30la)

嗨，

我正在设计一个进化的、时态的开源数据存储库[1],它目前允许原生存储 XML 和 JSON 数据。

## [](#features-in-a-nutshell)概括地说特征

SirixDB 是一个日志结构的、临时的 NoSQL 文档库，用于存储进化数据。它从不覆盖磁盘上的任何数据。因此，我们能够高效地恢复和查询数据库中资源的完整修订历史。SirixDB 确保为每个新版本创建最小的存储开销。我们不依赖第三方存储引擎，而是从头开始编写。

此外，每个修订版都有索引，因此查询过去的修订版还是最新的修订版并不重要。

目前，SirixDB 提供了两种内置的原生数据模型，即二进制 XML 存储和 JSON 存储。

## [](#design-goals)设计目标

一些最重要的核心原则和设计目标是:

*   并发性——Siri xdb 包含很少的锁，目的是尽可能适合多线程系统
*   异步 REST API——操作可以独立发生；每个事务都被绑定到一个特定的版本，并且一个资源上只允许一个读写事务与 N 个只读事务并发
*   版本/修订历史–Siri xdb 在数据库中存储每个资源的修订历史，同时将存储开销保持在最低水平。读写性能是可调的。这取决于版本类型，我们可以为创建资源指定版本类型
*   数据完整性——Siri xdb 和 ZFS 一样，将页面的完整校验和存储在父页面中。这意味着将来几乎所有的数据损坏都可以在读取时被检测到，因为 SirixDB 开发人员的目标是将来对数据库进行分区和复制
*   写时复制语义——与文件系统 Btrfs 和 ZFS 类似，SirixDB 使用 CoW 语义，这意味着 SirixDB 从不覆盖数据。相反，数据库页面片段被复制并写入新位置
*   每个修订版和每个页面的版本控制——Siri xdb 不仅对每个修订版进行版本控制，还对每个页面进行版本控制。因此，每当我们更改数据页中潜在的一小部分记录时，不必复制整个页面并将其写入磁盘或闪存驱动器上的新位置。相反，我们可以在创建数据库资源的过程中指定备份系统中已知的几种版本控制策略之一或滑动快照算法。SirixDB 使用我们指定的版本控制类型对数据页面进行版本控制
*   保证原子性(没有 WAL)-系统永远不会进入不一致的状态(除非有硬件故障)，这意味着意外断电永远不会损坏系统。这是在没有预写日志(WAL)开销的情况下完成的
*   日志结构和 SSD 友好–在提交期间，SirixDB 将所有内容按顺序批量写入和同步到闪存驱动器。它从不覆盖提交的数据

## [](#roadmap)路线图

我希望在今年晚些时候发布 1.0.0 之前完成 API，增加一些性能增强，修复 bug 并听取社区的意见。

之后，我首先想到的是横向扩展 SirixDB。此外，一个 SPA 将是一个伟大的网络前端，并嵌入互动的视觉分析方法来比较修订。我也喜欢为查询引擎研究查询重写规则，以真正提高查询速度。

子目〔t0〕约翰尼斯

[1] [https://sirix.io](https://sirix.io)