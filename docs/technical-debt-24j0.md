# 技术债务

> 原文：<https://dev.to/2dsharp/technical-debt-24j0>

软件开发在任何阶段都被隐含的成本所诅咒，无论你的解决方案在任何时候看起来多么优雅。弥补你所造成的损失的代价。人类写代码，代码容易丑。随着时间的推移，这种情况会越积越多，处理这种情况是每个团队一生中都会多次面临的挑战。

在构建任何有意义的系统时，如果代码超过一页，你就开始把事情分解成碎片，如果你不是这样的话，你就应该这样做。当你开始将事物抽象成独立的小模块时，你开始考虑如何将它们组合在一起。通常，你需要添加一个微小的特性，然后再添加一个，同时尽量保持最初的结构不变。

尽管这个想法在一开始就很清晰，但这些部分并不像你希望的那样简单地组合在一起。所以，你可以稍微改变一下代码库的结构，只是一些无害的小调整。随着功能的积累，您开始看到模块结构的巨大变化。

一开始是一个干净的、结构良好的模块，现在变成了一堆杂乱无章的新增功能。在某种程度上，你不再理解它应该做什么，因为它做了太多的事情。

但是这很有效。

所以你把它丢在一边，在你的待办事项列表上打个勾，然后继续下一个模块。几天后，您的需求发生了变化，您需要再次修改该模块。或者您可能想将它与其他模块集成在一起。令人困惑的模块现在很难阅读、理解和扩展。有了它，再往前走就不可能了。

现在你有两个选择-

*   彻底抛弃它，重新开始
*   处理

除非你正在构建你的第一个应用程序，它并没有做很多事情，第一个通常不是最好的选择。尤其是在一个项目中，你投入了大量的时间去思考和开发那个模块。它可以工作，里面有一些巧妙的代码，只是变得混乱了。

现在你必须迈出一步，解决它。

这是**技术债**。就像货币债务一样，如果你不尽早偿还欠款，利息会越积越多，把你推到一个难以回头的地步。

当你想，“嘿，这个现在有效，我们可以以后再解决”你在债务陷阱中陷得更深了。技术债务是你通过选择一条更容易的道路而隐含地添加到你的项目中的额外成本，你将不得不在将来为之付出代价。

现在，原本需要你 3 天完成的工作，将需要你大约一周的时间。就是修复代码的成本(还清债务)+实现新特性的成本。

### 我如何防范技术债？

你不知道。只能最小化。把它想象成一个金融系统，做你从银行贷款时会做的事情。你逐渐支付会费。一旦你在你的模块中实现了第一个特性，你需要额外的时间来消除混乱，使之更加清晰。

是的，你确实投入了额外的时间，但是它减轻了下一个功能的负担，降低了总成本。这种逐渐消除混乱的方法使您能够修复代码中随着时间的推移需要修改最多的部分，因此也需要是最干净的。

随着时间的推移逐渐清理债务将确保债务不会随着时间的推移积累到无法挽回的地步。它帮助您在最需要的地方保持内部代码质量的新鲜。

最近，在一个系统中，我使用了一个工厂来将传输对象转换成域实体。它最初就是要这么做，但是我最终验证了数据并检查了数据中持久层的冗余。都在一个工厂里。那时候太聪明了。

最终，我在太多的地方使用了这个工厂，并添加了更多的逻辑使其更加智能。我开始很难将这些碎片连接在一起，这显然违反了 SRP。我不得不请了一天假，让工厂变得沉闷，只限于制作物品，不做太多事情。

紧密耦合是模块化系统中的一个主要缺点，甚至在最初考虑得最周全的业务逻辑中也经常会导致代码味道。随着时间的推移，耦合最终会导致您积累技术债务，并且当清理过程中某些东西停止工作时，您会感到困惑。

当你在一个紧密耦合的系统中很晚的阶段才开始偿还欠款时，你会发现自己比平时更容易破坏东西。在这一点上，支付过程变成了一场噩梦，需要付出巨大的努力来解决。

**不受欢迎的观点:**不要修正有效的东西，你很少会改变。

如果你的同事构建了一个非常好的模块，并且集成得足够好，让你可以继续下去——如果你修改得不够频繁，就不要费心去修复它。没有什么理由去修复那些令人困惑的、不需要摆弄的东西。如果它符合您的业务需求，就不要管它。

最后，**写更多的测试**。有时，我们只需要添加一个快速修复，注入一段杂乱的代码来使某些东西工作或稍微改变它的行为。我们第一眼看不到的是副作用。我们倾向于更多地关注快速解决方案是否解决了实际问题，而忽略了随之而来的副作用。测试有助于这一点，你得到即时反馈。

这就是为什么我提倡测试驱动开发。它让你在实现一个特性之前就把那些棘手的部分移走，从而降低成本。稍微增加的成本是编写这些测试的成本，但是无论如何您都必须编写它们。

技术债在软件开发中是不可避免的，它会来的。有时候，我们需要用优雅来换取工作，也就是说，早点还清欠款会让你的生活轻松很多。