# 数据是硬的。

> 原文:[https://dev.to/iangreengross/data-is-hard-5b3f](https://dev.to/iangreengross/data-is-hard-5b3f)

我理解数据。我花了十八九岁和二十岁出头的时间用与第一批基于 DOS 的关系数据库相关的语言编程——Paradox 和 DBase IV。

所以我理解数据结构和数据是什么样子的。

但是，当您试图将来自 4 或 5 个不同来源的数据合并在一起时，其中所有数据的唯一关键字是一个人的姓名，并且该人的姓名可以在每个集合中以不同方式使用(Ian Greengross、I. Greengross、IG 01 等)，那么您需要找到一种方法来统一这些关键字。

虽然我的项目只涉及 32 个人，但我不想以“廉价的方式”来做，只是手动添加列并放入我自己的密钥。

所以——我实际上不得不考虑数据，以及如何自动给每个人一个统一的密钥，以便当数据被合并时，正确的数据被分配给正确的人。

你猜怎么着？我做到了。这不是雄辩的，但正如 Zax 所说，第一条规则是——如果它有效，那就足够好了(或者他告诉我一些大意如此的事情。)

在我终于有办法确保每个人的数据都被正确地合并到他们的“记录”中之后，我不得不处理这样一个事实:我将为每个人的记录分配相同的信息类型/列名，但是是针对不同的年份，并且这些年份因人而异。

我又写了另一个不善言辞的脚本，它再次工作。但是我不得不为每个脚本重写几十行，以覆盖不同的年份，并且每当我转到不同的数据表时都要重写每个脚本。

这是我和我的导师马特第一次见面时停下来的地方。

在大约 30 分钟的时间里，Matt 向我展示了一种更有效的方式来连接数据，并且在这种方式下，我真的不必重新编写任何内容来覆盖一年中的变化，而只需在移动到我想要合并的下一个数据集时重写一些列标签。

在这 30 分钟里，Matt 帮我节省了几个小时的重写时间，还帮助我从新的角度看待和思考数据及其结构。

这使得数据变得不那么困难了。

暂时如此。