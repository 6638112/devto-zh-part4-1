# 8 分钟的库伯内特介绍

> 原文：<https://dev.to/prodopsio/an-8-minute-introduction-to-kubernetes-1oi>

核心概念、功能和构建模块

[![](img/4731ec8394535fd1e49ff27556084af9.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--bCO7LXE2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/10178/1%2AoRUsjY0iizMyIwyx8GpSeQ.jpeg)

> 这是我在完成“ [Kubernetes:启动并运行](https://www.amazon.com/Kubernetes-Running-Dive-Future-Infrastructure/dp/1491935677)”后为自己写的总结贴。我决定这将是一个强迫自己回顾我所读过的东西的好方法，并为其他寻找目标语的人总结它；医生，*如果我有，我也会的。*

构建在谷歌 [Borg](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/) 肩膀上的 k8s(“Kubernetes”)是一个容器[编排系统](https://www.mongodb.com/containers-and-orchestration-explained)；非常强大的一个。K8s 及其整个生态系统(工具、模块、插件等)都是用 Golang 编写的，这使得它本质上是一个面向 API 的、非常快速的二进制程序的集合，这些二进制程序都有很好的文档记录，并且易于贡献或构建应用程序。

它有一些核心概念，任何开发人员/运营人员/感兴趣的读者都应该熟悉，以便掌握该系统及其不同的功能，并理解为什么几乎每个人都在使用它。

在继续之前，我想提一下 k8s 的顶级朋友(或对手):ECS，Nomad 和 Mesos。ECS 是 AWS 自己的编排解决方案，最近推出了 EKS——AWS 上的托管 k8s 系统。两者都提供了 FARGATE，允许用户忘记运行物理资源。

虽然 k8s 毫无疑问是采用数量的大赢家，这是它作为开源系统的一个功能，但它也可以在三大云提供商的托管形式中使用；然而，它比其他的更复杂和纠结。K8s 可以处理几乎任何类型的容器化工作负载，并且有很多诀窍，但这并不意味着每个人都应该运行它。公司可以对其他解决方案感到满意，例如，只部署在 AWS 上的互联网产品公司有更好的机会享受使用 ECS 而不是 k8s 的生产生活，是的，而不是 EKS。

话虽如此，k8s 有它的魔力——它可以部署在任何地方，它有一个由数百名核心开发人员组成的活跃社区，以及围绕它的广泛生态系统中数以千计的其他开源贡献者。它是快速的，创新的，模块化的和面向 API 的，使它成为一个超级友好的系统来构建附加组件或服务。

## 那么事不宜迟，就这么办吧；11 步 k8s 简介:

### 1。分离舱

吊舱，是 k8s 中最小的可交互单元。一个 pod 可以由多个容器组成，这些容器将形成一个部署在单个节点上的单元。一个 pod 接收一个 IP，该 IP 在其容器之间共享。
在微服务世界中，pod 是微服务的一个实例，它做一些后台工作，或者服务于传入的请求。

### 2。节点

**节点**是机器。它们是 k8s 部署其 pod 的“裸机”(也可以是虚拟机)。节点为 k8s 提供可用的集群资源来保存数据、运行作业、维护工作负载并创建网络路由。

### 3。标签&标注

标签是 k8s 及其最终用户过滤系统中相似资源的方式，它们也是一个资源需要“访问”或关联到另一个资源的粘合剂。例如，希望为部署打开端口的服务。无论是为了监控、日志、调试、测试，任何 k8s 资源都要贴上标签，以便进一步检查。例如:app=worker，一个给系统中所有 worker pods 的标签，以后可以使用 kubectl 工具或 k8s api 使用- selector 字段选择它。

注释与标签非常相似，但通常用于以自由格式字符串的形式保存不同对象的元数据，例如“*变更原因:升级安全补丁的应用程序版本*”。

### 4。服务发现

作为一个协调者，k8s 控制着不同工作负载的许多资源，为 pod、作业和任何需要通信的物理资源管理网络。为了做到这一点，k8s 使用了 [ETCD](https://kubernetes.io/docs/concepts/overview/components/#etcd) 。
ETCD 是 k8s 的“内部”数据库，主人用它来知道所有东西的位置。K8s 还为您的服务提供了实际的“服务发现”——它使用所有 Pods 都在使用的自定义 DNS 服务器，您可以解析其他服务的名称以获得它们的 IP 地址和端口。它在 K8s 集群内部“开箱即用”,不需要任何设置。

### 5。复制集

虽然 pod 是一个物理运行任务，但通常使用它们的单个实例是不够的。对于冗余和负载处理，由于各种原因，即“扩展”，必须复制 pod。为了实现负责缩放和复制的层，k8s 使用了 **ReplicaSets** 。这一层用副本的数量来表示系统的期望状态，并保存系统在任何给定时刻的当前状态。

这也是配置自动扩展的地方，当加载系统时会创建额外的复制，当不再需要这些资源来支持运行的工作负载时会进行扩展。

### 6。达蒙塞特

有时，某些应用程序在每个节点上只需要一个实例。一个很好的例子是日志收集器，比如 [FileBeat](https://www.elastic.co/products/beats/filebeat) 。为了让代理从节点收集日志，它需要在所有节点上，但只能在一个实例上。为了创建这样一个部署的工作负载，k8s 有 **DaemonSets** 可以实现这一点。

### 7。状态集

尽管大多数微服务世界都涉及到不可变的无状态应用程序，但有些却不是。有状态工作负载需要某种磁盘卷的可靠支持。虽然应用程序容器本身可以是不可变的，并且可以被更新的版本或更健康的实例所替换，但是它们需要其数据的持久性，即使有其他复制。为此， **StatefulSets** 允许部署在其整个生命周期中需要使用相同节点的应用程序。它也保留了它的“名字”；容器内的`hostname`和跨集群的服务发现中的名称。由 3 个动物园管理员组成的状态集可以命名为 zk-1、zk-2 和 zk-3。它还可以扩展为包括其他成员，如 zk-4、zk-5 等。状态集还可以管理 PersistentVolumeClaim(s)(连接到 pod 的磁盘)。

### 8。乔布斯

K8s 核心团队已经考虑了绝大多数使用编排系统的应用程序。虽然大多数都需要持续的正常运行时间来同时处理服务器请求(例如一个 web 服务器)，但我们有时需要一批作业在完成后产生并清理。一个小型的无服务器环境。为了在 k8s 中实现这一点，我们可以使用**作业**资源。工作就像它们听起来的那样，是一种工作负载，它旋转容器来完成特定的工作，并在*成功完成*时被销毁。一个很好的例子是一组工人，他们从要处理和存储的数据队列中读取作业。一旦队列为空，就不再需要工人，直到下一批准备好被处理。

### 9。配置地图&的秘密

如果你还不熟悉[十二因素应用清单](https://12factor.net/)，你应该熟悉一下。现代应用程序的一个关键概念是无环境和可从注入的环境变量配置的[。应用程序应该完全不知道它的位置。为了在 k8s 中实现这个重要的概念，我们给出了**配置图**。这些基本上是键值环境变量的列表，它们被传递给正在运行的工作负载，以便确定不同的运行时行为。在相同的范围内，我们有**秘密* *，其*** *类似于正常的配置条目，除了被加密以防止诸如密钥、密码、证书等敏感信息的泄露。](https://12factor.net/config)

> 我个人知道在任何系统上使用秘密的最佳选择是 Hashicorp 的保险库。请务必阅读我去年写的一篇关于它的文章，关于你为什么希望 Vault 成为你作品的一部分的原因，以及我的一个同事写的另一篇很棒的和一篇[更技术性的文章](https://medium.com/prodopsio/taking-your-hashicorp-vault-to-the-next-level-8549e7988b24)。

### 10。部署

当你让你的 pod 运行时，一切都很好，即使上面有一个副本集，当负载要求很高时也可以扩展。但是我们聚集在这里是为了用新版本快速替换我们的应用程序。我们希望以小块的方式构建、测试和发布，以享受[短暂的反馈循环](https://www.ibm.com/developerworks/community/blogs/beingagile/entry/short_feedback_loops_everywhere?lang=en)。K8s 让我们可以使用**部署**不断地部署新软件；一组元数据，描述某个运行中的工作负载的新需求。一个很好的例子就是一个新版本、一个 bug 修复，甚至是一个回滚(这是 k8s 的另一个内部选项)。

在 k8s 中部署软件有两个主要的*策略*可以使用:

1.  替换——顾名思义，用新的需求替换您的整个工作负载，自然会强制停机。有利于快速替换非生产资源。

2.  RollingUpdate — k8s 通过监听两个特定配置来慢慢地用新容器替换容器的方式:a. MaxAvailable —部署新版本时工作负载的可用百分比(或确切数字)的设置，100%意味着“我有 2 个容器，保持 2 个活动，并在整个部署过程中为请求提供服务”。b. MaxSurge —设置要在当前活动的工作负载之上部署的工作负载的百分比(或数量)，100%意味着“我有 X 个容器，部署另外 X 个容器，然后开始推出旧的容器”。

### 11。储存；储备

K8s 在存储之上增加了一层抽象。工作负载可以为不同的任务请求特定的存储，甚至可以管理超过某个 pod 生命周期的持久性。为了长话短说，我想让您参考一下[我最近发表的一篇关于 k8s 存储](https://medium.com/prodopsio/k8s-will-not-solve-your-storage-problems-5bda2e6180b5)的文章，特别是为什么它不能完全解决像 DB 部署这样的数据持久性需求。

## 概念性理解

K8S 过去是(现在仍然是)根据几个指导方向设计和开发的，每个功能、概念和想法都是根据社区的性质构建到系统中的。此外，最终用户被引导以某种方式使用系统，尽管从未被强迫；最佳实践是众所周知的，但是作为一个不属于任何人的开源免费系统，你可以做任何你想做的事情。

面向 API——系统中的每个部分都是以一种方式构建的，它可以通过一个良好记录和操作的 API 进行交互。核心开发人员确保您作为最终用户可以进行更改、查询和更新，这样您就永远不会被封闭在屏蔽或不需要的过滤器后面。

欢迎包装工具——作为上一点的衍生工具，k8s 欢迎围绕其 API 构建的工具和包装器。它介绍自己是一个原始平台，以一种非常可定制的方式构建，供其他人使用，并为不同的用例进一步开发工具。有些已经变得非常有名，并被广泛使用，如 [Spinnaker](https://www.spinnaker.io/) 、 [Istio](https://istio.io/) 和许多其他的。

声明性状态——鼓励用户使用带有声明性描述的系统，而不是命令性描述。这意味着，系统的状态和组件最好被描述为在某种版本控制(如 git)中管理的代码，而不是导致某一点的手动更改的结果。这样 k8s 更有 [DR](https://en.wikipedia.org/wiki/Disaster_recovery) 抗性，便于团队间共享，传递责任。

## 就是这样

试图把重点放在 k8s 的介绍和主要概念上，这是向这个伟大的系统介绍时需要知道的事情的列表。
当然，k8s 还有其他非常重要的领域，如物理系统构建模块，如 *kubelet* 、 *kube-proxy* 、 *api-server* 和终极控制工具——*kube CTL*。我将在下一篇文章中讨论这些和其他一些很酷的特性。请务必关注并继续关注更多内容。

我叫 Omer，是一名工程师，在 [ProdOps](http://prodops.io) 工作，这是一家全球咨询公司，采用 Devops 文化，以可靠、安全和简单的方式提供软件。请在下面的评论中告诉我你的想法，或者直接在 Twitter [**@** omergsr](https://twitter.com/omergsr) 上与我联系。如果你喜欢拍手，它帮助我集中我未来的写作。