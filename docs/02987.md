# 微服务和多交付流

> 原文:[https://dev . to/tonyhicks 20/microservice-and-multiple-delivery-streams-35g 4](https://dev.to/tonyhicks20/microservices-and-multiple-delivery-streams-35g4)

你的工作已经完成好几天了。你已经测试过了，QA 团队也测试过了。产品所有者已经测试了它，船上的每个人都希望它能从准备阶段进入生产阶段。只有一个问题——其他人的代码已经被合并进来并引起了问题。它甚至不在系统的同一个部分，但是它现在在你的 staging 分支中，并且它与其他代码太紧密地联系在一起，以至于不能负责任地挑选出你想要发布的变更。

[![Waiting](img/271949516b2a0cf4e7e2732e06f9e471.png)T2】](https://i.giphy.com/media/o5oLImoQgGsKY/giphy.gif)

因此，您现在不得不在发布代码之前等待代码被修复和测试。听起来熟悉吗？

## [](#enter-microservices)进入微服务

走微服务路线意味着你已经将你的代码库分成了更小的、独立的模块。每个模块基本上(尽可能)是一个自包含的实体，可以单独部署，而不必太担心其他服务中已经准备好了什么。

事实上，将每个服务看作是他们自己的完全独立的小公司是一个好主意！就像与第三方集成时一样，他们可以自由地更改自己的系统，并按照自己的计划进行部署。

不再需要等待系统的其他部分准备就绪！部署您的更改！

[![Party!](img/206348fa3db1bf1df1885496e1f21879.png)T2】](https://i.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif)

不完全是。微服务之间还是需要沟通的，可能还需要和外界沟通。因此，如果您正在更改服务的任何面向公众的方面，您将必须确保您的调用版本正确，并提供向后兼容性，以便系统的其他部分在部署服务后仍能工作。

此外，如果您的服务依赖于部署在不同服务中的新更改，并且**该**服务被阻止，您的部署仍可能被阻止！

你必须永远记住，你的服务会有客户，同时也是其他服务的客户。

不幸的是，微服务不会解决你的相互依赖问题，但如果你在识别服务的有界上下文方面做得很好，*你的大多数*变化将是内部的，这意味着你绝对可以在服务准备就绪时进行部署。

## [](#do-you-really-need-microservices-to-achieve-this)你**真的**需要微服务来实现这个吗？

大概不会。我只想强调这是使用这种架构的另一个好处。

如果您为特性分支创建环境，并在将新的变更合并到阶段化或生产中之前，在这些环境上进行业务测试，那么您可以获得非常相似的结果。然而，这并不是一件小事。

## [](#but-wait-theres-more)但是等等，还有更多

代码库分离的另一个好处是，您现在可以保护代码的某些部分免受特定人员的侵害。也许你不想让初级开发人员接触系统的核心逻辑？

现在，您可以通过简单地拒绝他们访问该服务的代码来实现这一点。

同样，这也不是解决这个问题的唯一方法——你应该有自动化的单元和集成测试来确保这种情况不会发生，并且至少由 3 个高级开发人员和天主教教皇进行代码审查的分支策略——但是以我的经验来看，应该发生什么和确实发生了什么通常是两码事。

有些项目没有测试。单元测试可能会遗漏一些东西，集成测试可能会很慢，并且只是偶尔运行一次。即使是高级开发人员也有可能错过一些事情，教皇可能只是那天太忙了，没有时间试图驱除你的代码(我被要求请停止给梵蒂冈打电话)。

因此，就像在实施模块化的情况下，因为它不可能直接引用你不应该引用的代码，它也创造了机会，使人们不可能更改他们不应该更改的系统部分。

[![Hallelujah!](img/86b216b7d98a8ff151c79e2b67031ec2.png)T2】](https://i.giphy.com/media/BoIUmD3M39B0rTCF4I/giphy.gif)