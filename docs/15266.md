# a，P，I -把单词拼在一起

> 原文：<https://dev.to/voanhcuoc/a-p-i-put-together-the-words-1h89>

*API 的另一个介绍*

*原文：<https://write.as/voanhcuoc/a-p-i-put-together-the-words>T3】*

# 上下文

目前，我正在指导我的一些朋友如何开发软件。他们很聪明，他们知道如何编码，但是没有接触过软件开发过程。我碰到的第一块石头是向他们解释**什么、为什么以及如何做 API** (应用程序编程接口，**广义上的** )。

看在上帝的份上，我是一个懒惰的人，所以我只是想在互联网上搜索一些博客帖子或讲座，这通常会比我解释得更好。但是没有，没有这样一篇文章来表达我的理解。维基百科的帖子很好，但是被新手弄得无法学习。终于有了自己写帖子的冲动！

# API -一个重载术语

从这篇文章中学习的最好方法，是先自上而下地读一遍，然后再以每一部分为单位自下而上地读一遍。

## Web API

由于云计算和微服务架构的兴起，单词 *API* 在常识中的意义几乎已经被 *Web API(即通过网络，主要是互联网公开的 API)*所取代。

> 当业务人员提到 *API* 时，他们总是指 *Web API* 。

这一个，虽然应该被放在学习路径的后面，但是总是出现在第一个 Google 搜索结果中。

## SDK(软件开发工具包)

*API* 不是 *SDK* 反之亦然。反正是不同的概念。

*SDK* 是技术保护伞下的一个术语。技术提供商可能会给你一个 *SDK* ，这样你就可以构建利用或应用他们技术的软件。(例如，您可以使用 *Kinect SDK for Windows* 来应用 *Kinect 技术*)

一个 *SDK* 就是一个工具包。工具包由工具组成。而且它里面通常都有一个 *API* 。 ***API* 就 *SDK* 而言，是一个工具**。

> *SDK* 通常由**至少一个*API*T5 组成。
> *API* 可以单独提供**或者在 *SDK*** 中提供**。****

 **这里至关重要的是，从将 *API* 视为工具的角度出发，对 *API* 有了新的理解。

> 当*应用软件开发者*提到 *API* 时，他们大多指的是作为工具的 *API* 。

要明确的是*应用软件开发者*是设计或实现用户界面的人，而不是设计或实现 *API* 的人。他们只使用 *API_s .对 _API 作为工具*的理解对他们来说就足够了...

## 编程接口-P 和 I

...但是对于 API 开发者 T1 来说却不是这样，他们 T2 创建了 API T3。

用户界面和编程界面有很大的不同。用户是活生生的人，他们可以调整自己的行为来适应界面，而计算机是一台没有大脑的机器，很难做到这一点(除非有意识地付出巨大的努力来这样做)。

*应用开发者*可以利用*人的常识*来制作用户界面。 *API 开发者*只有一些*社区约定*，仅供参考，不可依赖。

例如:

*   窗口角落的红色关闭按钮可以用来退出整个程序，或者只是最小化它——这取决于它是哪个程序。如果行为不是他们首先期望的，用户可能会感到困惑，但是他稍后会很快了解到这一点。

*   在使用 Python 的科学界，有一个惯例，大多数时候矩阵由`numpy.ndarray`数据结构表示。这很好，但你不能依赖它，在对这些矩阵使用`numpy.ndarray` API 之前，你必须通过查看官方信息源来确认它。如果你这样假设并开始编码，那么你的程序可能会崩溃，你会惊讶地发现矩阵是由不同库中的不同数据结构表示的。

你会注意到，术语*编程接口*(没有*应用*)很少在外面使用。人们到处说 *ey - pee - eye* 。

这很合理，曾经创建的每一个*编程接口*的目的都是**应用**一个软件。如果不是，那是什么？从我的经验来看，我不能指出*编程接口*不是为了应用软件而创建的。

所以， *API* ≈ *编程接口*

> *API 开发者*将他们开发的软件视为一个系统，API 是系统向其他软件程序公开的*接口*。

## 界面-I

让我们总体上建立一个*接口*的概念模型。

*接口*定义了一个*个体系统*如何与外界交互。在分析层面上，*接口*是我们考虑的关于系统的一切，所以我们可以说:

> *接口*定义了*系统*。

例如，每天你走进便利店(如 Circle K)买东西，下面是对所发生情况的逐步描述:

1.  首先，*店员*向你打招呼。
2.  你问她要一些东西，她告诉你在哪里。
3.  你到那里选择你想买的东西。
4.  你拿给她，她告诉你价钱。
5.  你给她钱，然后拿着东西离开商店。

每天，你来到商店，遇见不同的店员:昨天是凯伦，今天是莎拉，明天是海伦...但是你和她总是经历和我上面描述的一样的过程。总而言之:

1.  凯伦，莎拉或者海伦，...实现*店员接口*(如上所述)。
2.  你与一名店员互动购买物品。

作为顾客，所有这些女孩对你来说都是一样的。作为分析等级，你们的*是不是同一个*系统。

> 该系统由上面的*接口*定义，因此命名为*店员*。

让我们在此澄清角色:

*   你是*界面*的**用户**。
*   女孩们和商店经理一起提供商店里可用的*界面*。他们是*界面*的**开发者**。
*   女孩们和她们的*店员界面*组成了更大的**系统**(商店)的多个**子系统**。
*   由于相同的*接口*，它们可以互换。所以没有每个女孩每天的出现。店里还能*曝光**店员界面*，每天都有。

> 一个接口可以由多个*系统*实现。(每个都被称为该接口的一个*实现*

*但是有问题！这些女孩是人，她们是不同的...*

是的，当然。有一天你觉得凯伦很可爱，想和她调情。过了一会儿，她同意和你约会。你们一起吃午饭，散步，谈论爱好和家庭，然后做爱...现在凯伦不同于莎拉和海伦。

> 凯伦给你曝光*情人界面*。

但对我来说，她还是和其他女孩一样。作为顾客的你也一样:不管你们是不是情侣，你仍然可以去那家商店向 Karen 询问商品信息，她仍然为你实现*店员界面*。

> 一个*系统*可能会暴露多个接口。

界面就像一片水。你拿一杯水，倒进两个杯子里，一个给你，一个给凯伦。撞！你有两块水，因为你已经给它们命名了。凯伦是由她暴露给世界的界面定义的。如果你像我上面这样把她的接口拆分成多个接口，那么我们可以认为她公开了多个接口:*店员*、*情人*、*朋友*、*孩子*、...

待续...

*TODO 将性能写为实现的质量(在理想情况下，实现 100%符合接口)***