# 你只讨厌你不知道的东西

> 原文：<https://dev.to/michaeljota/you-only-hate-what-you-don-t-know-1egn>

> 图片由 [andreas160578](https://pixabay.com/users/andreas160578-2383079/) 提供

我最近发现这个反对 TS 的精彩帖子:[为什么我讨厌 TypeScript](https://gist.github.com/amcdnl/b52e9dd11850eeb8de8f) 。我甚至写了我自己的版本，[这就是为什么我讨厌打字稿](https://dev.to/michaeljota/this-is-why-i-hate-typescript-3da0)，但似乎我并不像我想的那样有趣，许多人不喜欢它，他们中的一些人甚至因此非常生气。也许值得一提的是，这篇文章没有包括第一个免责声明，我暂时将 TS 从我的简历中删除。但是，我想适当的写一下 TS，就是这样。

# 打字稿不标准

这其实是真的。Typescript 本身不是一个标准，它是 JavaScript 的超集。这意味着任何用 JavaScript 编写的有效程序对于 Typescript 编译器来说都是有效的程序。此外，Typescript 将尝试遵循 ECMAScript 规范中的任何有效标准，即阶段 3 或更高版本。

当然，当 TS 最初被创建时，设计者抓住机会实现了他们自己的模块，现在命名为名称空间，他们自己的公共和私有成员和属性，以及其他一些东西。但那几乎是 5 年前的事了。这是 web 开发的一生。几乎与 Node 0.12 同时发布。有人记得那个节点的问题吗？

在同一个版本中，TS 引入了 decorators，这是对 TC39 的实际提议。当 decorators 被引入时，他们处于第一阶段，从这个阶段到下一个阶段，他们经历了一次大规模规范重写。因此，TS 对 decorators 的实现现在是一个永远不会成功的遗留实现。

他们现在要求提案在第 3 阶段实施，这只是为了避免 TS 中的实施与最终规格不同的情况，因为提案在第 3 阶段时规格不能更改。

我将举两个提案的例子，自从它们第一次进入第一阶段，我就一直在关注它们。

*   [无效合并](https://github.com/tc39/proposal-nullish-coalescing)打字稿[第 26578 期](https://github.com/microsoft/TypeScript/issues/26578)
*   [可选链接](https://github.com/tc39/proposal-optional-chaining)打字稿[第 16 期](https://github.com/microsoft/TypeScript/issues/16)

两者都有望在 3.7 版本的 Typescript 中引入，就在它们最终达到阶段 3 的几个月后。

> 不，Typescript 不是一个标准，但是它遵循 JavaScript 规范，尽可能地引入了每个版本对 JS 新特性的支持。

# 不受群体驱使

这是我能找到的更有争议的一个。我知道严格来说，决定 TS 走向的并不是一个社区团体，但是 TS 团队非常重视社区反馈，他们开发的许多功能都是基于此。此外，我认为 Typescript 的路线图在大多数情况下是清晰和一致的。他们甚至从 2 个月的发布周期移动到 3 个月的发布周期，在得到社区的反馈后，我们想要更稳定的 TS 版本，即使这意味着更少的版本。

> TS 以极大的责任感接受社区反馈，他们会调查列出的功能和改进。

# 在一种非类型化的语言中输入类型是很难的

我想在此摘录一个关于该声明的论点:

> 写这篇文章的人在他们开始之前并不是 JavaScripters 高手，这可能没有帮助，但这只是我个人的想法。

他怎么知道的？我不知道。请，如果你知道 TS 背后的人，请，我也想见见他们。

没有非类型语言这种东西。所有的语言都有一个打字系统。他的意思是在动态类型语言中有一个严格的类型语言。但是，即使是他的意思，Typescript 也只是增加了*可选的*静态类型。而且可选的部分真的很重要。然而，我不认为有人会把 TS 仅仅作为一个代码转换器，但是他们可以。此外，理解静态类型也很重要。现在没有，将来也不会有严格的类型检查器，因为它需要运行时类型检查器，这是 TS 团队的[非目标](https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals)。

如果你读了目标和非目标的列表，你会惊讶于 TS 是如何愿意让静态打字工作的。他们不想要稳健，而是在正确性和生产力之间寻求平衡。个人觉得这才是 TS 真正出彩的地方。

> Typescript 编译器使用的静态类型系统可能很难理解，但实现起来并不难。即使这样，我们也不应该太在意它的实现，因为对我们来说，大多数时候它只是工作而已。

# 巴别塔更好

Babel 没有任何类型检查系统，所以这真的是另一回事。在比较 Babel 和 TS 的 transpilation 时，我更喜欢 TS，但我也不会用那个，所以我觉得真的不重要。

如果你认为 Babel 更好，因为它是插件系统，插件系统主要用于在 transpiler 中实现新的提议。正如我们所见，这并不总是一件好事。在生产中，您应该始终使用第 3 阶段或更高阶段的提案。

> 有不同的工具，有不同的目标，所以我不认为一个比另一个好。两者都有自己的用例。Babel 7 可以传输 TS 源代码，TS 从 1.8 开始可以传输 JS 源代码，但是，Babel 不会类型检查 TS 源代码，TS 可以类型检查 JS 源代码，如果它有类型注释的话。

# 打字稿定义

现在，在 Typescript 服务器中有了自动类型获取，因此，如果您有一个依赖于 TS 服务器的 IDE，它可以使用它来改善您的编码体验。然而，这只适用于 JS 文件。对于 TS 文件，您仍然需要安装类型定义，但是大多数情况下 TS 会告诉您需要安装哪个模块才能使它工作，并且它很可能是您正在使用的带有`@types/`前缀的同一个包。因此，没有打字，或任何其他需要安装的东西。它们现在是普通的 npm 模块。

> 自从引入了`@types/`范围的包以来，类型脚本定义的获取已经得到了改进。

# 不知道我可以使用什么语言功能

正如我已经说过的，第三阶段或更高阶段的 JS 提案可能已经实现了，或者已经在将要实现的路线图中。其他早期的提议可能已经实现了，但是实现可能与当前的规范不同，就像 decorators 的情况一样。但是，为了使用这些功能，您需要在中为 Typescript 编译器添加一个显式设置。

> 使用阶段 3 或更高版本的功能可能是安全的。如果你还不会用，那也没办法。(键入安全用语)。

# 他们说谎

所以，我真的不知道作者在这篇文章中的观点。我不得不说，如果你知道如何为编译器配置选项，你真的可以想放多少就放多少。如果不这样做，编译器默认会打开一些严格的设置，这在大多数情况下是有帮助的。

如果你发现自己在任何地方写`any`，我不认为问题是 TS。您应该考虑通过使用静态 linters，比如 TSLint，来避免使用`any`。相反，你可以使用`unknow`，它是`any`的类型安全等价物，或者更好，只是花费一些时间来更好地表达对象的预期用途。

# 流量呢？

虽然 Flow 是一个出色的项目，我不得不说，Flow 引入的几个想法后来也在 TS 中引入了，但我认为 Flow 与 Typescript 的最佳论点是用法，Typescript 的用法在改进，而 Flow 在减少。

我对 TS 和 Flow 有自己的看法，那就是当你写 TS 的时候，你只要看一下文件扩展名就知道了。但是 Flow 就像常规 JS 之上的一个静态插件。然而，TS 有一些 Flow 没有的特性，同样。如果你想更好的比较它们，检查 [Typescript 和 Flowtype](https://github.com/niieani/typescript-vs-flowtype) 。

* * *

这涵盖了主要作者的论点，但如果你看评论部分，它有几个其他反对 ts。

* * *

# 是 JavaScript 给懂 Java 和 C 的人用的

我不认为 TS 是为习惯于使用 Java 或 C#的程序员而设计的 JS，但他们肯定会发现 TS 是 JS 中复杂概念的替代物。他们不知道的是，我真的想强调这一点:

> Typescript 不是一种严格的语言，只有当你真正理解 JS 时，你才能充分利用 TS。否则，你只是在一个非常高的攀爬的边缘玩耍，迟早你会掉下来。

想学 Typescript，先学 JavaScript。然后，你将能够知道这实际上是 TS 为你做的。剧透:这不是魔术。抱歉。

# 有角就有角

那也许是真的。但是，你真的应该考虑扩大你的舒适区。TS 现在正在被几个项目使用，包括 [Vue](https://hub.packtpub.com/vue-js-3-0-is-ditching-javascript-for-typescript-what-else-is-new/) 、 [Nest](https://nestjs.com/) ，甚至 [Jest](https://jestjs.io/) 也在今年从 Flow 迁移到 Typescript。

# 有 ESLint 来捕捉类型错误，有 PropTypes 来捕捉运行时的类型错误

我不会说你不能用 ESLint 创建一个相当好的类型检查系统，但是如果你这样做了，那么你就承认你需要一个静态类型检查系统，并且你正在创建你自己的版本。如果使用 PropTypes，情况也是如此。有趣的是，我曾在一个项目中使用 PropTypes 来进行 Typescript，即使当时对 Typescript 的 React 支持还不太好，但这对开发时间来说是一个不可思议的改进。

* * *

还有其他人。我肯定有，我也肯定还会有其他的。然而，我只是想用正确的方式解释，把那些论点当作绝对真理是完全错误的。

# 打字稿是帮你的

作为大型 JS 生态系统中的任何其他工具。您有几个其他的工具来帮助自己改善编码体验。如果你只是抱怨 TS 不能做什么，而不是寻求 TS 能为你做什么，我不认为这是 TS 的问题。如果你在尝试用 TS 做一件事，而你发现自己连 JS 都做不到，但你觉得 TS 会做得更好，同上，不是 TS 的错。

不要因为不了解某件事，或者低估了某件事，就*讨厌*这件事。相反，花时间真正了解静态类型系统如何帮助您的团队改善编码体验。