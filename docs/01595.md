# 每日挑战#70 -撑杆跳比赛结果

> 原文：<https://dev.to/thepracticaldev/daily-challenge-70-pole-vault-competition-results-3al4>

你的挑战是在有几个竞争者参加的撑杆跳比赛中确定前 3 名决赛选手。对于那些不知道规则的人来说，这可能会非常混乱。

作为输入，您将收到一个对象数组。每个对象包含各自竞争者的名字(作为一个字符串)和他们在不同高度的成绩(作为一个字符串数组):

```
[{name: "Sergey", results: ["", "O", "XO", "O", "XXO", "XXX", "", ""]}
{name: "Jan", results: ["", "", "", "O", "O", "XO", "XXO", "XXX"]}
{name: "Bruce", results: ["", "XO", "XXO", "XXX", "", "", "", ""]}
{name: "HerrWert", results: ["XXX", "", "", "", "", "", "", ""]}] 
```

空字符串表示由于各种可能的原因(例如，在这个高度“通过”，被临时叫去参加另一个田径项目，已经退出比赛，或因受伤退出比赛)，该运动员没有在这个高度跳跃。

字符串中的大写 X 表示在该高度的尝试不成功。(你可能知道，连续三次试跳失败后，这位撑杆跳高选手就被淘汰了。)

大写的 O 代表一次成功的尝试。如果存在的话，这将是字符串中的最后一个字符，因为它表明运动员现在已经成功地完成了这个高度，并准备继续前进。

* * *

第一步应该是确定谁成功越过了最高高度。谁在比其他竞争者更高的数组元素上有一个“O”标记？在最直接的情况下，你可以通过这个逻辑来确定最终入围者。

但是如果有一个并列的名次呢？进行如下操作:

首先回溯找到两名运动员成功跳过的最高高度。然后确定谁在该高度的尝试失败次数最少(即，在该高度的字符串中 X 最少)。这个人赢得了决胜局。

但是如果他们仍然被绑在一起呢？不要继续追溯过去！相反，比较他们在比赛中所有高度的不成功尝试的总数。总失误次数最少的运动员赢得决胜局。

但是如果他们仍然打成平手呢？这取决于整理的地方:

*   如果是第二名或第三名，平局仍然有效(即没有被打破)。
*   但如果是争夺第一名，就必须有一个跳投(像其他运动中的加时赛或点球)来打破平局，决定胜负。(这种跳跃发生在——假设——你的代码运行之后，因此不是这个挑战的一部分。)

返回一个对象作为结果。包括在结果中的每个名次结束应该有其值作为各自的运动员的名字。如果出现平局，该属性的值是所有并列选手的姓名，按字母顺序排列，用逗号分隔，后跟表示并列第一名的符号(jumpoff)和表示并列第二或第三名的符号(tie)。

下面是一些可能的结果:
`{1st: "Jan", 2nd: "Sergey"; 3rd: "Bruce"}`(这些结果对应于上面给出的样本输入数据。)【T6`{1st: "Julia", 2nd: "Madi, Emily (tie)}`
`{1st: "Caleb, Dustin (jump-off)", 3rd: "Sam"}`
`{1st: "Meredith", 2nd: "Maddy", 3rd: "Cierra, Sara (tie)"}`
`{1st: "Alex, Basti, Max (jump-off)"}`

下面是测试数组:
`{"name": "Linda", "results": ["XXO", "O","XXO", "O"]}`
`{"name": "Vickie", "results": ["O","X", "", ""]}`
`{"name": "Debbie", "results": ["XXO", "O","XO", "XXX"]}`
`{"name": "Michelle", "results": ["XO","XO","XXX",""]}`
`{"name": "Carol", "results": ["XXX", "","",""]}`

祝你好运！

* * *

这个挑战来自 CodeWars 用户 HerrWert。感谢 [CodeWars](https://codewars.com/) ，他在 [2 条款 BSD 许可](https://opensource.org/licenses/BSD-2-Clause)下许可了这个挑战的再分发！

想为未来的帖子提出一个挑战性的想法吗？发送电子邮件给**[yo+challenge @ dev . to](mailto:yo+challenge@dev.to)**提出您的建议！