# 在野外使用大 O 符号

> 原文:[https://dev . to/peternycander/using-the-big-o-notation-in-the-wild-200d](https://dev.to/peternycander/using-the-big-o-notation-in-the-wild-200d)

我看到很多人被大 O 符号吓到了，我理解。这是一个数学问题，对很多人来说数学是可怕的。

我有计算机科学的硕士学位，说实话，第一年左右，大 O 符号对我来说也很可怕。但是教授们每年都在谈论它，它变得不那么可怕了。

在“野外”，这些知识在绝大多数的日常工作中被证明是无用的。但是有一种模式，我看到很多人重复使用，这有可能使服务器响应时间和负载变得更糟，如果他们知道一个与大 O 符号相关的简单技巧的话。

## [](#the-scenario)场景

想象以下场景:您集成了两个不同的服务。它们都返回一个人员列表。一个人只有关于他的职业的数据，一个人只有他的名字。您希望将这些合并到一个列表中。在这个场景中，它们共享一个 id，但是列表没有排序。

我观察到的模式是遍历其中一个列表，并在这个循环中尝试`.find`第二个列表中的相应项目。它是有效的，当你读它的时候，它很有意义。它也有比它可能有的更糟糕的时间复杂性(大 O“措施”)。

### [](#analyzing-the-time-complexity)分析时间复杂度

大 O 符号的意思是当列表中的人数增加时，会如何影响运行时间？(或者记忆，但是让我们关注时间)。它也只关心最坏的可能情况，也就是列表排序的最大坏运气。

在我们的例子中，对于列表中的每个人，我们将不得不潜在地查看另一个列表中的每个人，以将他们配对在一起。让我们称名单中的人数为`n`，这是(愚蠢的？)规范。为了创建*一个*完整的人，我们可能需要通过使用`.find`来查看列表中的`n`项。

这项工作必须为所有`n`人重复进行。这意味着时间复杂度将是`O(n*n)`或`O(n^2)`。我们可以做得更好。

### [](#the-easy-fix)轻松搞定

我们可以更快地在另一个列表中找到相应的人。在 javascript 中，我们可以为此使用一个简单的对象`{}`。在其他语言中，你应该寻找叫做`Map`或`dict`或类似的东西。

您需要做的是做一些前期工作来创建一个 lookup 对象，如果您有 id，就可以在其中获得 name 对象。它看起来会像这样:

```
const lookup = {
  "13": {
    name: "Robert",
    id: "13",
  },
  "52": {
    name: "Julia",
    id: "52",
  },
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

那样的话，不用用`.find`来获取名字，你可以做`lookup[id]`。好处是，通过计算机的魔力，从一个对象获取一个值非常快。事实上，当我们用大 O 符号谈论它时，我们甚至没有注意到它。据说要花恒定的时间。它的意思是，不管对象中有 100 个还是 10000 个项目，获取项目花费的时间都差不多。

如果你不相信我的话，我做了一个[码笔给你看](https://codepen.io/peternycander/pen/orbdvO)。

### [](#the-time-complexity-of-the-fix)修复的时间复杂度

由于`lookup[id]`需要的时间是常数，所以我们不用大 O 记数法来计算。这意味着我们仍然要看每个人一次，对于那个人，我们只做持续的工作。这意味着我们只剩下`O(n)`。对于大多数问题来说，这是一个很大的时间复杂度，这是我们在这种情况下所能做的最好的事情。

然而，我们有额外的准备工作。我们实际上循环了列表两次。那是`O(2*n)`，但是关于大 O 符号的一件奇怪的事情是我们简单地删除任何常数。这意味着`O(2*n) = O(n)`。

这种奇怪是因为大 O 符号实际上并没有转化为一个算法需要多长时间。它只转化为输入大小增加时时间增加的数量级。

* * *

时间复杂性在日常工作中很少是重要的，但它确实偶尔会出现。从本文中您可以了解到，一旦您看到一个循环在另一个循环中，您可能会看到时间复杂度很高的代码。仔细想想这是否重要，你是否可以用上面的技巧来解决它。