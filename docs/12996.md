# 抽象类的 C#介绍

> 原文：<https://dev.to/gamersuji/c-intro-to-the-abstract-classes-4m0>

## 什么是抽象类？

### 抽象类是普通类(默认类)和接口的组合。

**抽象类作为接口:**像接口一样，你不允许在任何地方拥有抽象类的实例，你也可以创建*“仅声明”*方法，像接口内部的方法，并且可以在以后要求抽象类的继承者编写定义。

**作为普通类的抽象类:**像普通类一样，你可以拥有成员变量、带定义的方法以及其他所有的优点，这些将在本文中介绍。

### 让我们跳到一个例子，看看如何创建一个抽象类。

让我们写一个场景，让一个人在晚上睡觉。我们可以通过在一个单独的类中创建一个函数 **Sleep** 来轻松实现这一点，在一个单独的类中编写一个功能可以使这个类变得独立，最重要的是，它将更容易在多个接收者类中使用。
因此，我们创建了**睡眠**作为**抽象**类。使用抽象类而不是普通类是有原因的。我们稍后会解释，但在此之前，让我们先看看如何创建一个抽象类。)

**创建抽象类**

要使一个类成为一个**【抽象】**类，只需在 class 关键字的正前方加上一个 ***抽象*** 关键字。

```
 public abstract class Sleep: MonoBehaviour
    {
      public bool sleep;
        public void GetSleep()
        {
          //the inherited organisms will sleep whence this method is called
          sleep = true;
        }

    } 
```

**Sleep** 抽象类有一个名为 **GetSleep()** 的方法，该方法将 **sleep** 布尔值切换为 **true** 。一旦使 sleep 为**真**，它将使继承了 **Sleep** 类的类的实例进入睡眠状态。(*在编写了人类睡眠所需的其余结构之后，我们将详细阐述已经写入 sleep 方法中的“遗传的有机体将睡眠”注释。*

### 让我们开始编写继承**睡眠**类的类。

按照计划，这个继承类将是类 **Human** 。因为我们已经在**睡眠**类中为**睡眠**编写了功能。因此，我们几乎将整个人类类留空，并从 **Sleep** 抽象类继承睡眠功能。继承这种行为而不只是将其作为人类类的一部分的主要原因之一是人类类不需要知道睡眠是什么。

### 这是一个抽象类被称为抽象类的主要原因之一。

继承的类不需要知道它所继承的类内部的类的结构。它就像一个真正的人，一个像你一样想睡觉的人。你闭上眼睛，期待自己进入睡眠，但作为一个有意识的自我，你无法控制睡眠的过程，你的大脑中没有让你进入睡眠的**【睡眠】**按钮。对你来说，睡眠的整个概念就是 ***抽象****。你知道如何触发睡眠，但不能直接让自己入睡。你能做的最好的事情就是闭上眼睛，等待你的大脑让你入睡。所以就像人类不需要知道睡眠的内部结构一样，这个**人类**类也不需要知道一个**睡眠**类的内部结构以及它是如何进行**睡眠过程**的。对于**人类**类，**睡眠**类的内部结构是**抽象**。*

```
 public class Human : Sleep
    {

    } 
```

现在**人类**类能够在任何人类主题上调用 **GetSleep()** 时睡觉，让我们在一个名为**之夜**的类中实现这一点。因为夜间周期是人类或任何生物睡觉的潜在触发因素之一。

```
public class Night : MonoBehaviour {
 private GameObject human;

    private void PutEverybodyToSleep()
    {
        Sleep sleep = human.GetComponent<Sleep>();

        if(sleep != null)
        {
            sleep.GetSleep();
        }
    }
} 
```

这里我们有一个**游戏对象** ( *一个**统一**为中心的对象，它只是作为一个引用，让类**人类**控制它*)。现在我们执行一个 **GetComponent** 来从**人类游戏对象**中获取一个 **Sleep** 的实例，如果它实际上有一个 **Sleep** 的实例(*我们通过执行一个空检查*来确认它)，我们调用 **GetSleep()** 方法来让人类主体进入睡眠状态。由于**人类**类直接继承了**睡眠**方法**获取睡眠**方法已经成为**人类**类的一部分。
正如你所看到的**人类**类里面什么也没写，它所做的只是继承了一个**睡眠**类，并且所有的**睡眠**功能都由**夜**类调用。

### 我信誓旦旦地承诺，我会不按时间顺序回答以下两个问题。

1)在 **sleep** 类中 **GetSleep()** 的注释说，*“被继承的生物体将睡眠，由此该方法被称为*
”2)为什么是抽象的而不是普通的类？

我将回答第**个问题**首先，之所以说遗传生物而不是生物体，是因为我们在那个时间点上只谈论一个人，而这个 **GetSleep()** 不仅仅是为人类建造的。继承后， **Sleep** 类中的 **GetSleep()** 方法将成为一个通用方法，使任何生物进入睡眠状态，因为“ *sleep* ”是所有生物的常见行为。所以我们可以在任何需要睡眠行为的类类型上继承这个类。

在回答我的**第二个问题**之前，我想再次提醒你，抽象类和普通类非常相似。两者都能够处理**构造函数**，两者都能够在内部创建**局部/全局**变量(就像**睡眠**类中的**睡眠**布尔)，两者都能够**封装** ( *隐藏子类或其他不相关类的数据*)一个类中的成员变量和方法。这两类中最后也是最重要的相似之处是，它们都能够处理虚拟方法。

### 等等！什么是虚拟方法？

虚拟方法就像任何其他方法一样，它们有一个方法定义，并在调用该方法时执行该定义。作为一个额外的优势，如果这些方法是从一个**父**类继承的，这些类可以在**子**类中通过添加新的定义和现有的定义来修改，或者甚至可以使用**“覆盖”**关键字用一组新的定义覆盖父类提供的整个定义。

### 让我们在睡眠类内部写一个简短的虚拟方法

要使任何方法成为虚拟方法，请在访问说明符之后、方法的返回类型之前添加 **"virtual"** 关键字。在我们的例子中，有一个**梦**方法，它生成*一个基本的不那么可怕的、非古怪的梦*，由任何子类实例调用。

```
public abstract class Sleep : MonoBehaviour
    {
        public bool sleep;

        public void GetSleep()
        {
            //the inherited organisms will sleep whence this method is called
            sleep = true;
        }

        public virtual void Dream()
        {
            BasicDream();
        }

        private void BasicDream()
        {
            //A basic not so nightmarish, non-eccentric dream 
        }

    }
} 
```

子类重写虚方法不是强制性的。

```
 public class Human : Sleep
    {
        public void GetSleep()
        {

        }

    } 
```

这应该不会引发任何编译时或运行时错误，但是如果您想要更改定义，您可以自由地这样做。让我们假设我们的人类受试者患有某种睡眠障碍，并且很难入睡。我们不能期望我们的实验对象在睡眠过程中做一个愉快的梦。所以我们覆盖了现有的**梦**方法给他一个噩梦。

```
public class Human : Sleep
    {
        public void GetSleep()
        {

        }

        public override void Dream()
        {
            //bring him some ghosts, clowns and zombies to wreck his sleep
        }

    } 
```

现在，如果你调用 **Dream()** 作为一个**人类**类的实例，这个人类将会在他的梦里看到鬼魂、小丑和僵尸，而不是做一个非噩梦的梦。
在这里，我们已经覆盖了先前的定义，并改变了它，让我们的人类主体尝到了地狱的滋味。但是你不觉得我们对我们的测试科目太严格了吗？我绝对喜欢。所以让我们给他一个正常的非噩梦般的梦。如你所知，这个"*非噩梦般的梦*"功能已经是位于父类 **Sleep** 中的基础 **Dream()** 方法定义的一部分。因此我们不必重写它。要调用被覆盖方法中的基定义，只需使用关键字**“base。MethodName()"** ( *在我们的例子中是 base。Dream()* )来使用写在父类内部的基定义。

```
 public override void Dream()
        {
            //bring him some ghosts, clowns and zombies to wreck his sleep
            base.Dream();
        } 
```

基类可以在重写的方法中调用，没有特定的顺序。它既可以在被覆盖的定义之前调用，也可以在被覆盖的定义之间调用，甚至可以在被覆盖的定义之后调用，就像我们上面所做的那样。

### 既然你已经学习了虚拟方法，我们现在可以继续回答第二个问题“为什么是抽象类而不是普通类”？

正如你所看到的，普通类和抽象类非常相似，只有一个原因可能让你使用抽象类而不是普通类。它需要一个像方法一样的接口。在接口中，方法只是被声明，而不是被定义。对于继承接口的类来说，定义这些方法的能力将是强制性的。同样，我们可以在抽象类中创建这样的方法，方法是在方法前面加上**“abstract”**关键字。只需在访问说明符之后和方法的返回类型之前添加**“abstract”**关键字，就可以使方法成为抽象方法。

我们现在使用同一个旧的 **Sleep** 类来创建一个名为 **EstablishSleepTime()** 的抽象方法。正如你所看到的，睡眠时间会因物种而异，每个物种都应该能够建立自己的睡眠时间管理定义。请记住，这些抽象方法内部没有定义，即使你试图给出一个定义，编译器也会抛出一个错误。

```
public abstract class Sleep : MonoBehaviour
    {
        public bool sleep;

        public void GetSleep()
        {
            //the inherited organisms will sleep whence this method is called
            sleep = true;
        }

        public virtual void Dream()
        {
            BasicDream();
        }

        private void BasicDream()
        {
            //A basic non nightmar-ish, non eccentric dream 
        }

        public abstract void EstablishSleepTime();

    }
} 
```

还要记住，**抽象方法**只能在**抽象类**中编写。

从这个类被继承的地方，被继承的类(在我们的例子中是**人类**类)将必须建立任何人类应该得到的睡眠量。

为抽象方法编写定义只能通过重写继承类中的抽象方法来完成，就像重写继承类中的虚方法一样

```
 public class Human : Sleep
    {
        public void GetSleep()
        {

        }

        public override void Dream()
        {
            //bring him some ghosts, clowns and zombies to wreck his sleep
            base.Dream();
        }

        public override void EstablishSleepTime()
        {
            //get 8 hours of sleep for this human
        }
    } 
```

这里，在**establishesleeptime()**方法中，我们定义了一个人可以睡眠的时间。由于这个 **EstablishSleepTime()** 在父类中作为一个抽象方法，这个方法作为一个强制类在子类中定义。

### 这是我们使用抽象类而不是普通类的主要原因。

**抽象类的另一个主要用途:**
如果你能看到抽象类**睡眠**你就能见证这是每一个生物非常普遍的行为。甚至像计算机这样的非生物在疲劳的时候也会睡觉。所以这个功能可以被任何需要睡眠的类继承。如果你在每一个类中都编写了睡眠功能，那么它只会是每一个需要睡眠的类中相同功能的重复。因为 abstract 可以替代普通的类，所以我们在一个类中编写一次 abstract，然后直接继承它，并在任何地方使用它，就像我们使用普通的默认类一样。

### 结论

抽象类是普通类和接口的组合。普通方法不能处理抽象方法，接口不能使用构造函数、封装、成员变量和方法定义。但是抽象类能够做这两个类都不能做的事情。如果你的类结构要求继承这样一个类，那么你应该使用一个**抽象**类。*