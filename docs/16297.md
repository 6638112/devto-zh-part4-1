# 为什么会有丢包？

> 原文:[https://dev.to/rkeene/why-is-there-packet-loss-1p8a](https://dev.to/rkeene/why-is-there-packet-loss-1p8a)

## 互联网正在消亡吗？

我在数据中心工作。真的，我在半个数据中心工作。该数据中心跨越两个物理位置:我工作的位置和位于海边的另一个位置。因为我们是如此的相互依赖，所以两个站点之间的可靠连接是我们实际履行托管职责的关键因素。

由于我们的数据中心相距甚远，我们没有像电缆这样简单的东西来连接我们。相反，我们租用别人网络上的带宽来提供两个站点之间的连接。我们的预算有限，租用专用带宽非常昂贵，因此，尽管我们在两个站点都有 OC-12 连接到我们提供商的网络，但他们只能保证我们能够维持 45Mbps -以上的一切都是尽最大努力。我们直到后来才知道这个限制。

最近，我们开始努力提供“操作连续性”,这涉及到在一个站点发生灾难性故障时，让我们存储的数据在另一个站点可用。我们的运营连续性计划要求我们能够尽快将系统恢复到故障前的状态。为了实现这一目标，我们决定通过网络将数据传送到每个相对的站点并保持其最新状态。

我们对此进行了设置，并在一天晚上将其释放，并开始注意到两个站点的所有主机的延迟和数据包丢失都有所增加。我们开始查看网络图，发现我们在 WAN 链路上的速度仅为 500 Mbps(OC-12，622Mbps)。我们开始向网络组询问数据包丢失的问题，他们承认我们在两个站点之间确实只有 45Mbps 的保证带宽。他们说他们正在使用 QoS，所以这应该不成问题。

我查看了他们的 QoS 配置，注意到他们没有在其 Cisco QoS 配置上指定任何类型的带宽限制。我提到我们没有达到我们的接口容量，但是他们似乎认为他们的 QoS 配置是有效的。它确实设置了一些 DSCP 参数，但我们两个网站之间的所有流量都被设置为相同的值，所以它不太可能有用。

我试图在下面的电子邮件中向他们解释这个问题:

* * *

鲍勃，

下面是我们服务质量实验的一点理由、解释和行动计划。

上周晚些时候，当 SAN 团队开始使用未使用的带宽
(同时不超过我们的链路容量)时，我们在
数据中心之间遇到了数据包丢失。数据包丢失是由以下两种情况之一引起的:

1.  设备或传输(如电缆或中继器)出现故障；
2.  队列已满(或几乎已满):
    1.  接口出站队列；
    2.  设备全局队列；或者
    3.  随机早期检测(红色)表示队列(上述之一)即将满

考虑到现代网络设备的总体可靠性，以及一旦我们减少了通过网络传输的流量
数据包丢失就停止的
事实，我认为我们可以排除
设备故障作为我们应该尝试解决的原因。

这使得我们的队列已经满了或者接近满了。该队列可能位于我们网络内部的
设备上(例如防火墙)或 WAN 网络
内(例如我们提供商网络上的路由器或交换机)。

首先，让我解释一下:

1.  为什么丢包会降低 TCP 流的速度；
2.  为什么队列满(或接近满，导致更高的红色概率)会导致数据包丢失是我们的问题；和
3.  为什么队列几乎满了会导致延迟增加，从而导致 TCP 连接变慢，这不是我们的问题。

首先，传输控制协议(TCP)是一种网络协议，它(在其他特性中)保证套接字流中数据包的传递和排序。在 TCP 中，一端传输的数据包会得到另一端的确认。这种确认是通过向发送方发送一个数据包来完成的，该数据包指示在给定的“确认窗口”(字节范围)中接收到了哪些数据包。如果接收方没有收到足够的数据包来构建确认窗口覆盖的整个字节范围，它将不会发送此确认。如果发送方在规定的时间内没有收到确认(存在各种算法，但我们将只假设 2 * ''AverageRoundTripTime ' ')，要么是因为确认数据包因数据包丢失而丢失，要么是因为数据包丢失导致数据包在接收方的确认窗口中丢失而没有发送，发送方将重新发送确认窗口中所有未被确认的数据包。

因为 TCP 保证数据包的排序，即使在不保证这一点的介质(即以太网)上，TCP 套接字的接收端也必须有一个缓冲区可用于对传入的数据包进行重新排序。这个缓冲区自然是有限大小的。因此，如果数据包已经丢失，接收器必须等待它们被重新传输，然后才能向系统的套接字发送任何后续数据包，并将它们从缓冲区中逐出。因此，接收方缓冲区的大小决定了在给定时间内有多少数据包未处理/未确认以及 TCP 窗口的大小。

一旦发送方发送了足够的数据包来满足 TCP 窗口大小，而从最后一个清除的确认窗口开始的连续范围没有被确认，它将停止传输，直到进一步的数据被确认并且缓冲区变得可用。如果我们假设“AverageRoundTripTime”为 100 毫秒，发送方将等待 200 毫秒以获得确认，在出现数据包丢失的情况下，它将重新传输丢失的数据段，这将需要额外的 100 毫秒才能到达并得到确认。在这 300 毫秒的时间间隔内，一条能够传输 100Mbps 数据的链路将会传输 4 兆字节的数据。很可能到那时接收机的缓冲区已经耗尽，发射机将停止发射。随着传输的停止，链路的平均吞吐量将显著降低。

此外，在出现数据包丢失的情况下，TCP 会减小窗口大小，并需要更频繁的确认，这将受到延迟的限制。

第二，参与“存储和转发”的设备必须利用某种数据结构来存储哪些分组仍要从给定接口发出。这种数据结构通常是一个队列，因为它将限制从接口传输出去的无序数据包的数量，同时使设备可以管理的数据包数量最大化。一些网络设备对于给定的接口将具有多个队列，并且以预定的顺序处理队列(例如，当将分组出队时，首先检查最高优先级的队列，如果没有分组，则尝试下一个，等等)。这些队列的大小自然是有限的，如果它们被填满的速度比它们被清空的速度快，最终就不会有更多的包被排队。

当接口队列已满时，发生的事情很简单，本应添加到队列中的数据包会被丢弃(“尾部丢弃”)。大多数现代网络设备还将实现“随机早期检测”(RED)，其中分组将从非空队列中被丢弃(队列越满，概率越大)，以防止队列变满并强制尾部丢弃(因为尾部丢弃会导致 TCP 的大规模失败)。

这种数据包丢失(来自尾丢弃或 RED)会显著降低 TCP 连接的速度，从而允许处理队列中的数据包。在我们大量使用两个数据中心之间的网络路径期间，我们发现 WAN 链路上的数据包丢失率增加了约 15%。

第三，在将数据包插入队列并等待轮到它们出队列的过程中，时间会流逝。这个时间导致延迟增加。延迟增加将导致接收方的 TCP 接收缓冲区和 TCP 窗口的平均利用率增加。只要等待时间没有增长到缓冲区因等待确认而变满的程度，就不会显著影响 TCP 套接字的吞吐量。在我们大量使用两个数据中心之间的网络路径期间，我们没有注意到过高的延迟。

鉴于这是一个队列在某处已满而导致数据包丢失的问题，控制丢弃数据包的队列会对我们有益，这样我们就可以控制哪些数据包被 T2 丢弃。鉴于数据包丢失可能发生在我们控制之外的网络设备
上(例如，在我们提供商的网络内)，我们限制了
选项，以尝试控制填充和丢弃哪个队列:

1.  区分服务代码点(DSCP)标记；和
2.  在我们这一端设定队列，使其出列速度不超过我们在端点之间不出现可接受的数据包丢失的情况下可以承受的速度

我将阐述这两种方法的优点和成本:

1.  区分服务代码点(DSCP)标记允许我们在支持多队列的接口上尝试操作数据包被分配到哪个队列。这是最简单的方法，但是它有几个缺点:
    1.  并非路径上的所有网络接口都支持多队列，或者如果它们支持 DSCP 的话；
    2.  DSCP 可能被忽略或在提供者内部重写；和
    3.  DSCP 是非常粗糙的，除了缺省值之外，只有 13 个类可以放置数据包
2.  如果 DSCP 标记不可用、被忽略或不充分，则必须采取更复杂的方法来实现管理优先级的目标，在该优先级中，数据包被丢弃，而其他数据包被丢弃。我支持探索的一个可能的解决方案(同样，如果 DSCP 标记证明无效)是在与我们的 WAN 路由器串联的系统上使用服务质量(QoS)和流量整形(TS)。该设备可以设置任意数量、任意深度的队列，我们可以控制这些队列，也可以控制插入哪些数据包。这将使我们在控制丢弃哪些数据包方面拥有无限的灵活性，只要它与流量整形相结合。需要流量整形，以确保我们的传输速率不会超过远程队列的当前出队速率——如果我们不整形流量，远程队列仍然会变满并丢弃数据包，而不管它们从我们这边的哪个队列开始。为了调整流量，我们需要知道当前通过网络路径从一个系统传输到另一个系统的速率。或者，更准确地说，我们需要知道我们是否已经超出了网络的容量。执行服务质量和流量整形的同一设备也可以用于确定我们是否超过了网络路径上给定队列集的速率。该设备可以通过确定链路上发生了多少次 TCP 重传来被动地测量分组丢失量，并确定对于给定的一组队列，有效速率是否太高。

我提议以下行动计划:

1.  确定哪些主机、子网或其他可定义的特征可以具有较低的优先级；
2.  尝试将这些主机和子网归入适当的 DSCP 类别；
3.  用 DSCP 做一些测试，看看是否有效；
4.  如果它是有效的，并且我们能够将我们所有的流量分类到 DSCP 类别中，就宣告胜利。
5.  如果无效，或者我们无法将所有流量分类到适当的 DSCP 类别，我们应该调查 QoS/TS:
    1.  我们首先应该想出一个工具来被动地监控重新传输的次数，以确定我们当前是否正在网络路径上发送超出该路径限制的某些设备。
    2.  当我们准备好测试该工具时，我们可以在一台 WAN 路由器上创建一个监控端口，以镜像来自出站 WAN 链路的出站流量，然后尝试使网络路径饱和
    3.  一旦该工具能够确定网络路径的当前限制(因为这可能随时间而改变，这取决于在远程网络设备上的队列上放置了什么其他依赖项),我们就可以通过使用所确定的速率手动配置给定网络(例如 DC2 和 DC1)之间的 WAN 路由器 QoS 速率，用该工具所确定的限制来测试 QoS 和流量整形
    4.  一旦完成，我们就可以实施排队层次结构，并在内嵌的盒子上定义流量整形要求
    5.  一旦我们已经定义了我们的队列(5.d .)，已经定义了哪些分组将被插入到它们中(1。)，并拥有一个工具来持续确定给定网络路径的吞吐量(5.a .)。我们可以将这些部分放在一起，让该工具在一个盒子上设置流量整形参数，该盒子将与我们的 WAN 路由器和 WAN 链路串联在一起，以确保我们不会溢出远程队列。

* * *

最终，我们决定最好的办法是什么都不做，抱最好的希望。

万岁。