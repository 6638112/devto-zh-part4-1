# 分布式系统中的时间和顺序

> 原文:[https://dev . to/maneeshchaturvedi/time-and-order-in-distributed-systems-508 p](https://dev.to/maneeshchaturvedi/time-and-order-in-distributed-systems-508p)

## 什么是顺序，为什么它在分布式系统中很重要

在我们进入顺序之前，让我们对分布式系统中的节点做一些假设。节点(物理的或逻辑的)，

1.  通过消息传递进行通信
2.  通过不可靠的网络
3.  没有共享内存

### 什么是秩序

顺序定义了事件发生的顺序。也就是说，我们感兴趣的是定义以前发生的关系的属性。给定两个事件 A 和 B，我们想知道

1.  a 发生在 B 之前，反之亦然
2.  或者我们不能说出 A 或 B 出现的顺序

### 为什么我们关心分布式系统中的顺序

一个一次只能做一件事的系统将会有一个明确的操作顺序。如果人们通过一个一次只允许一个人通过的门，那么每个人都会有一个明确的前任和继任者。然而，在分布式系统中，由于有多个节点，可能会引入冲突。

假设一个场景，其中连续的写操作针对同一个购物车的不同节点。哪个节点具有购物车的正确视图？

因此，在分布式系统中，推理排序、解决冲突变得很重要。

### 全序和偏序

总顺序是一种二元关系，它定义了集合中每个元素的顺序。如果两个不同的元素中有一个大于另一个，那么它们就是可比较的。在偏序集合中，有一些元素不能进行比较，因此偏序不能指定每个元素的确切顺序。

分布式系统中的自然状态是关于偏序的。节点和网络都不能保证相对顺序，但是在每个节点上你可以观察到局部的总顺序。

从数学上讲，全序和偏序具有以下属性

#### 总订单

订单总额为

*   传递性-如果 a <= b 且 b <= c，则 a <= c
*   反对称-如果 a <= b 且 b <= a，则 a = b
*   对于 X 中的所有 a，b，a <= b 或 b <= a

#### 偏序

部分订单是

*   传递性-如果 a <= b 且 b <= c，则 a <= c
*   反对称-如果 a <= b 且 b <= a，则 a = b
*   自反的- a <= a 对于 X 中的所有 a

总体性意味着反身性，但是对于偏序的一些元素，总体性不适用，所以集合中的一些元素不能比较。

## 时间

时间是秩序的源泉。它允许我们定义操作的顺序。从某种意义上说，时间就像任何其他的计数器。当应用于程序时，时间有两种有用的解释。

*   命令

*   持续时间

### 时间和时钟

#### 全球时钟

全球时钟是一个全球可用的时钟，具有完美的准确性。即使节点从不通信，全局时钟也能提供跨节点的事件的总顺序。然而，这是一个理想化的世界观。实际上，时钟同步只可能达到一定的精度。从根本上说，全球时钟的精确度受到时空的[性质的限制](https://en.wikipedia.org/wiki/Time_dilation)

全局时钟假设节点上的时钟都以相同的值开始，并且从不漂移。这些假设本质上是不可靠的，在很多情况下，假设会失效，比如一个不同步的节点加入了一个集群，或者节点上的时钟漂移。然而，有一些系统假设时钟同步并应用最后写入获胜的语义，Cassandra 就是其中之一。另一个是谷歌的扳手，它假设了最坏情况下的时钟漂移。

#### 本地时钟

本地时钟是每个节点上的时钟。本地时钟不能用于确定远程时间戳是否发生在本地时间戳之前。因此，使用本地时钟，您无法比较两个节点的时间戳。本地时钟分配部分顺序；一个节点上的事件是完全排序的，但是事件不能跨节点排序。

#### 因果/逻辑时钟

因果时钟或逻辑时钟假设没有时钟，并使用其他跟踪因果关系的机制。逻辑时钟使用计数器和节点之间的通信来确定某件事情是在另一件事情之前、之后还是同时发生。计数器可用于对节点上的本地事件进行排序(本地时钟的时间戳可视为计数器的特例)。在没有通信的情况下，节点之间会有偏序。然而，对于跨节点排序，我们需要通信或消息传递。

Lamport 时钟和矢量时钟是逻辑时钟，用于替代物理时钟。它们依靠计数器和节点间的通信来确定分布式系统中事件的顺序。这些时钟提供了一个可跨节点使用的计数器。伏地魔和里亚克是使用矢量时钟的分布式系统。

##### Lamport 时钟

Lamport 在 1978 年的论文 **Time，Clocks and Ordering of Events** 中阐述了跨节点排序事件的发生之前结构。为了理解 Lamport 时钟，让我们首先看看如何为进程/节点
维护计数器——每当进程工作时，递增计数器
——每当进程发送消息时，将计数器包含在消息
中——每当进程接收消息时，将计数器设置为 max(local_counter，received_counter) + 1

Lamport 时钟允许使用偏序跨节点比较计数器。对于两个事件 A 和 B，如果计数器(A)

-那么 A 可能在 B 之前发生
-或者 A 和 B 无法比较
简单来说，这就是说，如果一个事件先于另一个事件发生，那么该事件的逻辑时钟先于另一个事件发生。
换个角度看，如果 A < B 如果

- A 和 B 都出现在同一个节点/流程上。
- A 和 B 是同步对。同步对是对先前事件的响应。所以 B 是对 A 的响应，举个例子，A 是执行 update(B)的 GET。

##### 矢量时钟

矢量时钟是 Lamport 时钟的扩展。向量时钟维护 N 个逻辑时钟的阵列，每个节点一个。每个节点更新其在阵列中的逻辑时钟，而不是递增公共计数器。定义矢量时钟的规则是

-每当进程工作时，增加阵列中该节点上的逻辑时钟。
-每当一个进程发送一个消息时，它在消息中包含完整的数组。
-当进程接收到消息时，将数组中的每个元素更新为 max(local，received)并递增代表数组中当前节点的逻辑时钟值。

判断 A 是否先于 B 发生的方法是基于
if A<B IFF vector clock(A)<vector clock(B)。假设三个节点 N1、N2 和 N3，A 处的向量时钟为[1，0，0]，B 处的向量时钟为[2，1，0]，这意味着 A 发生在 B 之前