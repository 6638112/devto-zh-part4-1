# 使用遗产，一个缓慢查询的故事。

> 原文:[https://dev . to/willmenn/working-with-legacy-a-tale-of-a-slow-query-3447](https://dev.to/willmenn/working-with-legacy-a-tale-of-a-slow-query-3447)

我在一个遗留代码中工作，hibernate 和 ORM 控制了几乎所有与数据库的交互，这是一个很好的库，但是当我们有一个随着时间推移被许多开发人员传递的代码时，sql 查询开始成为一个神话，没有人知道如何去做，并把这项工作留给 hibernate 来解决如何创建查询。

### [](#the-problem)问题

一个无辜的故事，要求现在添加更多的数据到报告中。开发人员转到查询并添加过滤器。从最差情况下的 1.6 秒查询到 50 秒。

### [](#remove-hibernate)解除休眠

所以查看 hibernate 的日志，hibernate 查询了比它需要的更多的数据，因为它正在获取一个巨大的模型，而只需要一些属性。我们可以配置 hibernate 来完成这项工作，但是开发团队决定移除 hibernate，并获取有关该功能的知识。

从 hibernate 中的一个简单查询到 sql 查询中的一个 4 Join，这就是结果，但是令人惊讶的是查询并没有那么好。现在的问题是，在查询所连接的两个表中，可能是一个数据列表，而不是连接到主键，而是连接到另一个属性，导致查询生成重复数据。

要解释这种连接:

如果在另一个表中通过主键或唯一键进行联接，则每次联接只能获得一条记录，但是，如果在表中可以超过 1 的属性内进行联接，则可以获得多条记录，如果在多个表中进行联接，则同一条记录有 2 条记录，则查询将返回 4 条记录，如果有 3 条记录，则结果为 9 条记录。当然，在生产中，这个查询是针对大约 5，000 条记录的，您总是可以假设最坏的情况是每行 4 条记录，这可能导致一个查询返回大约 2 万条记录。

连接的有趣部分是查询返回 10 列，如果 2 个表有 2 条相同父记录的记录，我们将得到 4 条相同数据的记录，换句话说，40 列相同数据。呵呵呵

这个查询大约与 hibernate 同时出现。

### [](#multithread)多线程

由于试图创建一个查询来统治所有查询(哈哈哈)令人沮丧，我们尝试使用多线程方法。因此，我们的想法是通过主键访问每个表，获取需要的数据，并在内存中进行组装。

对于第一个 500~1000，它的表现还可以，但是当我们开始用 5k 的数据集同时运行 50 个调用的性能测试时，它也开始表现得像 hibernate 一样，这是因为 IO 部分大约花费了 10~30ms 每`Select by Primary Key`，但是我们对每个数据有 4 个查询，对于 5k，所以`(5000 *10)/1000 = 50sec`。

另一个问题是，根据容器的大小，如果您使用较少的内存运行，您将能够创建较少的线程，因此，最终，您将需要对请求进行排队，直到有新的线程可用，这将非常耗时，对于我们将要创建或重用的每个请求`5000 * 4 =20.000`(显然，2Gb 的应用程序无法创建那么多的线程，所以我们对每个请求进行排队)。
在生产中，我们有一个大型数据库，其中的`16Gb`与一个`k8 2Gb`应用程序相对，数据库比应用程序更好地管理内存。

### [](#understanding-the-business)了解业务

带着另一个令人沮丧的想法去停车场，我们决定更多地了解业务，并尝试避免或改进第一个查询中的一些连接。

总之，我们能够删除查询中的一个大表`join's`,并更精确地过滤我们希望在报告中显示的数据部分。通过这样做，我们将查询时间从 50 秒提高到了 14 秒。还是没那么好但是好多了(happy_face)。

### [](#improvements)改进

由于该报告每周仅生成一次，并且仅由该角色中最多有 100 人的管理员用户使用，我们认为花费更多时间来提高性能是浪费时间，因为我们有更重要的东西要改进，可以对业务产生更大的影响。

最后，这是一个有趣的旅程，但了解业务是正确的解决方案，但也是最困难的，因为我们必须与许多人讨论，深入了解项目的历史，以及它是如何完成的，为什么不只是去那里提高性能，只改变技术部分。

改进该查询的下一步是启用分页，并尝试重构数据库，以便有一种更高效的方式来查询该数据。