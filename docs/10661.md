# 关于测试 React 应用程序，我学到了什么

> 原文:[https://dev . to/jenniferlynparsons/what-I-ve-learn-about-testing-react-applications-5bmn](https://dev.to/jenniferlynparsons/what-i-ve-learned-about-testing-react-applications-5bmn)

*TL；前端的灾难恢复测试是开发中最个性化的方面之一，有各种各样的工具和观点，特别是对于 React 生态系统。当你学习如何测试时，要对自己有耐心。根据我的经验，自学是最具挑战性的事情之一。*

我最近花了很多时间研究 React 测试，获得了比开始时更多的知识，尽管我仍然有一些挥之不去的困惑。然而，我确实开发了一个对我来说可行的系统，并使我的测试对我的工作方式有意义。目前，随着 React 测试的快速发展，这似乎是我们所能要求的最好的了。

虽然测试 React 的最佳实践如此多变令人沮丧，但我希望这篇文章能对各种选择有所启发，并朝着某种共识迈出一步。

## [](#general-thoughts)一般思想

在我深入研究 React 特有的信息之前，我想我应该分享一些关于测试的一般想法。智慧之言，如果你愿意，基于我的经验。它们提醒我为什么测试是重要的，以及编写测试的真实情况是怎样的。

*   是的，你基本上是在一个不同的框架中重新编写一个精简版的应用程序逻辑。

*   有一些从后端继承的松散的最佳实践，但是人们似乎在应该如何处理测试上比在应该使用哪个框架上更加分裂。你必须和你的团队一起决定什么是有效的。

*   编写测试需要以不同于平常的方式思考你的应用程序，并且会让你重新思考你是如何处理数据的。

*   覆盖率并不是衡量质量的完美标准。如果您还没有编写“不愉快的路径”代码(else 语句、catch 块等)。)你的报道会不准确。你不能测试你没有写过的代码。

*   编写测试确实会增加编写应用程序所需的时间、代码和工作量。这不是幻觉，这是过程的一部分，因为...

*   它节省了你本该投入调试的看不见的时间和精力，尤其是在重构期间。你不会知道你存了多少钱，因为你不会去做那些工作。这个很容易忘记。

## [](#tools)工具

当涉及到测试 React 应用程序时，可以根据您的测试方法进行选择。你想专注于集成测试吗？单元测试？还是更喜欢功能测试？是的，这些术语有不同的定义，取决于你问谁。了解这些选项很好地提醒了我们，React 在技术上是一个库，而不是 T2 框架。这意味着有很多定制的可能性，这在测试中非常明显。

**基本测试**

*   ReactTestUtils: React 自己的内置测试实用程序，即使是 React 团队也不再推荐使用。
*   jest:React 测试的事实标准库，由脸书专门为测试 React 应用而构建。

**建立在笑话之上**

*   React 测试库:当前推荐的组件测试库，它测试组件的方式与用户使用组件的方式相同。
*   Enzyme:一个广泛使用的测试库和 RTL 的竞争对手。它允许您遍历和操作组件的输出。

**整合**

*   Cypress:利用时间旅行、快照和基于浏览器的界面进行端到端测试。
*   Puppeteer:运行 headless Chrome 的端到端测试，允许您编写与浏览器交互的测试，而无需运行浏览器。

**替代品**

*   Mocha/Chai/Karma:因为 React 实际上只是 JavaScript，所以也可以使用这些稳定、古老的测试工具。

其他一些选项可以在 [React docs 的社区部分](https://reactjs.org/community/testing.html)找到。

这涵盖了基本测试的大部分选项。根据您的应用，还可以使用许多补充工具。例如，`redux-mock-store`通常用于模拟 redux store，而`moxios`可以用于模拟用于 API 测试的`axios`,尽管还有其他方法来测试这两种工具。

## [](#documentation-amp-notes)文献&笔记

我发现大多数工具的文档都非常密集，涉及的概念相当复杂，没有重要的先验知识。当我尝试应用从基础教程中获得的经验时，我很快就感到沮丧，因为它们与我试图测试的更复杂的代码库不一致。我说的“更复杂”是指我在 React 上使用了 Redux 和 React 路由器，所以在现实世界中，实际上没有那么复杂。

在我阅读的各种文档中，有一些重要的概念没有解释清楚。以下是我从文献中收集到的，以及从其他试图弄清楚这一切的人那里学到的:

*   单独的*文件*并行运行(除非您启用 runInBand 选项)。因此，多个测试文件共享一个可变的数据存储是不安全的。文件中的所有描述和测试块总是按照声明顺序连续运行。如果您要在测试之间改变数据，这一点很重要。

*   如果您在 redux 商店之外工作，即使您尝试输入新的道具，React 测试库也不会在道具改变时重新呈现组件。除了`componentDidMount`之外，与生命周期方法相关的任何内容都不会运行。您可以手动传入更新的 props 并手动重新呈现组件，但这与测试 redux 调用的结果是不同的。对于这种测试，Cypress 可能是更好的选择。

*   如果您有来自 React 路由器的任何链接，或者想要测试重定向在您的组件上的工作，RTL 的标准`render`函数是不够的。你必须使用这里的`renderWithRouter`函数: [React 路由器测试库](https://testing-library.com/docs/example-react-router)

*   类属性中的命名箭头函数不在原型中，所以对它们进行单元测试很有挑战性。JS 类中的粗箭头赋值不是类方法；它是一个保存函数引用的类属性。

*   尽管快照在大多数测试库的文档中是作为第一步出现的，但它并不像乍看上去那样有用，并且通常被许多开发人员所避免。

*   如果没有完全理解它是如何工作的，以及可以从它那里得到什么，嘲讽可能是具有挑战性的。我已经写了一篇单独的文章[专门讨论嘲弄](https://dev.to/jenniferlynparsons/a-bit-about-jest-mocks-2o7k)的问题，涵盖了一些基础知识，尽管值得注意的是承诺增加了额外的复杂性。

尽管如此，当学习测试时，文档仍然是一个坚实的起点。通读一遍，然后继续研究任何新的术语，这将使你能够提出更好的问题。

我发现搜索出现的任何错误也很有帮助。找出我的测试、代码和配置的问题是一个挑战，但是每一个问题都让我更加了解各个部分是如何组合在一起的。

我还强烈推荐加入各种测试库的社区，阅读他们的 github repos 中的问题。我的许多问题在这些地方得到了比在文档中更有效的回答，特别是当它涉及到使用 Redux、thunk 和其他非本机 React 工具所增加的复杂性时。

## [](#my-own-system)我自己的系统

目前，我选择在我的副业项目中使用以下设置:

*   玩笑
*   反应测试库
*   redux-模拟商店

我还有一个“test”文件夹，我所有的测试数据都存储在这个文件夹中，还有一些测试工具。作为参考，测试实用程序[存储在一个 gist](https://gist.github.com/jenniferlynparsons/fe79f5c1a7a00da44c7f53fff99c1cd7) 中。夹具和其他设置细节可以在我的一个项目中查看[。(我有一个样板文件，将包括这种类型的测试)](https://github.com/jenniferlynparsons/cuppa-webpack)

### [](#guidelines)指导方针

*   夹具和实用程序存储在根级`test`文件夹中。
*   对数据使用 fixtures，除非是少量(少于一行)的一次性数据。
*   偏好可重用的测试数据和工具。保持测试干燥！
*   测试与它们所测试的元素一起存在。每个组件文件夹应该包含一个`__tests__`文件夹，并且测试应该被命名以匹配它们的组件。

### [](#tests)测试

#### [](#structure-of-a-test-file)测试文件的结构

并非所有的测试套件都需要下面列出的所有结构，但是这是每个文件的首选顺序。

*   进口
    *   反应
    *   反应测试库
    *   其他必需的包和库
    *   文本工具
    *   routerTestUtils
    *   数据设备
    *   连通容器组件
    *   未连接的容器组件
*   常数
*   模拟功能
*   beforeEach 的变量
*   每次安装/拆卸前/后功能
*   描述块
    *   试样
    *   变数(包括间谍)
    *   商店.配送
    *   预防
    *   预期

#### [](#notes-on-my-testing-style)我的测试风格笔记

*   除非出于模仿的目的，否则数据设备不会给变量起别名。
*   任何测试套件的第一个 describe 块是组件的基本呈现，该组件具有连接的存储，或者测试正在测试的函数或对象是否存在。
*   第二个描述块测试基本交互。
*   所有其他的测试都在前两项之后。
*   在一个测试中，多个期望是可以接受的，只要它们都与相同的功能和测试相关。

## [](#wrap-up)总结起来

我希望这些信息对那些对开发可靠的测试策略感兴趣的人有所帮助。也许有一天我们会有更标准化的前端测试方法，但在那之前，我鼓励大家分享自己的发现和测试经验。