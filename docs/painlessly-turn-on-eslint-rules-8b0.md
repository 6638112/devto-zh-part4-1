# 如何轻松打开 ESLint 规则

> 原文：<https://dev.to/hjylewis/painlessly-turn-on-eslint-rules-8b0>

esplint 是一个 ESLint 警告追踪器，帮助将规则引入遗留代码库。

### 此工具将…

*   允许你立即开启一个新的 ESLint，而不强迫你首先修复所有的违规。
*   防止将来出现违规情况。

### 这个工具不会…

*   自动修复 ESLint 违规。

## 问题

林挺是一种捕捉不良代码和实施最佳实践的强大方法。通过静态分析您的代码，linters 创建了快速、一致的反馈循环，可以标记不良实践、反模式和输入错误。它们通过提供最佳实践的描述和资源，非常适合培训开发人员。JS 社区通过像 [ESLint](https://eslint.org/) 这样的工具及其强大的插件生态系统，普遍接受了林挺的力量。

也就是说，为现有项目启用新的林挺规则可能会很困难。当使用具有大量代码的遗留代码库时，每个新规则都可能意味着需要修复数百个违规，然后才能正确启用规则。所有的代码库，不管它们的历史有多长，最终都会有这个问题，因为新的 ESLint 规则在不断地被创建。谁知道今天会是一种模式，明天会是一种反模式呢？！打开规则可能会非常痛苦，暴露出隐藏的违规，您必须在使用规则之前修复这些违规。

## 过去的解决方案

### 使用 ESLint 警告

一般来说，让你的 linter 阻塞你的持续集成(CI)是一个很好的实践，这样违规就不会被引入到你的代码库中。这意味着为了引入一个新的 ESLint 规则，需要修正每一个违规。然而，如果我们可以将这些新的违规行为归类为“非阻塞”，情况就不会是这样了。为此，我们可以使用 ESLint 的警告。如果 ESLint 发现违反了配置为`error`的规则，但没有违反配置为`warn`的规则，则返回错误退出状态。如果我们启用一个新规则作为警告，我们可以引入一个新规则，并且在修复所有新违规时不会被阻止。警告是教育代码库贡献者的好方法。我们可以稍后在不阻止任何人的情况下修复新暴露的违规，然后当所有违规都被修复时，最终将规则从`warn`切换到`error`。但是，ESLint 的警告本身并不能像错误那样阻止新违规的发生，因为错误本质上不会阻止 CI。如果你每引入 2 个违规就修正 1 个，你将永远无法完成！

### 使用 ESLint Max 警告

ESLint 允许你设置警告数量的上限。比如`eslint --max-warnings 100`。如果你的代码库有超过这个数目的警告，ESLint 失败，否则通过。我们可以使用这个特性来防止在新规则仍然是一个警告时引入新的违规。我们只是将最大警告数设置为初始违规数，然后如果有人意外尝试引入新的违规，ESLint 将会阻止 CI。随着警告计数的减少，我们可以手动降低最大数量。这是一个更好的解决方案，但仍有一些问题:

*   如果有人在一个文件中修复了一个违规，但不小心在其他地方引入了一个违规，该怎么办？计数仍将低于最大值，ESLint 仍将通过，但引入了新的违例。
*   如果我们想引入第二个新规则呢？该计数必须是违规次数的总和。我们怎么知道什么时候准备好将一个规则作为`error`打开？

我要说明的是，这种方法的范围太广了。我们只有一个完全警告计数要执行。没有特定于文件或规则的计数。

### 使用 ESLint 禁用注释

另一个解决方案是将新规则作为`error`打开，并使用 ESLint 的[禁用注释](https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments)来禁用特定违规行的 ESLint。这无疑解决了我们以前遇到的一些问题。这是更具体的范围，范围到违反代码。在修复所有违规之前，它不会阻止引入新规则，如果添加了新的违规，它会阻止 CI。然而，它确实违背了打开规则的要点。通过在这些行上禁用 ESLint，您正在抑制您可能会收到的潜在警告，错过了 ESLint 规则提供的教育，并且基本上放弃了修复那些隐藏的违规。

## 介绍 esplint！

[esplint](https://github.com/hjylewis/esplint) 是一个工具，它允许您将新规则作为警告打开，并在文件和规则的范围内防止进一步的违规。esplint 构建在 ESLint 之上，并在引擎盖下使用它。运行 esplint 会跟踪每个文件和每个规则的 ESLint 警告数，并防止警告数增加。当警告数目减少时，esplint 会自动记录新的较低数目。通过这种方式，您可以引入新的规则，并随着时间的推移修复现有的遗留违规，同时避免进一步的违规。

运行 esplint 会运行 ESLint 并创建一个名为`.esplint.rec.json`的记录文件，该文件存储了每个文件和每个规则的警告数量信息。这与为 npm 和 yarn 锁定文件的方式类似，应该在您的代码中提交。当 esplint 再次运行时，如果这些计数中的任何一个变大，它都会出错，如果这些计数变小，它就会更新这些计数。esplint 鼓励您使用 [lint-staged](https://github.com/okonet/lint-staged) 来运行 esplint，作为我们的预提交挂钩的一部分。由于它运行 ESLint underhood，它甚至可以取代你的 ESLint 预提交钩子。更多信息参见[入门自述文件](https://github.com/hjylewis/esplint#getting-started)。

如果您只是想要 esplint 的检查功能，而不是自动更新计数，您可以使用`esplint --no-write`选项。选项`esplint --overwrite`是在无法避免引入新违规的情况下提供的逃生出口。在这些情况下，esplint 将忽略您现有的`.esplint.rec.json`，并且不会在警告计数增加时出错。

运行`esplint stats`获得一个包含违规和警告总数的可读文件列表。

## 我学到的东西

### 写磁盘的危险

由于使用了锁文件，esplint 比 ESLint 更接近于 npm 或 yarn，因为它在磁盘上留下了一个必需的工件以提交给代码库。这会增加复杂性并引入合并冲突的问题。每当磁盘上有许多团队成员可以接触的中心文件时，就必须考虑意外的合并冲突。esplint 已经进行了多项改进，以避免合并冲突的问题。

在我最初的方法中，记录文件是未排序的，包括每个文件的信息，甚至包括那些没有违规的文件。每当一个新文件被添加到代码库中，它的`.esplint.rec.json`条目就会被添加。由于记录文件是未排序的，这意味着条目总是被添加到文件的底部。当多人在不同的分支中创建新文件时，这显然会产生冲突。剧透一下，我发现这种情况经常发生！更改文件以按排序顺序存储记录有助于避免大多数不必要的合并冲突。从记录文件中删除零违例文件的条目也有助于减少合并冲突。此外，它大大减少了记录文件本身的大小。在某些代码库中，这一改变将记录文件的长度减少了一百倍。

虽然这些修改改进了锁文件，但是它们没有完全防止记录文件中的合并冲突。Git 不理解 JSON 格式，只理解被删除和添加的行。当在单独的分支中修复违规时，Git 可能会感到困惑，因为记录文件的多行被删除。在这种情况下，运行`esplint`将尝试自动解决 git 冲突，类似于 npm 解决锁文件的方式。

### 大声失败

有时候，大声失败比优雅而无声地失败更有益。早期版本的 esplint 在遇到不是有效 JSON 的记录文件时会正常失败。它会继续运行，就像是从零开始一样，忽略无效的记录文件。这在当时是处理无效记录的合适方式。但是这也会导致 esplint 像分析没有记录时一样分析整个代码库。根据代码库的大小，这可能会非常慢。

当一个 esplint 用户意外地将一个损坏的记录文件提交到他们的存储库时，其他人开始报告在预提交挂钩上的 esplint 时间非常慢，这令人困惑并影响了工作效率。发现无效的 JSON 并理解发生了什么花了一些时间。埃斯皮林特默默地假装一切正常，这没有任何帮助，这使得追查原因变得更加困难。现在，在这种情况下，esplint 不会无声无息地失败，而是显示一条有用的错误消息，让用户知道记录文件已损坏。

### 警告疲劳的危险

不幸的是，即使有了 esplint，违规也不会自行修复！根据您的团队，贡献者可能没有动力自己修复警告。在工作中，我们发现一次专注于一个新规则并安排黑客会议来解决违规问题是成功的。警告疲劳是真实的，一次关注一个可能意味着更快地引入新规则。

## 总结

esplint 通过跟踪、实施和更新文件和规则范围的警告计数，可以更容易地将新的 ESLint 规则引入大型的遗留代码库。

有关入门、使用和配置的更多详细信息，请参见[自述文件](https://github.com/hjylewis/esplint#esplint)。