# 组装很简单

> 原文:[https://dev.to/skydevht/assembly-is-simple-3jgd](https://dev.to/skydevht/assembly-is-simple-3jgd)

一年前，在阅读一篇关于安全的帖子时，我偶然发现了[嵌入式安全 CTF](https://microcorruption.com/) 。这是一个关于逆向工程的教学游戏。我玩了几关，真的很有趣。但它让我想起组装其实很简单。

我学习编程的动机来自于我想成为一名黑客。我读过 Jon Erickson 的《黑客:利用的艺术》,这本书鼓励我扩展我的计算机知识。我也读过《Shellcoder's Handbook》和《Gray Hat Hacking 》,我记得我曾努力阅读过这两本书的第一部分。你必须了解程序如何工作的基本原理，虽然他们做了很好的总结，但这和我所知道的太不一样了。它实际上太简单了。

我的第一门语言是 C 和 Python。虽然与 Python 相比，C 是一种低级语言，但它仍然比汇编增加了许多抽象。函数、变量、循环、...不存在于程序集中。我的思维过程围绕着这些概念。在我了解了当代码被翻译成机器代码时这些抽象是如何实现的之后，事情变得更好了。

我所理解的是，一旦被编译，你的代码实际上将是数据和指令的混合(这是特殊的数据)。这些指令可以根据它们的用途大致分为三类。

## [](#moving-data-around)四处移动数据

最常见的指令之一`MOV`就属于这一类。你实际上做了很多，把数据从一个位置(内存，存储器，寄存器)移动到另一个位置。即使在显示某些内容时，您也只是将数据移动到图形控制器。

## [](#compute-data)计算数据

其他指令如`ADD`和`CMP`会这样做。虽然它们可能涉及复杂的电路(如在进行浮点运算时)，但它们所做的是基本的操作，如加法、除法和将结果存储在某个地方。

## [](#jumping-all-over-the-place)跳来跳去

处理器实际上以线性方式执行代码，一条指令接一条指令，有一个寄存器记录下一条指令的位置。通过操作该寄存器中的值，我们可以跳过指令或返回到上一条指令。`JMP`、`CALL`等指令都是这么做的。

这是对组装的粗略概述。一些汇编者在其上添加了他们自己的抽象。汇编很简单，但是写起来甚至读起来都很乏味。这就是为什么高级语言中的抽象更接近我们的思维方式，而不是计算机的工作方式，使代码更容易理解。