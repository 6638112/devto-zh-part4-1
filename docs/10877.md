# 组件 vs (UI)集成 vs E2E 测试

> 原文：<https://dev.to/noriste/component-vs-ui-integration-vs-e2e-tests-3i0d>

我正在 GitHub 上做一个大的 [UI 测试最佳实践](https://github.com/NoriSte/ui-testing-best-practices)项目，我分享这个帖子来传播它并有直接的反馈。

* * *

说到 UI 测试(记住，我们只是在谈论 UI，而不是底层的 JavaScript 代码)，有三种主要的测试类型:

*   组件测试
*   UI 集成测试
*   端到端(E2E)测试

## 组件测试

UI 的单元测试，他们在一个隔离的
环境中测试每一个组件。

独立开发组件很重要，因为它允许您将组件与相应的容器/用途隔离开来。一个组件的存在是为了隔离一个单一的行为/内容(单一责任原则)，因此，隔离编码是有益的。

有很多方法和工具可以独立开发组件，但是
[故事书](https://storybook.js.org)因为其有效性和生态系统成为了标准选择。

组件有三种类型的契约:生成的输出( **HTML** )、它们的可视方面( **CSS** )和外部 API(**道具和回调**)。测试每个方面可能会很麻烦，这就是[故事镜头](https://www.npmjs.com/package/@storybook/addon-storyshots)派上用场的地方。它允许您自动化:

**快照测试**:快照是组件生成的输出，是包含所有渲染 HTML 的字符串。如果生成的 HTML 发生变化，
无论是意外还是意外，快照测试都会失败，您可以选择这些变化是否是有意的。

**视觉回归测试**:组件的视觉方面将**逐像素**与前一个进行比较，再次提示您选择是否接受更改。

这些测试由 [Storyshots](https://www.npmjs.com/package/@storybook/addon-storyshots) 在每一个故事书页面(又名“故事”)上自动启动。

**回调测试**:一个小的 React 容器应用程序通过一些回调来呈现组件。然后，模拟用户交互，并传递预期要调用的回调。
[React 测试库](https://testing-library.com/docs/react-testing-library/)是这类测试的标准库选择

**交互/状态测试**:一些与组件的交互期望正确的状态管理。这种测试必须从消费者的角度来写，而不是从内在的角度(例如。用户填充时输入字段的值，而不是内部组件状态)。交互/状态测试应该在键盘事件触发后断言输入字段值。

## UI 集成测试

他们在一个真实的浏览器中运行整个应用程序，而不需要访问一个真实的服务器。
这些测试是每个前端开发者的王牌。他们速度极快，更少暴露于随机故障或假阴性。Cypress 非常适合 UI 集成测试。

前端应用程序不知道没有真正的服务器:每个 AJAX 调用都会被测试工具立即解决。静态 JSON 响应(称为“fixtures”)用于模拟服务器响应。Fixtures 允许我们测试前端状态，模拟每一个可能的后端状态。

另一个有趣的效果是:Fixtures **允许你在没有后端应用程序的情况下工作。你可以把 UI 集成测试想象成“仅前端测试”。**

最成功的测试套件的核心是大量的 UI 集成测试，考虑最适合你的前端应用的测试类型。

## 端到端(E2E)测试

他们运行整个应用程序，与真正的服务器进行交互。从用户
交互(其中一个“端”)到业务数据(另一个“端”):一切都必须按照设计工作。E2E 测试通常很慢，因为

他们需要一个**工作后端**应用程序，通常与前端应用程序一起启动。没有服务器你就不能启动它们，所以你要依靠后端开发人员来工作

他们需要**可靠的数据**，在每次测试前播种并清理数据

这就是为什么 E2E 考试不适合作为唯一/主要的考试类型。它们非常重要，因为它们测试一切(前端+后端),但是必须小心使用，以避免脆弱和长达一小时的测试套件。

在一个包含大量 UI 集成测试的完整套件中，您可以将 E2E 测试视为“后端测试”。您应该通过它们测试哪些流程？

快乐之路:你需要确保，至少，用户能够完成基本操作

对你的企业有价值的一切:幸福之路与否，测试你的企业所关心的一切(显然，对它们进行优先排序)

经常发生故障的一切:系统的薄弱环节也必须受到监控

识别/定义测试的类型有助于对它们进行分组，限制它们的范围，以及选择是否在整个应用程序和部署管道中运行它们。

同样， [Cypress](https://www.cypress.io) 是我进行 E2E 测试的首选工具。

## 明智地命名

您可以编写许多不同的 UI 测试，用一种通用的方式命名测试文件是一个好习惯。

这很有用，因为通常您只需要运行一种类型的测试，情况可能是:

*   在开发过程中，您只需要运行其中的一部分
    *   您正在更改一些相关的组件，并且您需要检查生成的标记是否没有更改
    *   您正在更改一个全局 CSS 规则，并且您只需要运行可视化测试
    *   你正在改变一个应用流程，你需要运行整个应用集成测试
*   您的 DevOps 同事需要确保一切正常运行，最简单的方法就是启动 E2E 测试
*   您的构建管道只需要运行集成和 E2E 测试
*   您的监控管道需要一个脚本来启动 E2E 和监控测试

如果您明智地命名了您的测试，那么启动其中的某一类测试将会非常容易。

柏树:

```
cypress run --spec \"cypress/integration/**/*.e2e.*\" 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

是" T0 "

```
jest --testPathPattern=e2e\\.*$ 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

不存在命名测试文件的全局方法，建议使用以下名称命名它们:

*   你要测试的对象
*   测试的种类(`integration`、`e2e`、`monitoring`、`component`等)。)
*   选择的测试后缀(`test`、`spec`等)。)
*   文件扩展名(`.js`、`.ts`、`.jsx`、`.tsx`等。)

所有这些都用句点隔开。

一些例子可能是

*   `authentication.e2e.test.ts`
*   `authentication.integration.test.ts`
*   `site.monitoring.test.js`
*   `login.component.test.tsx`等。