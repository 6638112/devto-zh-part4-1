# 琐碎的、类型安全的翻译

> 原文:[https://dev . to/vivainio/trivial-type safe-translations-in-angular-3 aod](https://dev.to/vivainio/trivial-typesafe-translations-in-angular-3aod)

官方的 Angular 翻译系统(angular-i18n)在各方面都有问题(阅读 ngx-translate 项目中的这张票和线程了解背景):

# [![GitHub logo](../Images/a73f630113876d78cff79f59c2125b24.png) 讨论:图书馆的未来 #783](https://github.com/ngx-translate/core/issues/783) 

[![ocombe avatar](../Images/7ca234be67aba4d6c804a9ab1f7ba3b0.png)](https://github.com/ocombe) **[ocombe](https://github.com/ocombe)** posted on [<time datetime="2018-01-30T12:30:35Z">Jan 30, 2018</time>](https://github.com/ngx-translate/core/issues/783)

大家好，我想讨论一下这个图书馆的未来，并听听你们对我的计划的看法。

### [](#long-history)(悠久的)历史

如果你不关心这个图书馆是如何诞生的，你可以跳过这一部分

当我 3 年前开始这个库时，我想学习 Angular，我认为从事开源项目是最好的方法。我在 AngularJS 上使用我的库 ocLazyLoad 时，它取得了巨大的成功(2600 颗星),它的核心原则最终集成到了 v1.6.7 的框架中。

当时我正在寻找一种方法来翻译我的 Angular 应用程序，并发现 Angular 中没有任何东西可以做到这一点(i18n 甚至不存在于框架中)。我问我的好朋友 Pascal Precht 是否有兴趣将 angular-translate 从 angularJS 移植到 Angular，但他不感兴趣，并告诉我应该这样做。

由于各种原因，我的图书馆很快变得流行起来(没有真正的替代方案，我在 ocLazyLoad 上的工作、我在 Angular Air 上的出现以及我在会议上的演讲使我获得了很好的声誉)。我想代码已经足够好了，而且很容易上手。那时候框架还在测试阶段，没有真正的发布 Angular 库的指导方针，做起来很难，没有很多人尝试，我在 i18n 上很长时间没有任何真正的竞争。

过了一段时间，图书馆生态系统开始稳定下来，Angular 也稳定了，他们决定放弃 Angular 2/4/...赞成只是“有角”。我决定将这个库重命名为 ngx-translate，并使用 npm scopes 来提供模块化的体验。我重写了整个库，并使替换某些部分(加载器、解析器、编译器、...).对我来说，这仍然是一个兼职项目，但我在工作中使用它，因为我们终于开始在生产中使用 Angular，并需要在多个地区翻译该应用程序。

官方的 i18n 实现超级复杂(现在仍然如此)，它不支持 json、代码翻译、在不重新加载应用程序的情况下更改区域设置，并且您需要多个应用程序包(每个区域设置一个)。我的图书馆如此受欢迎，以至于我想全职为它工作，因为我可以看到它是 Angular 社区的必需品。它解决了许多用例，并且简单到只需几分钟就可以使用。

我决定辞掉工作，看看能否通过我的开源工作谋生。我知道这是可能的，因为 ag-grid 已经做到了，而且非常成功。那是 2016 年 12 月，我还有 2 个月的工作时间才有空，我去了核心团队的 Igor Minar 出席的会议 NG-BE。我想问他一些如何将这个项目变成一个盈利的 OSS 项目的建议，但在我告诉他我的计划之前，他告诉我:*“啊，Olivier，我想和你谈谈，你必须停止你的库[ngx-translate]的工作，一些公司找到我们，想做 i18n，但他们只谈论你的库，我们希望他们使用我们的解决方案[Angular i18n]，因为它更有效”。*

我有点说不出话来，我正要告诉他我已经辞职了，想全职做我的自由工作，他却让我停止做这件事。所以我做了任何有点常识的人都会做的事情，我告诉他 Angular i18n 很烂，它没有实现他们希望 Angular 成为的易用而强大的承诺。我可能没有使用这些词，但他同意我的观点，即它仍然需要一些工作，但他们没有足够的资源来完成它(维克多·萨维金和杰夫·克罗斯刚刚离开团队创建 Nrwl)。我欣然接受，并告诉他我很乐意与他们一起改善 Angular i18n。他告诉我他会考虑这件事，我们就此打住。

几个星期后，他再次联系我，告诉我他们可以雇佣我作为承包商来开发 i18n。对我来说，这就像圣诞节一样(实际上是在圣诞节前后，所以这可以解释为什么)，因为为谷歌工作是一生难得的机会，也是一份梦想中的工作。但是在家里为 Angular 开发开源软件甚至更好，我甚至不认为我有可能做到这一点。

2017 年 2 月(差不多一年前)加入团队，开始做 i18n。有很多工作要做，但我相信我可以有所作为。当时我很清楚，要让 i18n 对每个人来说都更容易使用，具有人们想要的功能，还需要几个月的时间，之后我可以弃用我的库。

原来在 Angular 这样的框架上工作是超级复杂的。代码库是巨大的，没有高度文档化，有许多不同的包。开发过程很复杂(它甚至还不能在 Windows 上运行)，无论何时你做出改变，你都必须格外小心，不要伤害任何人。我们甚至编写测试，比如很多测试。对我来说，这是一个很大的转变，因为我一直致力于需要快速发布的项目，测试显然不是优先考虑的事情，而是修复错误。但是在 Angular 这样的库上工作是完全不同的。数以百万计的人依赖你的代码，当你犯了一个错误，你可以破坏应用程序，因为你损失成千上万美元。责任是压倒性的，这就是为什么发布新功能要复杂得多。我也不是决定框架优先顺序的人。你想做的任何改变都必须和谷歌应用程序一起工作，而且你不可能复制功能来让它为每个人工作(谁说表单和 http？).

无论如何，改变 i18n 在 Angular 中的工作方式是很复杂的。我学到了很多，我觉得我们现在正朝着正确的方向前进。我理解他们对 Angular i18n 的选择，这是翻译应用程序最有效和最稳定的方式。对于像 Google 这样的大公司来说，它工作得很好，但是它并不是大多数开发者需要/想要的。

在这一年里，我没有真正从事 ngx-translate 的工作。问题越来越多，我只合并了几个公关，其中一些已经在那里等了很长时间，没有任何活动，因为我。有一些长期的问题我没有花时间去解决(代码分割/延迟加载，测试，ICU 表达式，ionic 的错误...).

但是在我们开始之前，让我们快速比较一下我的库和本机实现。

### [](#angular)棱角分明

在 Angular 中，您使用一个提取工具来翻译您的模板，该提取工具可以生成 xmb 或 xliff 文件，这些文件是经过实战测试的定义良好的格式。这些文件是由真正的翻译人员使用专业工具翻译的。最后，在构建时合并翻译，得到一个翻译后的包。

#### [](#advantages)优点:

*   翻译流程定义明确，很容易发现遗漏的翻译，您可以在部署应用程序之前将其集成到您的计划中(提取、发送给译者、合并)
*   它的伸缩性很好，你从来没有直接看文件，因为你使用软件，你可以翻译 x 语言，你只需要提取一次，并为每个地区创建翻译文件(这应该是你的专业工具为你做的)
*   它的效率非常高，因为应用程序在启动时就已经预先翻译好了，没有额外的工作来应用你的翻译，因此它可以很好地处理预渲染
*   由于您在构建时合并翻译，这意味着它可以支持指令、组件和其他 html 元素，您可以在不同的语言中移动它们，甚至在需要时删除它们
*   您不需要担心延迟加载，您的包在构建时被翻译，这包括您的延迟加载模块

#### [](#issues)问题:

*   这需要大量的工作来设置，你需要提取，发送给翻译，然后你可以合并
*   您创建了一个应用程序包/区域设置，这意味着您不能在运行时更改区域设置，您需要为此重新加载一个不同的包。为此，您需要处理服务器端路由，以交付正确的区域设置包。谷歌不觉得这是一个问题，因为你不应该经常改变你的地区。事实上，大多数用户可能只改变一次，或者根本不改变。但是它仍然使工作流程变得非常复杂。
*   没有代码翻译，只有模板被翻译，因为这是你现在在编译时所能做的
*   在开发中更难使用，因为你需要停止你的开发服务器，提取翻译，合并它们。JIT 和 AOT 的设置是不同的...
*   你不能翻译库，这对组件库(比如 material，ng bootstrap，...)

### [](#ngx-translate)ngx-翻译

使用 ngx-translate，您可以加载并配置模块，然后加载包含您的翻译的 json 文件。您需要为您的翻译手动定义关键字，并将它们写在您自己可能要翻译的 json 文件中，或者转换成其他格式发送给翻译人员。但是没关系，因为 json 很容易操作和生成。

#### [](#advantages-1)优点:

*   您可以选择处理翻译的方式(捆绑、http 加载、使用服务人员或本地存储进行预缓存等)...)
*   您可以随时更改区域设置
*   它适用于你的模板和代码
*   json(这就是我要说的)
*   社区可以开发插件、定制加载器、工具等...一切都是可破解的，你应该能够让它以你喜欢的方式工作

#### [](#issues-1)问题:

*   它使用绑定(通过管道或指令),这意味着它在运行时工作，当加载和应用翻译时，您可以体验某种 FOC 效应(内容的闪现)。此外，当触发更改检测时，需要一些内存和一些处理器时间
*   如果你想拆分翻译，效果不好，设置复杂，而且程序库中有很多错误
*   json 不是官方翻译格式，大多数专业翻译工具都不支持这种格式，但是您可以使用不同的加载器来支持其他格式(比如 po ),所以这不是一个大问题
*   很难测试
*   如果它坏了，那么你的应用程序将没有文本！
*   它不支持角度元素(组件、指令、管道)，因为 AOT 应用程序在运行时没有“编译”

### [](#changes-in-angular)棱角分明的变化

就像我说的，我已经在 Angular i18n 上工作了快一年了。实际上，我也从事过很多其他的工作，i18n 的变化显然不是框架的重点。在我们能做我们想要的改变之前，许多内部的改变也是必要的。

我极大地改进了文档(i18n 指南)，创建了使用和不使用 cli 的演示项目来帮助人们入门。我处理了一些 bug，做了一些改动，但是我们还没有发布任何主要的翻译版本。

最后，对于 v6 来说，大的变化来了，翻译将在运行时完成。对框架内部的访问意味着它将比 ngx-translate 更有效。您应该不会体验到 FOC 效应，并且在变更检测期间它不会占用任何资源。你终于可以翻译代码了！对于所有语言环境，每个应用程序只有一个包(或者多个，如果您愿意的话)。库应该是可翻译的。

不会改变的是:

*   您仍然必须使用提取工具提取翻译，并在构建时合并它们，这意味着它在开发中不太容易使用
*   还没有 json 格式*和*(我们已经在内部讨论开放 API，这样开发者可以写他们自己的序列化器，如果他们愿意的话)
*   它的设置和使用仍然比 ngx-translate 复杂
*   您可以在运行时在代码中进行翻译，但是模板将在 bootstrap 中进行翻译，这意味着您不能在不重新加载应用程序的情况下更改区域设置
*   新功能的实现仍然需要很长时间，因为我们没有 ngx-translate 这样的库所拥有的自由

### [](#so-what-about-ngx-translate-future)那么 ngx-translate 未来呢？

这是一个很长的帖子，我们终于到了谈论 ngx-translate 未来的部分。在我看来，有两种解决方案:

1/我们继续像去年一样，只合并了几个 PRs，没有开发新功能，也没有改进工作流程。我一直在努力让 Angular i18n 变得更好，希望人们会停止使用这个库，因为原生解决方案会更好。或者可能会出现一个真正的替代者(比如 https://github.com/robisim74/angular-l10n)。

2/我改变了我的工作方式，并决定在库上花更多的时间(至少 1 天/周)来改进它:修复懒惰加载、代码分割、添加功能来帮助测试、支持 ICU 表达式、创建文档化和维护良好的示例、最后解决 ionic 和其他移动问题，...我致力于通过提供 Angular i18n 不能解决的“问题”的解决方案来确保这个库是 Angular i18n 的可行替代方案。我编写更好的工具，甚至可能是翻译的编辑器。我重写了文档，在一个真实的网站上有闪亮的例子。

要做到这一切，我需要让这个图书馆盈利。我在考虑改变许可证，要求公司为库付费(同时对开源和个人项目保持免费)，以换取优先支持(用于修复 bug，以及开发他们最想要的功能)。显然，当前的版本将保持免费和麻省理工学院许可，因为没有法律途径来追溯改变许可证，无论如何，这将是愚蠢的。但是新版本将使用这个新的许可证。

这个库现在在 npm 上被下载了大约 350，0 00 次/月，如果你和`@angular/core`的大约 2，400，00 0 次下载相比较，这意味着我的库在 7 个 Angular 项目中有 1 个被使用！这太疯狂了，这让我相信这是可行的。

**你们觉得怎么样**？你的公司愿意花钱买一个更好的 ngx-translate 吗？你有其他选择吗？

[View on GitHub](https://github.com/ngx-translate/core/issues/783)

由于我们不能等待 Ivy 的出现，我们部署了自己的翻译系统，这个系统几乎没有任何代码或逻辑(与 ngx-translate 相反，它有很多代码和逻辑)。

作为准备，从 ngx-pttx github 项目中抓取文件[，并将它们复制到您的项目中(尚未创建 npm 包)。](https://github.com/vivainio/ngx-pttx)

## [](#the-approach)走近

您需要在分层的 JSON 结构中提供翻译。一个例子(在`en-US.json`中)是:

```
{  "mygroup":  {  "mykey":  "Hello my english text"  }  } 
```

一旦您的应用程序知道要获取什么文件(即选择什么语言)，它就会下载这个文件。从 [angular-translate](https://github.com/angular-translate/angular-translate) 你的狂野 Angular 1 年的格式可能很熟悉。

然后，通过注入 TxService 并执行 setStrings():
将字符串设置为全局可用

```
export class AppComponent {
  constructor(
    private txService: TxService
  ) {}
  ngOnInit() {
    this.fetchStringsSomehow.then(strings => this.txService.setStrings(strings));
  } 
```

现在你可以在各种组件中使用 txService:

```
const text = this.txService.instant("mygroup.mykey");

// warning: this can crash at runtime
const text2 = this.txService.txs.mygroup.mykey; 
```

在模板中，您可以使用 ptTx 管道:

```
<span>{{ "mygroup.mykey" | ptTx }}</span> 
```

或者 ptTx 指令:

```
 <span ptTx="mygroup.mykey"></span> 
```

现在你可能会问——这种类型是如何安全的？嗯，不是的。

因为您想要类型安全(以确保您的字符串继续工作并获得智能感知)，所以您需要创建类型定义。我们在一个构建步骤中完成，使用 [quicktype.io](https://quicktype.io/) 命令行应用程序。将它指向翻译的 json 文件(一个，通常是英文，足以生成类型):

```
yarn quicktype --lang ts --no-maps --just-types --out gen/translations_common.ts ../../some_dir_to_translations/en-US.json 
```

现在，我们可以使用 txService.make()创建一个函数来检查类型并给出字符串。它将 quicktype 生成的类型作为类型参数:

```
 import { MyUiStrings } from "./gen";

  private getLocalizedTexts() {
    const tx = this.txService.make<MyUiStrings>();

    return {
      someText: tx(s => s.mygroup.mykey)
    };
  } 
```

## [](#thats-all)就这些？

是的，这就是你需要做的。你需要自己提供一些零件:

*   确定从哪里获取 json 文件。
*   在应用程序绘制组件之前调用 setStrings()。为此，您可以使用 [APP_INITIALIZER](https://hackernoon.com/hook-into-angular-initialization-process-add41a6b7e) 提供程序。