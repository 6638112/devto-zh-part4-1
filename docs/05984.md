# JavaScript 中提升的秘密

> 原文:[https://dev . to/god crampy/the-secret-of-raising-in-JavaScript-egi](https://dev.to/godcrampy/the-secret-of-hoisting-in-javascript-egi)

提升是 JavaScript 中最混乱的概念之一。这是人们认为 JavaScript 是一种无意义语言的原因之一。但是，一旦你知道引擎盖下发生了什么，一切都变得非常有意义。

## [](#inside-the-engine)发动机内部

JavaScript 是一种由*解释的*语言。这意味着 JavaScript 引擎通过将代码转换为机器码(机器码是计算机可以理解的二进制代码)来逐行运行代码。与 JavaScript 类似，Python 和 Perl 也是解释型语言。但是 JavaScript 与这些编程语言的不同之处在于*提升了*。

试着猜测下面代码的输出:

```
console.log(a)

// Some other code

var a = 5; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果你猜的是 5，那你就错了。

如果你猜得到一个错误，那么你也错了！

上面的实际输出是*未定义*！很奇怪不是吗？当提升有意义时，一切都有意义了。所以让我们弄清楚。

#### JavaScript 的解释

所以我们已经知道 JavaScript 是*逐行解释*的。嗯，这里面也有一些复杂因素。认为 JS 引擎两次*逐行检查你的代码是有帮助的。第一次，引擎检查代码，进行提升和其他一些事情(比如添加丢失的分号)。第二次实际运行代码时。*

所以，*提升*就是为我们的变量和函数建立内存空间的过程。在代码开始执行之前，JS 引擎检查代码并为函数和变量设置内存块。变量值不被存储，但是函数连同它们的定义一起被完全存储。这就像引擎在实际运行代码之前在一张纸上写下它需要跟踪的变量和函数。

让我们来测试一下我们的理解:

**我们前面的例子:**

```
console.log(a)

// Some other code

var a = 5; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

因此，当我们的引擎首先检查我们的代码时，它会“写”在一张纸上(比喻为变量保留内存块)。引擎不会给变量赋值，所以默认情况下它会使用未定义的值*。所以在这个*提升*在我们想象的一张纸(内存)上完成后，引擎再次启动来执行代码。所以在第一行它遇到了变量 *a* 。然后，它查看它的纸参考(内存)。哦！ *a* 被定义，因此它打印出现在*未定义*的值。然后在下一行， *a* 被重新分配值 5。*

 ***再来一个:**

```
b();

function b() {
    console.log('b called!');
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

注意，当*提升*完成时，变量仅存储有*未定义*的值，而函数也存储有它们的定义。因此，在浏览一次代码后，引擎知道有哪些变量，但不知道它们的值。它还知道有哪些功能以及每个功能的作用。因此，在上面的例子中，当我们调用 *b* 时，引擎已经知道存在这样一个函数，以及这个函数做什么。所以我们得到的输出为 *b 调用！*。

**最后一个:**

```
b();
console.log(a);

function b() {
    console.log('b called!');
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这是一个棘手的问题，因为有一件小事你可能会忽略。这里，由于没有定义 *a* ，我们得到一个错误。在运行这段代码时，我们注意到另一件有趣的事情。让我们用*吊装*的知识一步步走过去。所以在第一遍中，函数 *b* 连同它的定义*被提升*并存储在内存中。现在是第二关。看到第一行，解释器将调用函数 *b* ，我们将调用 *b！在我们的屏幕上。在这之后的下一行，我们将得到一个错误，因为没有定义*和*。这里需要注意的是，错误行上面的代码将被执行，输出也会显示出来。这突出了 JavaScript 作为解释型语言的一个非常重要的特性。*

因此，在结论中请注意以下事项:

*   与其他语言不同，JavaScript 在声明之前不会给出调用变量和函数的错误
*   函数被完整地执行，而变量作为未定义的返回，直到它们被重新赋值。

## [](#es6-features)ES6 特性

没有一篇关于 ES6 特性的 JavaScript 博客是不完整的。ES6 引入了两个新的关键字 *let* 和 *const* 来声明变量。使用 let 和 const 声明的变量也被提升，但唯一的区别是在 let/const 的情况下，变量不像在 var 的情况下那样用*未定义*初始化。当变量 *a* 在*时间死区*内时，下面的代码将抛出一个引用错误。如果它没有被提升，那么 *a* 的值应该是 10。

```
a = 10;

console.log(a);
// Reference Error

let a = 5; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

> 那都是乡亲们！感谢您的阅读，祝您度过美好的一天😄*