# 国家管理观

> 原文:[https://dev.to/patrixr/an-outlook-on-state-management-469c](https://dev.to/patrixr/an-outlook-on-state-management-469c)

这篇文章回顾了今天在*前端* web 开发中的状态管理实践。

## [](#not-a-tutorial)不是教程

有了今天的资源，你可能不到一分钟就能找到大量关于如何编写健壮的 web 应用程序的技术指南。

如果你花了一点时间做这件事，你一定会找到关于*“状态容器”*库和模式的教程，又名*“商店”*。最著名的 **Redux** 经常用在 React 应用程序中，或者它的 Vue 对应物 **Vuex** 。

坦率地说，即使我努力，也写不出更好的教程。相反，我在这里想做的是花一点时间思考一下**为什么**我们要做所有这些，以了解编写一个好的应用程序真正意味着什么。

在我们继续之前，我将快速介绍一下 Hassan Djirdeh 关于在 Vue.js 中管理状态的精彩教程。如果你正在寻找一篇更具技术性和动手能力的文章，一定要去看看。

## [](#what-is-a-stateful-system-)什么是有状态系统？

如果您从来没有问过自己，您的系统是否具有有状态的本质，那么它很可能是有状态的。

让我们尽可能地定义它:

> *如果应用程序存储的数据会反过来影响系统的行为和输出，则该应用程序被归类为有状态的*

为了给这个定义一个背景，让我们举一个简单的例子:

示例:*一个用户登录到您的应用程序。该代码检索一段用户相关数据并存储它。下次打开应用程序时，应用程序会读取存储的数据，了解您已登录，并直接打开您的个人资料页面。*

在上面的例子中，由用户数据组成的**状态**影响了应用程序的**行为**，这里应用程序决定向你显示一个不同的页面。

以这种方式编写应用程序是如此普遍，以至于我们很少花时间去思考它。

...*但是我们真的应该*

## [](#side-effects)副作用

下面是软件缺陷的一个常见定义

> *软件缺陷是指计算机程序或系统中的错误、瑕疵、故障或失误，导致其产生不正确或意想不到的结果，或以意想不到的方式运行*

来源:[维基百科](https://en.wikipedia.org/wiki/Software_bug)

让我们关注一个词:

> ...或者以意想不到的方式表现

也存在于有状态系统的定义中:

> ...将反过来影响系统的**行为**和输出

尽管对某些人来说这似乎是显而易见的，但是对我们的数据管理不善是 bug 的直接原因，从而导致不稳定。一个常见的术语是[副作用](https://en.wikipedia.org/wiki/Side_effect_(computer_science))。

所有这些都回到了数据上:

*   数据是不可预测的
*   数据可能是错误的
*   数据可以变异

让我们用一些场景来说明这些副作用。

### [](#case-1-unexpected-mutation)情况 1:意外突变

先说一个数据样本:

```
{
    message: 'This is my first post',
    timestamp: 1560044669311
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我们决定将**日期**显示为一个用户友好的**字符串**，显示消息是多久前发布的，例如“ *1 小时前*

我们的初级开发人员对此一无所知，决定对其进行良好的格式化，**在过程中对数据进行**突变:

```
post.timestamp = moment(post.timestamp).fromNow() 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果读到这一行让你感到不安，那么恭喜你，你理解了数据突变的危险。

**快进**到应用程序生命中的稍后时刻，当另一段代码读取那个帖子时，**期待**一个数字值。

```
console.log(post.timestamp); // => '1 hour ago'
new Date(post.timestamp); // => Invalid Date 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如您所料，这会返回一个无效的日期，最终导致一个 **bug** 。

### [](#case-2-multiple-sources-of-data)案例二:多个数据来源

用户成功登录后，将返回一个 JWT 令牌。它被添加到**本地存储器**中，并在连接到服务器时附加到请求上。

该应用程序由多个**服务类**构成，很好地代表了 API 的不同功能，例如

```
class UserService { ... }
class SearchService { ... } 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

让它们都拥有一个在调用 API 时使用的 **authToken** 属性并不太难。

例如

```
apiCall() {
    ajax('/some/url', { Authorization: this.authToken })
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

每一个基于用户的应用都有一个**注销**功能:

```
logout() {  
    localStorage.setItem('jwt', null);
    UserService.clearToken();
    SearchService.clearToken();
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

那种*有点*的效果，不是很好，但是为了表明我们的观点，让我们继续下去。

现在来了一个功能请求，我们希望我们的用户能够与他的播放列表进行交互。简单，我们添加一个新服务:

```
class PlaylistService { ... } 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

**！问题！**我们忘记在注销方法中清除新服务的令牌。

如果我退出应用程序，现在会发生什么，我们可以想象大量的错误:

*   该应用程序甚至可以在注销后修改用户数据
*   该应用程序可能代表错误的用户
*   该应用程序可以认为用户仍处于登录状态

有些人会认为我们所描绘的架构本身并没有什么错误，但是我们不应该记得清除 PlaylistService 令牌。在我们即将构建的健壮系统中，**我们不需要**。

## [](#how-resources-define-practices)资源如何定义实践

我们不需要追溯到很久以前的历史来记住计算机的内存是用兆字节，甚至是千字节来衡量的。

当我们在资源有限的系统上工作时，在**改变**数据和**重用**内存方面有很好的激励。用低内存占用换取副作用的风险是一个公平的**权衡**。

今天，资源通常是丰富的。为了**稳定**，我们可以允许自己使用更多的数据。

这在日常生活中意味着什么:

*   编写[纯函数](https://en.wikipedia.org/wiki/Pure_function)
*   重新创建替代数据集，而不是改变它们
*   使用语言功能保护数据(例如`const`)
*   仔细选择库，例如
    *   顾名思义，它是专门用来提供非可变结构的
    *   虽然它是一个非常强大的工具，但它也因拥有变异方法而闻名，所以要小心行事

实践随着**时间**和**领域**而改变。随着两个世界开始融合，Web 开发现在看到了从[函数式编程](https://en.wikipedia.org/wiki/Functional_programming)借鉴来的模式。一个很好的例子是 [Elm](https://elm-lang.org) ，一种编译成 JavaScript 的函数式语言。

## [](#is-the-grass-greener-on-the-other-side-)那边的草更绿吗？

我们已经经历了构建有状态系统的许多不利因素。一个问题出现了:**我们能否构建无状态的 web 应用**？
虽然无状态设计在后端已经存在了一段时间，但对于前端应用程序，这不是我们经常问自己的问题。

从技术上来说，没有什么可以阻止我们这样做，但是应用程序通常被设计成有状态的。购物车就是这样的一个例子:这个特性围绕着**存储**和**编辑**数据的能力。

构建一个有状态的应用程序，虽然容易产生副作用，但提供了很多通常被认为理所当然的便利。如果没有本地数据，要绕过这一限制就要加倍努力。

所以我们知道这种状态不会消失，我们也知道它很容易出错。那么我们如何有效地管理 it 呢？

## [](#the-birth-of-flux)通量的诞生

最流行的存储容器是从通量模式中派生出来的。尽管我们可能会发现差异，但他们都试图解决**相同的问题**并分享**核心价值观**。

### [](#formalization)形式化

由于它们的存在，这些容器将状态带到了应用程序的第一线，并且在开发人员的眼皮底下。

它不再是旁观者，而是将数据转换成某种东西**官方的**、**明显的**，因此**值得关注**。

### [](#direct-access)直接访问

应用程序通常构建为组件的树形结构。数据**沿着树向下**级联，不断传递。

这为错误处理数据创造了大量机会。我们可以开玩笑地称之为“中国悄悄话”游戏的软件版本。

通量激发的商店可以减轻风险，因为组件可以直接从真实的来源检索数据。

中国悄悄话的比喻显示了链条越长，信息失真越大。这也让我们有了一个合理的假设，即状态容器在**大型应用**中更有价值。

### [](#single-source-of-truth)真理的单一来源

将一条信息存储在应用程序的多个部分有其自身的风险。这为它创造了使**与**不同步的机会。

托管存储通过提供存储信息的单一位置解决了这一问题。可以说是数据的**黄金来源**。

### [](#encapsulation)封装

状态容器通常会避免直接公开状态。简单的目的是**保护**免受意外的突变。

对于所需的更新，存储将公开一组方法，这些方法将准确地将所需的更改应用于数据。

通过暴露**有限的和受控的突变**，它减少了潜在的意外和不受控制的变化的数量。

### [](#accountability-and-traceability)责任性和可追溯性

当处理由意外或错误突变引起的**bug**时，找到突变的来源可能会很快成为一件麻烦事。每段代码都是潜在的嫌疑人。

幸运的是，状态管理器只允许通过一组有限的入口点进行更改。这个**缩小了嫌疑人的范围:要么是 mutator 方法本身，要么是调用它的代码。**

## [](#thanks)感谢

非常感谢那些在整篇文章中受苦的人。

*快速声明:这里写的一切都是我的理解、经验和观点的产物，绝不应被视为绝对的真理来源。*

另外，我很想听听你对这个话题的想法和评论。

如果任何人希望投稿并提出修改建议，我的 [github](https://github.com/patrixr) 上会有这篇论文。