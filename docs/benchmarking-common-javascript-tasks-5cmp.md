# 优化您的 JavaScript 速度

> 原文：<https://dev.to/agronick/benchmarking-common-javascript-tasks-5cmp>

在 JavaScript 中，做同样的事情通常有不同的方法。你不应该浪费时间担心过早的优化，但是很多时候性能确实很重要。当你处理巨大的数据集和大量的 DOM 元素时，你会把浏览器推到极限。

我有几个问题，我决定探究它们。

需要注意的是，这些基准并不科学。它们是出于好奇而放在一起的，有许多情况会影响这些结果。我下面讨论的结果发生在 Chrome 的 V8 JavaScript 引擎上。

让我们看看一些常见的做事方式，看看浏览器是如何反应的。

# 串联与扩散

当你想组合数组时，你有几个选择。你可以使用旧式的`arr.concat(arr2)`或者你可以使用扩展操作符`[...arr, ...arr2]`。它们都返回一个新的数组。

您可能会惊讶地发现，对于大型阵列，扩展可能会慢大约[50%](https://jsperf.com/concat-vs-spreader)。我发现，除非数组少于 10 项，否则 concat 总是更快。

# 绑定 vs .箭头功能

当你传递一个回调函数时，很多时候你想保留对`this`的引用。对于如何做到这一点，您有两种选择。你可以做`this.myFunction.bind(this)`或者`() => this.myFunction()`。事实证明，使用箭头函数比使用 bind() 要慢 83%。

也就是说，除非你多次调用这个函数。用`bind()`设置功能比用箭头功能更昂贵。因此，如果你只调用函数一次[，bind 会慢 90%](https://jsperf.com/bind-vs-array-single)。

# 过滤为真

从数组中获取真值是一项常见的任务。有几种方法可以做到这一点。常见的包括传递一些东西来过滤。由于某种原因，过滤器需要一个值。

那么应该将它转换为布尔值吗？

```
arr.filter(Boolean) 
```

只需返回值:

```
arr.filter((i)=> i); 
```

还是用双负把它强制转换成布尔值？

```
arr.filter((i)=> !!i); 
```

这是一个微小的差别，但是使用`arr.filter(Boolean)`比使用[慢 9%](https://jsperf.com/filter-true)并且无操作箭头功能是最快的。双重否定大约慢了 2%,实际上什么也没做。

# 集合 vs 数组

集合和数组可以用于很多相同的事情。主要区别在于集合是唯一的，而数组不是。另一个很大的区别是，检查一个对象是否存在于集合中要比检查一个数组快得多。差别大得惊人。拥有 10，000 个条目的 JSPref 报告`Array.includes`比`Set.has`慢 100%。

但是如果你有一个数组，你想检查里面是否有东西。是否应该将其转换为集合？事实证明创造一个场景有点昂贵。如果你需要检查一个 10，000 个条目的数组是否包含 200 次[的内容，你最好还是用](https://jsperf.com/convert-array-or-check-includes)把它作为一个数组并使用`Array.includes`，而不是把它转换成一个集合并使用`Set.has`。不过，这是一个转折点。在一个包含 10，000 个项目的数组中，似乎有大约 400 个检查。

我希望您喜欢这些基准测试。和往常一样，你应该对你的用例进行基准测试，除非你的代码需要高度优化，否则最重要的是代码看起来怎么样。