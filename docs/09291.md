# 请不要忘记你的历史

> 原文:[https://dev . to/cpow/please-don-t-forget-your-history-in-git-395g](https://dev.to/cpow/please-don-t-forget-your-history-in-git-395g)

当你开发一个新的特性，或者修复一个错误，并且你的代码被批准；合并到 master 之前做什么？你是否挤压了所有的提交，写出了最漂亮的提交消息，并把所有的东西都合并进去？或者当合并时，你会把历史——缺点和全部——留在原处吗？

我希望你做后一件事——让全世界看到你的过程。很多人不一定同意这个观点；说你必须挤压所有的提交，把你的历史重写为漂亮的小块，并且只合并最漂亮的 git 提交。我认为这有点愚蠢，原因如下:

1.  你不应该打破你的建筑，所以为什么要重写历史呢？
2.  当有人看到你的承诺时，他们需要详细的细节
3.  管理整洁的提交是一种可怕的体验。

让我们更详细地谈谈这几点。

### [](#1-you-should-never-be-breaking-your-build)1。你永远不应该打破你的建设

我记得不久前看过一个关于 ID 软件和他们如何在全盛时期快速开发游戏的演讲。对我来说最突出的一点是*“永不打破构建”*。每当 ID 提交代码给其他工程师测试时，构建总是有效的，游戏总是可玩的。这使得开发团队只专注于创建工作特性。他们从来没有提交一大堆 WIP(工作进行中),并告诉自己以后可以修复它；不，构建必须总是通过，游戏必须总是可玩的。

我在自己的工程实践中牢记这一点。每当我向代码库提交东西时，我都确保它总是工作，测试通过，并且“构建”从不中断。这是保持专注、保持提交轻松、保持特性稳定的最简单的方法。当以这种方式编写代码时，您永远也不会觉得有必要压缩提交、重写提交消息或任何类似的废话。只需编写不破坏当前构建的可靠的提交，您就可以顺利进行了。

### [](#2-people-need-granular-detail-when-looking-at-commit-history)2。当查看提交历史时，人们需要粒度细节

如果您经历过这种情况，请阻止我:您正在调试一些非常复杂的代码，它是非常密集和难以理解的认证逻辑。您检查提交历史以获得一些上下文，它显示如下内容:

> 为用户创建购物车功能，以便在结帐前存储商品

*什么？*

您看到的不是围绕这一小段代码的上下文提交，而是一条概括了整体的*压缩的*提交消息👏全部的👏特征👏。我在许多组织中经常看到这种情况。有太多的重点放在粉碎你的承诺，以保持历史整洁，但我认为这是愚蠢的。相反，想象一下看到这一系列信息

> 创建了新的验证功能来存储购物车功能的信息
> 
> 修正了带有认证功能的小错误

现在我们有了一些背景！您可以看到正在调试的函数的每个变化背后的实际思维过程，现在您有了更多的信息来继续进行。你可以看到你的同事在 auth 模块中创建了一个与这个大特性相关的函数，然后你可以看到他们已经试图修复了一个 bug！也许这造成了你现在正在调试的错误？它给你的思考过程增加了太多东西，而你的猜测却少了很多。

### [](#3-managing-groomed-commits-is-not-fun)3。管理经过整理的提交并不有趣

如果您的公司或组织大量实践重写历史，您可能会遇到重写提交的合并冲突。让我们看一个场景:

1.  您添加一个新特性并提交
2.  您为该特性添加了一个测试，并进行第二次提交
3.  有人检查了您的代码，发现了这个特性的一个小问题
4.  您创建一个新的 commit 来修复这个 bug，交互地重新基于 master，并用这个新的工作修复 commit #1。
5.  你意识到你忘记了一些东西，用更多的测试重新确定和修正提交#2
6.  你用 master 来更新你的数据库，然后 *BOOM* 你遇到了合并冲突。

事实证明，当您修复您的提交并重放您的分支的重写历史时，您有合并冲突。这是我见过很多次的常见问题。当你不断地用更多的工作修正提交时，管理更大的特性和/或分支真的很难。最终你会遇到合并冲突，通常会创建一个全新的分支，只是为了让一切都变得更好。

### [](#conclusion-dont-forget-your-history)结论:不要忘记你的历史

我认为，一般来说，在编写代码时，将提交历史留在原处应该是最佳实践。这将为您的同事留下更好的提交消息文档，在处理 bug 时有更多的上下文，并且总体上更容易处理。

现在，如果你不介意的话，我不得不在不抹杀任何历史的情况下提交这个帖子！