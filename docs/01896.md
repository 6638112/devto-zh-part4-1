# 有效的 Java 星期二！让我们考虑静态工厂方法

> 原文:[https://dev . to/kylec 32/effective-Java-Tuesday-let-s-consider-static-factory-methods-170 p](https://dev.to/kylec32/effective-java-tuesday-let-s-consider-static-factory-methods-170p)

最近我一直在通读约书亚·布洛赫(Addison-Wesley 2018)写的一直很受欢迎的 [Effective Java](https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997/ref=sr_1_1) 。如果你是 Java 开发人员，希望这不是你第一次听说这本书。也许你和我一样，第一次看到它的时候，你会想，“这可能是旧的，过时了。”事实上，第一版是在 2000 年初发布的。然而在听到许多热情洋溢的推荐后，我决定我应该试一试。不用说，我又惊又喜。唉，这并不奇怪，好的设计不会真的过时(我们还在谈论[四人帮](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_2)，不是吗？)

考虑到所有这些，为什么选择这个系列呢？老实说，自私地说，第一个原因是为了我自己。我坚信学习的最好方法是教。尽管如此，我确实热爱好的设计，也愿意分享这份热爱，并希望帮助其他人学习新的东西并付诸实践。话虽如此，我还是决定试着吸取书中的一些原则，每周分享一个新的。试着给自己一点压力，但也给自己一个节奏来发表文章。

最后，这个系列是书的替代品吗？一点也不，我仍然强烈建议你拿起这本书。希望这可以作为本书的一个伴侣，给你一个不同的观点。

事不宜迟，我们开始吧。

*第一章:静态工厂与构造函数*

当你开始进行面向对象编程(OOP)时，你首先要学会的事情之一就是如何创建对象。如果你不能创建它们，拥有所有这些对象也没有多大用处。我们通常学习创建对象的方法是通过构造函数。构造函数相当简单明了，所以这很有意义，可以很好地为我们服务。另一个选项是静态工厂方法，作者建议很多程序员不要去做，虽然他们可能应该去做。那么什么是静态工厂方法呢？简单地说，静态工厂方法是返回类的实例的静态方法。那么这看起来像什么:

```
LocalDateTime date = new LocalDateTime(Instant.now()); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

vs

```
LocalDateTime date = LocalDateTime.ofInstant(Instant.now()); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这两者之间肯定没有太大的区别。那么工厂方法提供了什么好处呢？

*工厂方法可以有名字*

当我第一次开始开发软件时，我不认为我理解好的命名的力量。构造函数没有被命名的能力。因为它们不能有不同的名字，你也不能有两个构造函数，做不同的事情，以相同的顺序接受相同的参数。例如，如果我们想在 LocalDateTime 类中添加一个构造函数，该构造函数获取一个时刻，并生成一个 LocalDateTime，这个时刻是所提供的时刻之前的一个随机时间，比如说，我们如何用构造函数来完成这个任务呢？改成这样的？

```
LocalDateTime dateTime = new LocalDatetime(Instant.now(), shouldBeBefore); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

绝对不行。但是用工厂方法，我们可以写如下:

```
LocalDateTime datetime = LocalDatetime.randomTimeBeforeInstant(Instant.now()); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

干净多了。

程序员将使用的另一个技巧是改变参数的顺序，这可能不像上面的例子那么明显，但是对于未来的开发人员来说，知道哪个做什么是非常困难的。因此，对于可维护性来说，这不是一个很大的胜利。

*工厂方法不需要每次都创建新对象*

构造函数本质上需要在每次被调用时创建一个新的对象。方法就不是这样了。想想 singleton 模式，这是一种大多数人都熟悉的模式。事实上，这是一种利用静态工厂方法的模式！在单例模式中，`getInstance`方法的真正目的不是创建多个实例。还有其他的选择。返回缓存值或枚举。

工厂方法可以返回方法返回类型的任何子类型的对象

这是一个很好的能力。能够将这种需求从接口中分离出来给了我们选择。这也使您有机会根据传递给函数的参数返回不同的子类型。因此，我们不仅可以返回子类型，还可以在运行时动态选择要返回的子类型。进一步扩展，我们甚至可以返回在编写工厂方法时不存在的类的实例。同样，这导致了更多的选择。好的设计通常都是留有余地。

那么工厂方法有哪些缺点呢:

*它们影响我们使用继承的能力*

如果你提供给你的类的用户的只是工厂方法而没有公共构造函数，那么这个类就不可能使用继承。这也可以被视为一个好处(期末班已经这样做了)。只是又一次考虑组成而不是继承。这是我们在使用这种方法时必须记住的事情。

*在公共 API 中很难找到它们*

因为构造函数是特殊的，它们跳出了文档和类。那么如何才能降低这种风险呢？一种可靠的方法是遵循工厂方法的命名惯例。其中有来自的*，*的*， *getInstance* ，*

*凯尔的拍摄:*

我认为这是一个坚实的工具带。虽然我仍然很难把这作为我每次做的基本案例，但我正努力记住这一点。关于模式的另一个有趣的部分是，经过几年的开发，你会发现自己无意中发现了这些模式，并在不知不觉中使用了它们。这种模式没有什么不同。在我的开发生涯中，我曾经使用过单件以及更通用的静态工厂方法。听到你所做的事情是其他人已经使用的实际模式，总是令人放心的。

你呢？你以前用过这种模式吗？它对你有什么作用？