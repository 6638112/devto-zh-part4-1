# 在 React 中轻松处理路线变更

> 原文：<https://dev.to/s_aitchison/handling-route-changes-in-react-accessibly-44fn>

(这篇文章最初发表在[Up Your A11y:React](https://www.upyoura11y.com/handling-focus/)中处理路线变更的焦点)

对于辅助技术用户来说，任何客户端路由呈现都可能导致混淆和上下文丢失。在本帖中，我们将简要介绍:

*   了解客户端呈现引起的一些焦点问题
*   实现一种简单的技术来为辅助技术用户恢复上下文，并确保更多的人可以参与到您的内容中

## 服务器端 vs 客户端渲染

最简单地说，服务器端呈现意味着当您导航到一个新的路径时，会联系服务器请求显示页面，并在浏览器中呈现一个全新的页面。

另一方面，客户端渲染意味着“examplesite.com”和“examplesite.com/page2”实际上是同一个页面(index.html)，但客户端应用程序决定在运行时将什么内容放入该页面。

实际上，事情远不止如此，尤其是使用新的服务器端呈现技术，但是理解 React 中的焦点管理的关键是理解当用户单击链接转到应用程序中的另一个路径时，DOM 在运行时被操纵，并且单个页面的内容被改变。你的用户从未真正“离开”页面。

这导致了一些可访问性问题，其中之一是当路由发生变化时焦点的处理方式。

## 一个简单链接的快速比较点击

想象以下场景——作为一个屏幕阅读器用户，您阅读了同一个 web 应用程序中另一个页面的链接。您可以使用键盘命令点按该链接。你预计会发生什么？

在“服务器端渲染”领域，会发生的情况是:

*   屏幕阅读器通知您，您按下了链接
*   浏览器中将加载一个全新的页面
*   页面的焦点被重置
*   宣布新的一页

但是我们知道，像 React 这样的客户端渲染，我们不会收到新的页面。如果焦点没有被显式处理，一个更可能的事件链是:

*   屏幕阅读器通知您，您按下了链接
*   获取新内容并将其填充到 UI 中
*   您的屏幕阅读器不会向您通告任何有关新内容的信息
*   焦点仍然在第一页的链接上，即使它不再可见

试着想象一下，对于一个有视觉障碍的用户来说，这是多么令人迷惑。他们如何知道在这个新的内容页面上从哪里开始？

当前的焦点可能在页面的中间，而不是你想让他们阅读的主要内容附近。当他们试图开始阅读新内容时，他们可能不容易识别它是否有用，或者他们可能会因缺乏上下文而感到沮丧。无论哪种情况，他们很可能会放弃并离开你的应用。

## 潜在方案

有几种方法可以尝试解决这个问题，都涉及到在加载新内容时手动操作页面上的焦点。接下来的问题是:当新的“页面”加载时，我们应该把焦点放在哪里？

最近，GatsbyJS 发布了一篇有趣的文章，总结了这些技术的一些用户测试。我建议完整阅读他们的帖子，但是剧透一下:

> 专注于一个标题被发现是最好的体验，因为它会节省时间，并清楚地表明发生了什么

## 非常简单的解决方法

继续上面那个简单的点击链接的例子——在 Gatsby 的用户测试中发现最理想的行为是确保以下事件序列:

*   您单击该链接，屏幕阅读器会确认您已按下该链接
*   获取新内容并将其填充到 UI 中
*   一旦加载了新内容，焦点将立即放在新内容的“h1”元素上
*   “h1”的内容由屏幕阅读器读出

**这有助于以两种关键方式恢复上下文:**

*   “h1”很可能在页面的顶部，因此键盘焦点位置被重置到一个更传统的位置，而不是潜在地浮动在页面的中间
*   “h1”应该已经包含了与新页面最相关的描述，以及用户可以在上面找到的内容(毕竟这是页面的主要标题！).宣布它会立即将用户导向新的内容。

## 实施解决方案

实现这种行为非常简单，只需要三个基本步骤:

1.  在跳转顺序的开头插入 h1 元素，并添加对它的引用
2.  在 componentDidMount()中，使用您创建引用来聚焦 h1
3.  禁用 h1 元素上的默认焦点突出显示，以防止焦点对屏幕阅读器以外的人可见

“可聚焦标题”组件的一个非常基本的示例实现:

```
class FocusableHeader extends React.Component {
  headingRef = React.createRef()

  componentDidMount() {
    this.headingRef.current.focus()
  }

  render() {
    return (
        <h1
          ref={this.headingRef}
          className="focusable-header"
          tabIndex="-1" >
          I'm a focusable header!
        </h1>
    )
  }
}

export default FocusableHeader 
```

Enter fullscreen mode Exit fullscreen mode

和相关的 CSS 来禁用这种特定类型的标题的可见焦点样式:

```
.focusable-header:focus {
  outline: none;
} 
```

Enter fullscreen mode Exit fullscreen mode

## 就是这样！

只需几个简单的步骤，就可以解决路线变更的问题，并且您的内容可以被更广泛的用户轻松消费。

但是请记住，在跳转顺序中插入项目和禁用焦点突出显示应该非常小心谨慎地进行；我只是根据这个特定用例中的用户研究来推荐这一点。

如果你想看这篇文章的一个版本，其中有路线变化的应用程序示例，这样你就可以试驾最初的方法和示例解决方案，前往 [Up 你的 A11y](https://www.upyoura11y.com/handling-focus/) ，在那里你会找到答案！

* * *

你觉得这篇文章有用吗？请考虑[给我买杯咖啡](https://www.buymeacoffee.com/mgkZuRU)，这样我就可以继续制作内容🙂