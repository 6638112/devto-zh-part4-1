# React，OOP 和键值存储。MVC 的两个层次

> 原文:[https://dev . to/aon 24/react-OOP-and-key-value-store-two-levels-of-MVC-3g7](https://dev.to/aon24/react-oop-and-key-value-store-two-levels-of-mvc-3kg7)

文章长，无图。这不是如何做的指示。这些是我对在大型项目中使用 React 的想法。在阅读之前，看一下[结果](http://sova.online/en)(没有广告)是有意义的。

对不起，我的英语不好

## [](#1-server-1st-level-mvc)1。服务器(一级 MVC)。

从客户端，一个请求被发送到服务器的 http-API，响应应该是一个 html 页面。API 解析参数，检查 ACL，并用必要的参数向模型发出请求。

### [](#model-level-1)**模型(一级)。**

该模型返回一个包含字段名称和值(键值)的对象。此外，API 调用所需的视图，即表单。表单的名称可以在 http-request 的参数中(...& form = myFormForPrint &...)，或者可以由模型从数据库中生成(其中，键值可以是“form”:“my form”)。当然，请求中表单的名称更优先。

### [](#form-as-a-view-of-the-1st-level)**形式为一级视图。**

我的表单是一个 Python 模块(以下简称表单模块)，包含标记和几个函数。用每种形式创建一个类更加困难(“简单比复杂好”，尽管“一个类而不创建一个类”听起来很奇怪)。视图创建了一个 html 页面，其中包含:

1.  从 js 格式的模型中获得的修改后的对象。
2.  到标记的链接(我的标记是转换成 json 字符串的 Python 字典)。
3.  只有这个表单需要的附加 js 和 css 文件的链接。
4.  链接到 SPA，即在 React-App 上(将呈现标记的 transpiler)。

同样更详细。

数据的形成和修改。

表单模块可以包含一个 ***queryOpen*** 函数，该函数传递来自模型的对象、模式(读取/编辑/新建/等等)、用户名、来自 http 请求的参数。
***查询打开*** 可以更改/添加/删除字段(例如，将‘谁’:‘伊万·彼得罗夫’替换为‘谁’:‘到伊万·彼得罗夫’或添加新的‘到伊万·彼得罗夫’字段)。
如果客户端收到创建新内容的请求(‘new’模式，例如，新订单)， ***queryOpen*** 将收到一个空对象，并能够设置默认字段值。
用于向客户端发送字典“数据”，也是键值:{“字段名 1”:值 1，“字段名 2”:值 2，...}会有所准备。感兴趣的人可以称之为层、管道、脚本、串行器 DRF。

**页面布局**。

表单模块必须有一个函数*，从 http-request 中传递模式、用户名和参数(几乎和 ***queryOpen*** 中一样)。根据所传输的函数形成所需的标记。这里是 React，不是 JQuery，所以没有 Jinja 2 等模板。如果您已经为这个表单创建了 SPA，那么您应该在 html 中包含这个脚本的链接。如果所有的表单(在我的项目中大约有 100 个)都是由一个脚本创建的，你可以静态地注册链接。
我的 react 应用程序解析并绘制接收到的 json 字符串形式的表单(更多信息见下文)。第一次调用的 ***page*** 函数形成并记住这个字符串，在后续调用中它返回它。该行的 url 缓存在客户端。
因此，第一级 的 ***视图生成一个包含字段数据和标记链接(指向表单)的 html 页面。
模板和表单有什么区别？从程序员的角度来看，不，这里有标记和标记。从概念分析的角度来看，这是有区别的:在 DJango 的情况下，视图不再是一个控制器，它不形成一个页面，它只是用标记给出一个到 json 行的链接。就速度而言，它有优势:服务器不会为每个请求生成 html，浏览器将表单存储在缓存中，只有数据通过网络传输。****

 *### [](#1st-level-controller)**第一级控制器。**

控制器是客户端。API 给他发了一个第一级 的 ***视图形成的 html 页面，忘记了。如果客户想保存数据库中的数据，他会提醒你。顺序相反:
客户端发送 json 格式的字段值，
表单模块调用 ***querySave*** 函数。有了它，你可以做额外的验证，改变数据中的某些东西。
如果 ***querySave*** 返回 True，则数据转移到模型中写入数据库。
成功完成记录后，客户收到期待已久的代码 200。
在表单模块中可以有一个函数*，在写入数据库并响应客户端后调用。它可以发送数据用于索引等。****

 *MVC 很好，因为它分担责任。模型返回数据，并且不干扰提交操作。碰巧模型返回完成的 html 标记。对于这样的标记，有一个很棒的表单，它什么也不做，只是将收到的内容发送给控制器。顾客想更换日程表上的桌子，没问题。我们删除表单，至少为 React、至少为 Plotly-Dash 创建一个新的表单，并将其发送给控制器。让他自己去发现。

更换第一级控制器甚至更容易，因为控制器是客户，即计算机旁的雇员。如果客户开始失败，在填写字段时出现错误，他们就会解雇并重新填写。

## [](#2-client-2nd-level-mvc)2。客户端(第二层 MVC)

客户端以 key-values 的形式接收数据，我们会认为它是一个 ***模型*** ，以及 形式的 ***url，它也是一个 ***视图*** 。
在我的例子中，表单是 json 字符串，其中封装了 ***控制器*** 和标记元素。每个 ***控制器*** 都有一个名称(字段名)。他聪明(把状态保留在自己身上)，英俊，面向对象。***

这是为什么呢？为什么不是 redux？我解释。

有一个项目，在项目中有大约 100 个表单和大量的业务逻辑。有自己意愿的活跃用户约 500 人。有一个任务:快速做好一切，快速做出改变。
你可以在 React 中描述每一种形式并在 reducer 中做份额的处理。结果，我们得到:

*   几兆字节的 SPA，或几个 SPA
*   表单开发/修订 SPA 的新版本
*   表单业务逻辑的改变——新版 SPA
*   多枝的，延伸到地平线之外的，缩小的树
*   React 程序员所做的任何更改

我们走了另一条路。屏幕上打开的每个表单都是 ***文档*** 类的一个对象(姑且称之为 ***文档*** )。下载文档后有:

*   具有键值形式字段的对象
*   url 表单
*   这种形式的纯 javascript 和 css

doc 对象通过 url 从服务器或缓存接收一个表单(json 字符串),将其解析成 React-components 并发送给 render。在 ***doc*** 中渲染时，一个控制器寄存器{fieldName: control，...}已创建。
希望 ***ref*** 不要被禁止。禁止 ***ref*** 与禁止 pluses 中的指针相同。

### [](#2st-level-controller)**2st 级控制器。**

控制器注册在注册表的 ***doc*** 对象的 ***字段名*** 下

*   保持状态本身
*   控制器可能有方法 getValue、setValue、setFocus、changeDropList
*   当状态改变时，控制器可以生成 recalc 事件
*   按钮型控制器没有状态，但可以生成命令。

**中间件**

如果有一个 ***控制器*** ，有一个 ***视图*** ，那么就应该有一个 ***中间件*** 。带有列表的控制器能够自己从服务器更新列表(方法***changeDropList***),但是在很多情况下，没有中间件是不行的。
一个 ***类文档*** 可以处理十几个标准命令( ***)打开、关闭、打印带有选择的表单*** 等。)，对于其他命令，使用可加载脚本。对于他们自己的每一种形式。还有 ***中间件*** 。

React 应用程序最初对它必须维护的表单以及表单脚本的位置一无所知。当它接收到表单 url 时，就会知道这一切。为了确保可加载表单脚本与 ***文档*** 类的对象的连接，引入了 1 个全局(恐怖)变量。每个表单的脚本应该这样开始:

```
window.sovaActions = window.sovaActions || {};
window.sovaActions.myform = { 
```

，其中 ***myform*** 是 ***form*** 的小写名称。需要 ***表单名称*** 是因为在页面上可以同时打开几个文档。
脚本结构:

```
window.sovaActions = window.sovaActions || {};
window.sovaActions.myform = {
    init: doc => {}, // initialization of data. Called before rendering (controllers have not yet been created). Rarely used.
    Init2: doc => {}, // Called after rendering. I'm not used at all.

    cmd: {// command handlers
    logoff: doc => {window.location.href = '/ logoff'},
         ...
    },
    recalc: {// state change handlers
        PROJECTO: doc => doc.forceUpdate (),
    // called when the projectO checkbox changes
    // controls the hiding of the project section
         ...
    },
    hide: {
       project: doc =>! doc.getField ('projectO'),
    // hide everything with the name project, if the 'projectO' field is empty
         ...
    },
    readOnly: {
        SENTOK: doc =>! Doc.getField ('MODIFIED'),
// field 'SENTOK' in readOnly mode, if the field 'MODIFIED' is empty
         ...
    },

    validate: {
        who: doc => doc.getField ('who')? '': 'The' Who 'field is not filled'
// check the field who. Empty line - OK, otherwise the message to the operator

// form validation is a promise. In this example, yes () is always returned.
        form: doc => new Promise ((yes, no) => {
            let disableAutoOrder = doc.getField ('ccType') === 'query';
            for (let i = 1; i <= 5; i ++) {
                let val = doc.getField ('RESPRJ' + i);
                if (/ behind my signature / .test (val) &&! / (inform | inform)  \ s + (for each | each)?  \ s * applicant / .test (val)) {
                    disableAutoOrder = true;
                }
            }
            disableAutoOrder && doc.setField ('AUTOORDER', '');
            yes ();
        })
         ...
    },
}; 
```

在所有函数中，第一个参数是对 ***doc*** 对象的引用。即使页面上有几个相同的表单，团队中也不会出现混乱。
总的来说，它看起来像一个*，但(恕我直言)并非如此万能。*

 *很多人对 SPA 的理解很简单。说“SPA！”，然后把它们都塞进一页纸。这是错误的。

一个不成功的 SPA 例子:Sber-网上银行。

我点击“新付款”，表单在同一个选项卡上打开(甚至用 ctrl)。我不能打开一个旧的支付订单从那里复制一些东西。离开剪辑之前，我什么都不会做。也许程序员不知道你可以在一个新标签页中打开另一个 SPA。

读到这里的人已经正确地注意到:

“React+Node.js. I 以更正后的形式，按 ctrl+s，我在第二台显示器上看到了结果。但是要理解你的巨蟒——解散。”

很难否认这一点，但我会尽力而为。

1.  React + ES2016 也行，Python 更好。

听起来没有说服力。

1.  在 python 上，您可以编写一个返回表单片段的函数，并在必要的地方插入一个片段。

*在反应堆上也是可能的。导入尚未取消。*

1.  python 上的表单更加灵活。根据用户的访问模式，我可以向他提供所需的表单。在服务器上更好地处理权利和角色。当数百个需求相互冲突的人使用系统时，界面经常会发生变化。在 python 上，这需要几分钟，无需重新组装应用程序。我的 SPA 已经几个月没更新了，表格也改得很频繁。

*用几分钟时间重新构建应用程序。*

1.  有一个双屏幕 LM 布局管理器，在一个屏幕上你放置元素(标签、控件、片段)，在另一个屏幕上你可以实时看到结果(使用了 **websocket** )。它不能在手机上运行，但是在智能手机上开发表单仍然很少见。React 的程序员很贵，也很少见，而且有了 LM，你可以把表单中元素的排列分配给任何人。

*在 React-programmer 上省了钱，雇了一个 Python-programmer。谁更便宜不得而知。*

不服气。

我记得那次讨论，程序员抱怨还原者的混乱，觉得像的人都啄他。曾在 SPA 4 的同志(四！)形式。

在我的项目中大约有 100 个。我朋友有 200 左右。
如果在 1 个 SPA 中推送所有表单，会非常繁琐。可以分成几个，但在我看来，管理这样的项目更难。有代码分割，但它会使事情变得更加复杂，并且需要项目中 5 的高级人员。

我喜欢反应堆。当我看到在 OOP 风格中，声明性 html 和命令性 javascript 如此完美地结合在一起时，对 javascript 和 html 的持续仇恨消失了。但是 redux 并没有启发我，因为它扼杀了 OOP。我的控件中有 ***FileShow*** 。这是一个包含愚蠢组件的容器。文件列表存储在一个容器中，愚蠢的组件只显示名称，并能够播放，预览，上传，下载和回调。没有**的作品伟大 *mapPropsToState* 的作品伟大**。

人不一样:有的油动词，有的油名词。重叠式的核心是动作，也就是动词。reducer 本质上是一个操纵组件的动词。

这种方式叫做函数式编程，这很正常(我自己也用函数)，但是我觉得用名词(对象)，当属性被封装后，就有了信号和与外界沟通的开放方法。 ***React 组件*** 理想情况下匹配 OOP，除非你用 ***连接*** ，把一个组件作为一个类杀掉。

弗洛伊德和**荣格**有不同解释的动机，而两人都是执业医生，都接受治疗(各有各的方式)，最重要的是，治愈了人们。如果您的应用程序工作正常，并且受到用户的喜欢，请吐槽缺少一个概念模型，不匹配那里的任何模型，即使它是用 JQuery 编写的。没关系。主要是结果。

此外。在 React 上设计系统是一个 bug。有必要在头脑中设计。React 是构建界面的优秀工具，但设计的优先级是 1 级。MVC 级的客户端部分只是一个控制器，它可以由几个库来实现。同样的例子还有表格:你需要数字——在 React 中打开的 SPA，需要一个图表——从 Plotly 中打开的组件——Dash。

创建一个使用数据库的 SPA 并不意味着重写所有旧的表单。在我的项目中有 2012 年出生的表单，没有人会重写它们。

我说的是严肃的项目。如果你有 4 种形式，按照你的想法去设计，一切都会迎刃而解。

* * *

为什么在头键值存储中，而不是在键值数据库中？

因为我们在 RDB 将 KV 实现为 5 个字段的 1 个表:

1.  uuid -二进制，16 字节。Unid 文档。
2.  xcrt -时间戳。创建字段的日期和时间。
3.  xnam - text。字段名称(键)。
4.  xval - text。字段值。
5.  xmdf -时间戳。将字段转移到历史记录的日期时间。

当字段更改时，旧值将被转移到历史记录中，并创建新记录。这就是具有回滚能力的时间机器。

对于搜索，他们使用 Sphinx Search(简单、方便、快速)，添加了几个表来显示列表。

我们没有一个大的日期:在 2 个服务器上有大约 1000 个日志，日志中的文档数量从 1 到 60 万。在一个 MySQL 服务器上，在另一个 PostgreSQL 上。两者都应付。比 Mongo 更容易也更快。

恕我直言，阿列克谢·诺西科夫***