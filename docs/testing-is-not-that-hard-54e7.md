# 测试…并不难

> 原文：<https://dev.to/sierisimo/testing-is-not-that-hard-54e7>

(这是我的第一篇英文和中文帖子)

# 测试…并没有那么难

我们需要不时地谈论这个话题。我们大多数人都很熟悉它，我们对编写测试感到很舒服，但事实是这样做并不是一个特别受欢迎的话题。

在过去的几年里，趋势是使用一些很酷的技术的变体，像 TDD 和 BDD，它们被很好地应用；但是大多数开发人员不遵守规则，或者感觉截止日期不允许他们只编写单元或集成测试。天哪…我甚至听到有人说:“[原文]编写测试是 QA 团队的事，对吗？”

嗯……这是我试图展示测试并没有那么难，并且可以成为你日常工作流程中容易的一部分。

注意事项:

*   当不加区分地提到方法或函数时，我将提到“函数”，这种对“正确名称”的讨论与本主题无关
*   我的大部分工作是在 android 上进行的，所以这可能只是 Kotlin/Java 中的例子，但是大多数概念也适用于其他语言，比如 JavaScript 中的`private`可以是`module.exports`中没有公开的函数

## 为什么要考试

作为开发人员，我们喜欢编写大量代码。我们喜欢用各种不同的东西让我们的生活变得非常复杂:

*   “我要用 X 算法对这些元素进行排序”
*   “我们应该为它添加一个 hashcode 函数”
*   “该设计模式将解决我们所有的问题”
*   “就用这个工具解决那个小问题”

有时我们会成功地解决问题。但是时间会消耗一切，包括代码，如果你需要使用你为那个小项目写的代码，并且不确定它是否能工作…你会怎么做？

测试可以在很多方面帮助我们。从 TDD 爱好者的角度来看，我们可以说:“测试帮助我们不破坏东西”，这意味着一旦我们进行了测试，引入的新特性/变化将不会破坏当前的代码，从 TDD 的角度来看，这是真的。但是并不是每个人每天都遵循 TDD，所以我们需要不同的视角。对于普通的开发人员来说，测试是一种“检查事情是否正常工作”的方式。这意味着我们可以验证，即使当新的东西(特性或变化)到达代码时，代码仍然是可用的，并且不会产生意想不到的事情或不应该发生的奇怪事情。

这是进行测试的主要原因。当我们想要验证我们的工作时，测试是必经之路。我记得在我上小学的时候，一位教授向我们展示了如何验证不同数学运算的结果，这样我们就可以在给她布置作业之前检查我们的结果。测试是类似的东西。测试是对我们的代码进行检查的一种方式，以验证一切都按预期运行。测试就像品尝你正在烹饪的食物:你拿一把勺子，尝一点味道，如果味道不合你的口味，你就在食物中添加和混合新的东西，直到它给你想要的结果(味道)。你不会为了让食物味道更好而调整勺子或嘴巴，或者按照你的意愿，你去调整食物，然后用勺子和嘴巴再试一次。测试也是一样的，你修正你的代码，而不是让代码按预期工作的测试。

> 注意:请品尝你做的食物，然后放在盘子里给你的客人。他们会感激的。

## 什么时候应该考试

虽然对于您应该获得多少百分比的“测试覆盖率”(或者用人类的话说“多少代码有测试”)有一个普遍的争论。对此我的回答是:**尽你所能**。您应该尝试为代码的大部分功能编写测试。在努力取得好成绩的同时，你仍然需要记住一些事情。例如，在我第一次测试的时候，我问自己:“*我如何确定测试做得很好，或者它会如我所愿地运行？*”而我的第一个想法是:“写测试！”，但显然这不是答案。

为你已经认为理所当然的事情编写测试是个坏主意。这方面的一个例子是为*GSON*(Google 用来解析 JSON 的著名 java 库)编写一个测试，并检查它是否成功解析了一个 JSON。这是一个坏主意，因为谷歌编写了这个库，显然他们已经为这个库的主要功能编写了一些测试，所以你只是在浪费时间为一个完善的库编写测试。相反，你可能想要的是为一些使用 *GSON* 的类/函数写一个测试，这是一个完全不同的情况，是一个有效的情况。

当我想写一个测试时，我会问自己这些问题:

> 我能控制这些代码吗？我能自由地修改它们吗？
> 
> 这段代码是不是别人可以在外部看到和使用的？

如果两个问题的答案都是肯定的，那么您可能需要对这段代码进行一些测试。

## 何时停止测试

有些情况不应该是测试的一部分。OOP 中的一个例子是拥有一个只代表数据的类，即在 *Java land* 中它将是一个 POJO(普通旧 Java 对象),在 *Kotlin land* 中它将是一个数据类，它有 getters 和 setters。为 getter 或 setter 编写测试是没有用的，**不应该成为测试的案例。测试**不应该**是关于数据本身，而是关于“这个数据会发生什么”，getter/setter 是直接关于数据会发生什么。**

其他申请*免试*的情况有: ***私用*** 。在 StackOverflow 这样的网站上，这也是一个真实的讨论。我个人的观点是，如果你有一个非常复杂的 ***私有函数*** 并且你觉得你需要对它进行测试，你可能需要把那个函数分割成更小的 ***私有函数*** ，然后检查它们是否真的需要私有或者它们是否需要测试。这在面向对象的世界里经常发生，甚至在脚本世界里也是如此，在那里开发者面对测试的需求，但是他们开始变得复杂起来。有很多方法(比如 Java 中的反射或者 android 中的`@VisibleForTesting`)可以让测试中应该是私有的东西变得可见。尽管如此，我还是建议避免这种测试，这种测试涉及到一些技巧和欺骗来获得一些用简单的方法可能得不到的东西。

## 你应该如何测试

几乎所有的语言都包含一些启用测试模式的方法，或者它们拥有由其他开发人员创建的工具来测试代码。即使是我这辈子用过的最糟糕的东西(Roku 的 BrightScript)也有办法测试你的代码。

在做测试的时候，你仍然需要记住一些事情:

*   **拥有一个封闭的环境**。我不想谈论复杂的事情(比如容器或者像 python 中的虚拟环境)。我所说的“*一个包含的环境*”是指有一种方法可以避免你的代码与它外部的资源通信。比如真正的数据库或者真正的网络服务。仍然有部分测试涉及到与这些外部资源的通信，但是即使如此，大部分环境应该被包含(或者被控制，无论你想怎么称呼它)
*   **想想最坏的情况**。是的，这是我们开始编写测试的主要原因。如果我的交换机有未列出的数据，会发生什么情况？空列表或空数组会发生什么？如果用户输入表情符号会发生什么？当用户不说英语而它写了一个非英语字符时会发生什么？文本的限制是什么？如果镜像服务器关闭会发生什么？等等。你应该总是首先想到不好的场景，并为它们编写测试。你会对编写这种测试的结果感到惊讶
*   **想想好的案例**。一旦你解决了坏场景中的所有问题，你的代码应该还能正常工作，如果不能，那么你应该再次修复代码以满足坏场景和好场景。记住，**抱最好的希望，做最坏的打算**
*   **想想别人会如何使用你的代码**。在编写测试时，考虑其他人将如何调用你的函数，他们将使用哪些数据进行调用，以及他们期望得到什么结果。试着在编写测试时记住这一点，就像真正调用你的代码，以及如果有人向你的函数发送错误的*参数*会发生什么。从两个角度考虑这个场景: ***其他开发者*** 和 ***最终用户*** 。最终用户是否总是一眼就能正确输入他的密码？当开发人员调用您`getProfile()`函数时，他们会首先理解您返回的复杂的`Response`对象吗？`Response`是那个职业的正确名字吗？这些只是你在编写测试时可能会遇到的事情的例子，当你试图弄清楚是否所有的事情都像预期的那样工作，或者你是否需要改变一些事情
*   将场景放入你的脑海。创建一个完整的用户场景，检查你的代码中涉及到了哪些部分，然后把这个场景写成一个测试，并验证所有的东西都像场景中描述的那样工作
*   不要害怕改变事物。在编写测试时，你会注意到，调用一个函数可能并不那么简单，你需要大量的数据来执行这个调用。好吧，按照你期望的那样，以一种“*快乐路径*”的方式编写测试，然后按照测试所说的那样重构代码。大多数时候，你最终会修改代码来通过测试，而不是相反。如果你在不修改代码的情况下通过了一个测试，很可能(很可能)你正在编写一个*假阳性*
*   不要过度思考你的测试。有一个最佳实践和复杂代码的时刻。编写测试不是那个时刻。测试应该直截了当地说明他们的意图。它应该是可读的，任何没有被测试代码背景的人都可以理解所述测试的意图

**更新**:你也可以给这篇牛逼的文章一个检查:

[![thejessleigh](img/f469a39e68e830438247062fe0064d78.png)](/thejessleigh) [## 解释了不同类型的测试

### Jess un rein 12 月 6 日 187 分钟阅读

#testing #beginners #explainlikeimfive](/thejessleigh/different-types-of-testing-explained-1ljo)

## 结论

测试和写代码一样复杂…因为测试也是写代码。如果你喜欢写代码，你也应该喜欢写测试，并验证你的代码如预期的那样工作。测试并没有那么难，但是需要时间和练习。最后，它就像编写常规代码一样简单，会教你更多关于你自己的代码，以及下一步该怎么做。

关于测试还有很多要说的，我将在以后的文章中写，并尝试用其他文章和例子的链接来更新这篇文章。

感谢阅读！