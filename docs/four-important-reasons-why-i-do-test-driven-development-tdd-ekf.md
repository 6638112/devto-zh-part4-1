# 我做测试驱动开发(TDD)的四个重要原因

> 原文：<https://dev.to/yuno_miyako/four-important-reasons-why-i-do-test-driven-development-tdd-ekf>

## 什么是测试驱动开发？

测试驱动开发是一种通过反复重复“测试= >实现= >重构”的过程来增长产品的开发方法。我会解释得更详细一点。重复接下来的三个步骤。

### 1。思考测试用例

思考测试用例与思考设计是一样的。您可以在您的测试用例中放入您希望这个对象拥有什么，它将如何被使用，以及您希望它返回什么结果。在这个阶段重要的不是考虑实现，而是考虑如何使用它。

### 2。履行

做一个最小的实现来通过测试用例。这个时候，你不应该想到抽象或者干净的代码，这是一个规则。只需实现第一阶段编写的测试。
极端来说，如果要通过测试`sum (1,1) => 2`，sum 方法实现可以是一个刚好返回 2 的方法。

### 3。重构

这是一个对实施阶段所犯罪行进行补偿的阶段。抽象可以抽象，可怕的变量名可以改正，复制的 pasta 应该是方法。这里的要点是一旦你修复了它就运行测试。重构程序时，确保所有测试都通过。这允许您重构代码，同时确保行为没有改变。

## 为什么要测试驱动开发？

这是一种非常奇怪的开发方法，所以第一次尝试的人很难理解你为什么要这么做。

然而，测试驱动开发是敏捷开发的基本风格，一旦你习惯了，你会宁愿想“为什么不测试驱动？”在这篇文章中，我想介绍我认为重要的四个原因。

### 1。可以制造出高质量的产品

我觉得这是最容易理解的。
由于测试实现是在编写测试之后进行的，所以测试驱动开发的测试覆盖率一般接近 100%(如果方法在重构过程中被裁剪掉，可能不会被测试)。更多的是，能够在测试编写阶段考虑错误也有助于提高质量。写测试也是一样要考虑使用的时间，这样会更容易想出使用时可能发生的边缘情况的想法，比如“如果这里的值是 null，我想让你返回一个错误”。因此，错误案例可能会在早期阶段被覆盖。

### 2。根据需要实现尽可能多的东西

实现阶段只考虑通过当前没有通过的测试，所以没有在测试用例中表达的规范不会被实现。如果你不写测试就开始实现，过度抽象是很常见的。经常想到以后可能会用到，就多加了一个功能，结果没用上。编写额外的特性不仅会降低代码的可读性，还会导致 bug。
实施太多不好，但当然太少(规范遗漏)也不好。如果规范可以在测试用例中很好地表达，那么实现端与测试是同步的，因此可以确认所有的规范都得到满足。理想的情况是写一个测试规范，而不是写一个规范文档。当测试本身就是规范时，诸如那些在规范文档中描述的但是没有实现的差距永远不会发生。

### 3。重构可以放心地完成

当所有测试都通过时，您就进行重构。每次你改变一段代码，立即运行测试，看看是否所有的测试都通过了。
这样可以放心地进行更改，因为已经进行了回归测试，以查看您所做的更改是否会影响其他部分。
这种信心推动了大胆的重构。

### 4。快速安全可靠的开发

通过反复采取这三个步骤，你可以缓慢而渐进地进行开发。
如果中途卡壳或者破坏了另一个测试，可以撤销，直到通过所有测试。
换句话说，测试变成了一个保存点。
短期发展还有其他好处。人类不善于思考事物。当你的老板突然说:“做这个产品！”，你突然被白编甩出来，你不知道从何下手，连第一步都迈不开。然而，如果你写了一个测试用例，并且只考虑实现它，认为“首先有这样一个规范”，你就可以向前迈一步。人类是一种可以通过减少问题并专注于它们而被创造出来的生物。一小步也意味着切出一个范围。

## 终于

我觉得结对编程的测试驱动开发也适合编程教育。一个老师编写测试用例，一个学习者实现它们，技术技能在重构阶段通过老师的指导得到提高。
专家可以调整测试用例的步幅，所以你可以着手调整难度。
此外，人们认为，在观看过程的同时提供教育反馈，而不是解决编程问题，是非常有教育意义的。对于编程来说，过程比结果更重要，我相信改进它会提高生产力。

再见！