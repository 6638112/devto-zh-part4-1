# 左转挑战

> 原文：<https://dev.to/kevinsarav/left-rotation-challenge-g5l>

今天我用 C++接受了 HackerRank 的数组部分的左旋转挑战。这个挑战让我思考了很久才完成。下面我来解释一下我的思考过程。

在开始这项任务之前，我的第一个想法是，如果我将数组中的每个值一个接一个地向左旋转，如果我遇到一个大数组的测试用例，可能会花费大量的时间。为了解决这个问题，我想做的是将每个值移动到它们的最终目的地，而不是一个接一个地移动到它们的最终目的地。

为了做到这一点，首先我考虑了递归。然而，递归被证明有点太难了，因为我有几个想要使用的变量，这些变量会在递归的迭代中以某种方式改变。

我的下一个想法是让一个 for 循环通过一个计数器。此计数器确保数组中的每个值都被旋转。我实例化了两个临时整数变量，它们将保存开头的值和目的地的值。一个 place 整型变量记录了我在数组中的位置。通过计数器 for 循环的迭代，我将从上一次迭代的地方开始工作。

我的第一个挑战是，当我想做的第一件事与之后的每一次迭代都不一样时，如何让它工作。为了解决这个问题，我做了一个 if 语句，说如果计数器变量等于零，意味着这是 for 循环的第一次迭代，那么我将使临时变量等于 place 的值，它应该是第一个索引处的值。我不需要编写 else 语句或者在 if 语句中添加任何额外的东西，因为我发现这是第一次迭代和之后每次迭代之间唯一的显著区别。

我已经知道如何轮换。我将从位置变量中减去 d 变量。如果 place 小于零，那么我将使 place 等于数组的大小减去 place 变量的值。

我的下一个挑战是找到如何交换。最初，我将原始位置的值与最终目的地的值进行了交换。然而，挑战在于，由于我的代码是如何完成的，最终目的地的值永远不会在先前的位置被再次访问，因此永远不会被放在它的最终目的地。只有位于最终目的地的值保持旋转。最重要的是，我从来没有存储我将在下一次迭代中旋转的值。为了解决这个问题，我没有交换，而是像前面提到的那样将变量存储在第二个临时变量中，并且没有对先前位置的值做任何事情。我只专注于改变新地方的价值。

我的下一个挑战是找出如何处理其中一个测试用例。一个测试用例是 10 次左旋转，数组大小为 20。问题是我的 for 循环只改变了第一个位置，最后一个位置和中间位置的值，因为在两次 10°左转后，我又回到了原点。为了解决这个问题，我创建了一个原点变量来跟踪我的 for 循环是否回到了原点。我做了一个 if 语句，说 if place 等于 origin，counter 不等于数组大小减 1，或者最后一次迭代，然后给 place 和 origin 加 1，让临时变量等于新位置的值。我把它放在 for 循环的末尾，这样首先 for 循环中的步骤将被完成，然后我提到的变量将在下一次迭代中被改变。

我希望在未来的帖子中更多地讨论其他具有挑战性的 HackerRank 挑战。我将使用 C++来应对实习准备中的挑战。