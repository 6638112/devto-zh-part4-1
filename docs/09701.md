# 将新的 CSS 技术引入生产

> 原文：<https://dev.to/ash/bringing-new-css-techniques-to-production-1lfn>

嗨，Dev.to 社区。我在这里潜伏了一段时间，但还没有发布任何东西🙂。从森林时代开始，我就想找到一个这样的社区！大约一个月前，我为 Si digital blog 写了一篇关于 CSS 新技术的文章。这是[那篇文章](https://sidigital.co/blog/bringing-new-css-techniques-to-production)的交叉贴。

* * *

如果你和我一样，当你第一次意识到 CSS 网格和自定义属性是浏览器开发者*正在努力实现的*真正的*特性时，你会兴奋得头晕目眩。如果你不熟悉前端开发，这些话可能根本不会给你带来多少乐趣。也许他们甚至会打哈欠。让我解释一下...*

我们——制作网站的人——在过去十年的大部分时间里一直在设计和建造响应迅速的网站。响应式网站被设计成在我们可以合理预期用来浏览网页的任何显示尺寸下都可以访问。这可能是任何东西，从最小的手机，甚至是手表，到大型桌面显示器。我们必须采取的部分心态是，我们并不真正知道我们的访问者将使用什么设备。今天，你很难找到一个没有响应的网站。事实上，响应式网站无处不在，以至于你可能没有注意到有些网站*没有响应。*

有了响应式网页设计，制作网站的过程变得更加复杂。我们曾经可能会欺骗，在一个单一的显示尺寸上建立一个网站，我们开始抛弃我们对网站访问方式的假设。我们的关注点从精度和像素完美转移到*流畅性*(布局自然伸展以填充可用空间)和*适应性*(布局在特定尺寸下变化，或*断点*，以最大限度地利用可用空间)。构建单视窗网站从来都不是一个好主意——毕竟网络天生就是灵活的——但它被广泛实践，甚至在某些情况下是实现日益雄心勃勃的视觉设计所必需的。

## 适应显示尺寸*和*浏览器功能

很快，网页设计者和开发者开始接受响应式网页设计作为一种方式。尽管有合理的理论支持，但实现响应式网站的挑战并不总是容易应对的。web 开发人员和不完整或不一致的浏览器功能之间的斗争是一个和时间一样古老的故事——或者至少和我在这个领域的职业生涯一样古老。当构建 web 时，我们不仅要考虑正在使用的多种设备外形和尺寸，还要考虑各种各样的浏览器功能。

> 正如我们必须承认网络是无边界的——没有单一的显示尺寸可供我们选择——我们也必须承认我们无法控制网站的访问方式。这是我们正在构建的媒体的一个基本特征。

就 CSS 支持而言，最广泛使用的移动浏览器通常比 IE 更完整，并且更快地采用新功能。有时候，我会觉得我必须在两个选项中做出选择，来限制我正在做的项目:

1.  我应该为移动设备和现代网络浏览器提供卓越的、经得起未来考验的、响应迅速的体验，还是
2.  我是否应该为 IE 提供一种增强的体验，这种体验对于移动设备和现代浏览器来说是可以接受的，但却被时间冻结了。

答案通常介于这两个选项之间。我们为所有 web 浏览器创建了一个坚实的基线体验，我们可以在此基础上为更高级的浏览器添加增强功能。这种技术被称为*渐进式增强*，由于 CSS 的工作方式，它相当优雅，并且是前端 web 开发的关键原则。正如我们必须承认网络是*无边缘的*——没有单一的显示尺寸可供我们选择——我们也必须承认我们无法控制网站将如何被访问。这是我们正在构建的媒体的一个基本特征。浏览器功能、设备 CPU 能力和网络状况都超出了我们的控制范围。

从技术上讲，CSS 中的渐进式增强相当简单。Web 浏览器会忽略它们无法识别的声明，所以只要我们在使用并非所有地方都支持的属性或值时指定一个后备声明，我们就可以提供逐渐增强的体验。

这里有一个例子，展示了我们如何逐步使用自定义属性，同时仍然为功能较弱的 web 浏览器提供功能体验:

```
:root {
  --spacing: 1rem;
}

.jumbotron {
  padding: 1rem;
  padding: var(--spacing);
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

<small>支持定制属性的 Web 浏览器将使用动态的`--spacing`变量，这非常有用，因为我们可以在运行时改变它(例如，在响应当前视窗大小的媒体查询中)。能力较弱的浏览器将退回到常量值`1rem`。</small>

CSS 还提供了*特性查询*，这有点像媒体查询，但允许我们测试浏览器功能，而不是视觉属性，如视窗大小。当我们要应用更复杂的样式组时，特征查询非常有用。举个例子，如果我们用 CSS 网格排版:

```
@supports (display: grid) {
  .product-group {
    display: grid;
    margin: 1rem;
    grid-gap: 1rem;
    grid-template-columns: repeat(3, 1fr);
  }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

一个例子，展示了我们如何为支持 CSS 网格的网络浏览器应用一个样式集合。

## 管理回退方式

尽管渐进式改进在技术上很容易实现，但我们仍然必须仔细考虑如何应用它。我的目标是尽可能简单的基线体验；例如，布局可能只占据一列。内容将根据它在 HTML 中出现的顺序线性呈现，一些视觉效果可能不会出现。网站*应该*在这种形式下完全无障碍。如果所有这些都失败了，CSS 和 JS 也不起作用了，访问者仍然可以利用语义 HTML 来形成前端的框架。帮助访问者的辅助技术依赖于语义 HTML 的存在，所以这是非常重要的。

正如我们在开发过程中面临的许多问题一样，在决定使用哪些技术和备用技术之前，我们必须考虑谁将使用我们的网站。在许多情况下，利用现代技术加上简单的后备措施是可以接受的。在其他情况下，很大一部分观众可能在使用功能较弱的浏览器。在这种情况下，最好使用旧的技术来提供增强的体验。查阅你的网站统计数据，以确定你的时间在哪里投入最大。

无论是哪种情况，在 CSS 中创建许多复杂的*分支*都是非常重要的。每次回退都有维护成本。有时候，我们可能很想将整个布局分叉，这样我们就可以在所有的 web 浏览器中交付对预期布局的一些评估。我认为重要的是尽可能避免这种情况；仅这种方法的维护成本就可能很高。有一个完整的不同设备和浏览器的马赛克将被用来访问一个网站，自然可能会有一些不同的网站出现的方式。

## 新增前端基线

浏览器厂商发布更新的速度比以往任何时候都快。IE 的使用正在稳步减少，微软的下一代网络浏览器将是常青树:持续自动更新。也许再过短短几年，我们就能推出直接针对现代网络浏览器的网站了。对于一些项目来说，这甚至是今天的现实。随着浏览器的改进，我们可以慢慢地从我们的军火库中剥离回退。当然，总会有不同支持的新技术，但是我们即将建立一个新的技术基线集合，它将在大多数 web 浏览器中可用。这些技术(如网格、自定义属性、Flexbox 和 Calc)代表了我们构建网站方式的显著变化。它们使 web 开发人员能够用比以往更少的代码创建更健壮、视觉效果更好的网站，这些网站可以在不同的显示尺寸之间平滑缩放。

在这篇文章中，我想特别提醒大家注意 CSS 的两个新特性:网格和自定义属性。这些功能非常令人兴奋，因为它们最终为我们制作响应式网站以来一直存在的巨大挑战提供了答案。

对于新手来说，Grid、Flexbox 等为 web 开发提供了一个简单得多的切入点。许多开发人员积累了十年或更长时间的网络平台琐事很难解释。在处理堆栈溢出答案和令人沮丧的 IE 测试会话时，我们已经慢慢获得了大量的知识。我发现很多这种琐事甚至对我自己来说都很难解释清楚。能够直接钻研新技术确实使前端开发变得更加容易。

## 网格

当我在 2000 年中期开始制作网站时，CSS 网格的概念对我来说几乎是不可想象的。我们只有几种技术可用于水平组合内容:即， *Floats* 。到 2000 年末，表格显示已经广泛使用，这为布局提供了一些有趣的技术，但感觉不太适合 web。在响应式网页设计的世界里，我们的手似乎被有限的可用功能所束缚。

实现响应式布局？选择一个断点，添加一些浮点。如果一个网格有不同的列数、间距和项目的垂直对齐方式呢？使用`inline-block`或表格显示结合负边距是可能的，但有点危险。

如果你曾经不得不清除一个浮动，键入`display: table`，或者使用*假列*，你可能会同意 CSS 网格感觉像魔术一样。我们被赋予了难以置信的力量来控制 CSS 布局的几乎每一个方面。在断点之间，我们可以根据需要重新排序*和重新绘制*组件。

2011 年， [Trent Walton 写了关于*内容编排*](https://trentwalton.com/2011/07/14/content-choreography/) ，以及我们如何在各种显示尺寸下*交叉*内容。但当时，没有清晰的技术路线来干净地实现这一点。如果你读过 Scott Jehl 的*responsible responsive design*，或者熟悉 Filament Group 的工作，你可能知道 [*‌AppendAround* 模式](https://github.com/filamentgroup/AppendAround)。这种模式与一个小的 JavaScript 实用程序相结合，使开发人员能够在给定的断点处移动页面内容。

我不能说 *AppendAround* 是否被广泛采用，但我个人发现它很难使用。此外，它将布局责任委托给 JavaScript，这通常被认为是一个坏主意。但是它所实现的对许多网站来说是必要的:交叉*组件的能力，这在当时需要 HTML 标记在页面上移动 <sup>2</sup> 。*

CSS 网格给了我们对布局难以置信的控制。对比 Trent 的文章和 Thoughbot 的 2018 年文章 [*‌Concise 媒体用 CSS 网格*](https://thoughtbot.com/blog/concise-media-queries-with-css-grid) 查询，看看 Web 平台进步了多少。CSS Grid 使一整类极其灵活的布局在 web 上很容易实现。现在我们可以单独使用 CSS 重新排序组件；我们实际上有一个很好的方法来实现看似微不足道的布局变化。我们不仅可以实现更有雄心的视觉设计，我们发现我们的布局更健壮，HTML 更干净，需要的代码更少。

有趣的是，网格还提出了统一的概念，允许设计人员和开发人员更有效地交流。网格对 web 来说并不陌生；它们早就被模仿了(例如，960 网格系统从我记事起就存在了)。然而，CSS 网格的存在意味着我们拥有了一个完全流动的、web 原生的网格系统的能力——不需要与[*web 的纹理*](https://frankchimero.com/writing/the-webs-grain/) 对抗。

### 后退为 CSS 网格

这么多好处，想不被 CSS 网格诱惑都难。很快，我怀疑它将成为在 web 上创建布局的事实上的技术，所以不管你是否选择在生产中使用它，学习它都是很重要的。在 Si digital，我们已经开始尽可能地在网站中加入 CSS 网格。

没有什么神奇的方法可以让网格布局在不受支持的浏览器上工作。它的功能不能简单地改进以适应旧的布局技术，所以通常我们为不支持网格的 web 浏览器提供一个更简单的选择。有时，可以提供一个带有浮动、表格显示或`inline-block`的替代方案。我非常谨慎地在 CSS 中创建复杂的分支来强迫一个布局在任何地方看起来都一样。你的技术选择应该由你网站的使用统计来指导。如果您需要为能力较弱的 web 浏览器提供增强的体验，那么现在最好不要使用网格。

对于最新版本的 IE，Autoprefixer 确实有能力将网格声明转换成等价的`-ms-grid`属性。不幸的是，Grid 的 IE 实现并不符合当前的规范，所以它远非板上钉钉。根据我的经验，Autoprefixer 对于少量简单的网格布局工作得很好。使用特征查询可以更好地处理大多数问题。

## 自定义属性

CSS 自定义属性是另一个让我再次爱上前端 web 开发的特性。如果您使用过 CSS 预处理器(比如 Stylus 或 Sass)，您可能会失望地意识到无法在媒体查询中更新变量。这是因为变量只在构建时存在，此时预处理器将静态值插入到输出 CSS 中。*自定义属性*不仅给原生 CSS 带来了变量的便利，还允许变量在运行时更新。

媒体查询现在能够更新样式表中使用的变量，回答了许多关于我们应该如何在一个响应迅速的世界中构建 CSS 的问题。排版，布局，甚至配色方案现在可以在一个单一的位置修改，以回应媒体的询问，我们以前会在我们的 CSS 中穿插。

我发现将 spacing 之类的值移动到自定义属性非常有效，这使得在许多显示尺寸上保持组件的间距和位置一致变得非常简单。很长一段时间以来，我一直在用 CSS 预处理器 mixins 来实现这一点，但是如果不创建非常臃肿的 CSS 输出，这是不可能的。既然自定义属性已经广泛可用，我们已经开始在生产中使用它们。

### 后退为 CSS 自定义属性

当讨论自定义属性的回退时，我们可能会提到几个场景:

1.  变量未定义。
2.  web 浏览器不支持自定义属性。

在这里，我们最关心的是浏览器支持。不存在的变量可以通过回退到`var()`函数来[寻址。然而，浏览器回退需要更多的思考…](https://developer.mozilla.org/en-US/docs/Web/CSS/var)

从技术上讲，回退很容易创建。Web 浏览器跳过它们不识别的 CSS 声明。我们只需提供一个*常量值*供功能较弱的浏览器使用。要做到这一点，我们必须做一些假设。例如，如果一个自定义属性处理响应式布局，我们可以选择一个桌面适用的常量来返回。我们瞄准的大多数移动浏览器都支持自定义属性，但 IE——一个桌面浏览器——不支持。这样做的代价是，无论用户的浏览器窗口有多大，一些响应风格对他们来说都是不可用的。在我们安全地选择退路之前，检查网站的使用情况是很重要的。

```
:root {
  --spacing: 1rem;
}

@media (min-width: 60em) {
  :root {
    --spacing: 2rem;
  }
}

.main-content {
  padding: 2rem;
  padding: var(--spacing);
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

<small>显示自定义属性回退的示例。对于不支持这个特性的浏览器(通常是桌面 web 浏览器)，我们回退到最大值`2rem`。</small>

#### 改善工作流程

开发人员经常发现自己在想“我能自动化这个吗？有没有好的抽象？”。请注意，抽象通常比它们实际解决的问题更加复杂和脆弱:通常代码会重复。但是我不禁想知道预处理器混合是否可以用来简化我们对自定义属性的使用。

我通过创建一个手写笔 mixin 来进行试验，它同时创建自定义属性消费者和回退声明。它在假设存在与自定义属性同名的*手写笔*变量的情况下工作。

```
customProp($propName, $varName)
  {$propName} lookup('$' + $varName)
  {$propName} s('var(--' + $varName + ')') 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

我们来看看正在使用的 mixin:

```
// Firstly, we set our Stylus variable that will be used as a fallback.
$spacing = 2rem

// We define our Custom Property in the usual way.
:root {
    --spacing: 1rem;
}

@media (min-width: 62em) {
  :root {
    --spacing: $spacing;
  }
}

// When creating a declaration that references a Custom Property, we use the customProp mixin.
body {
  customProp('padding', 'spacing')
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

虽然**我不认为我会推荐这种方法**，但是探索改进我们工作流程的方法是很有趣的。我越来越倾向于认为我们应该减少 CSS 预处理程序的使用。重复声明允许我们明确地进行回退，并且重要的是，阻止我们构建一个深奥的预处理代码层，使我们的样式表难以推理。

在普通 CSS 中提供后备相对容易，这意味着我们现在经常能够将自定义属性用于生产。它们是一种非常强大的方式来设计网站，这在目前来说是不可能的。

## 全面拥抱*新基线*

想象一下当我们可以完全投入 CSS 网格和自定义属性时会发生什么是非常令人兴奋的。这一现实可能只需要 1-2 年的时间。使用 Grid 来控制大部分布局，而不用担心回退，这不仅有助于使代码更易维护，而且使一个全新的布局类别有可能简单地实现。Jen Simmons 的 [*实验布局实验室*](https://labs.jensimmons.com) 是对现在可能实现的网络布局类型的精彩一瞥。

Subgrid 有望在不久的将来出现，并将为 CSS 带来更大的力量。在我的网络愿望清单上最重要的一项是*容器查询*:响应组件的实际大小，而不是整个显示大小的能力。在此之前，响应式设计仍然是一个挑战。

为一个庞大的、不可控的、灵活的媒体设计的许多方面保持不变，但是网络的纹理继续变化。近年来，我们看到了令人兴奋的新能力，这些能力超出了我开始建设网站时的想象。他们改变了网络设计和构建的含义。我迫不及待地想看到视觉设计和技术实现的进步，因为更多的人可以获得这些能力。

* * *

<sup>1。</sup>的确，并非所有手机浏览器都符合这一描述(比如 Opera Mini)。不管是好是坏，我很少不得不迎合这样的浏览器。不要忘记，许多移动设备的功率极其有限。

<sup>2。</sup>表格显示确实给我们带来了一些有限的重新排序能力。参见科林托[*CSS 布局的反英雄——《显示器:桌子》*](https://colintoh.com/blog/display-table-anti-hero) 。Colin 总结道“我必须强调 CSS 表格不是布局的灵丹妙药”。看看 2014 年可能实现的目标还是很不错的。