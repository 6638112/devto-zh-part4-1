# 撕裂 Vitcord 后端

> 原文:[https://dev.to/vitcord/tearing-vitcord-backend-46m8](https://dev.to/vitcord/tearing-vitcord-backend-46m8)

## [](#what-is-vitcord-what-do-we%C2%A0do)什么是 Vitcord？我们该怎么办？

Vitcord 是一家成立于 4 年前的西班牙巴伦西亚的初创公司。

我们试图让视频故事更有价值。人们分享视频是因为他们希望他们的朋友分享他们的经历:分享他们的心情，看到他们所在的特殊地方或他们正在享受的事件。有了 Vitcord，你可以在一个全新的水平上参与视频，不仅是和你的朋友，也和那些和你有着同样爱好的人。这是一个面向视频创作者的开放空间，你可以开始用视频讲述故事，世界各地的人都可以加入你的故事。

[![Vitcord](../Images/45009b309894485f6bf786a3ec039778.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--SHfh5WeW--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/bd441luy8tswdmd2tr30.jpeg)

## [](#our-monolitic-api)我们的 Monolitic API

当我们开始开发 Vitcord 的后端 API 时，我们无法想象我们会考虑采用微服务方法。现在，我们的 API 管理着用 **Ruby (Ruby on Rails)** 编写的 4 个主要服务:

*   **社交网络服务**(创建新账户、关注其他用户、管理我们的个人资料等)
*   **上传和处理文件**(上传新视频、存储视频、管理缩略图等)
*   **管理通知**(推送通知、通知列表等)
*   **视频线程**(创建新的视频线程，管理线程等)

我们认为将所有服务整合到一个 API 中并使用 Rails 作为我们的主要语言是一个很好的方法，因为我们是几个开发人员，在那一刻我们需要尽快构建一个 MVP，以开始验证我们的项目是否有意义。

现在我们已经验证了这一点，并且随着用户群的增长，我们的整体 API 已经达到了极限，所以我们决定像 6 个月前一样开始迁移到微服务架构的过程，用第一个“服务”来管理应用程序中的通知。

## [](#extracting-notifications-to-a-service-why)提取通知给一个服务，为什么？

首先，我们是一个基于用户之间互动的**社交网络**，所以你可能会猜测我们需要一个工具来让我们的用户保持清醒，并了解我们应用程序中发生的事件，所以我们有很多动作最终会以存储在 DB 中的**通知**和发送到其他设备的**推送通知**(或推送通知池)结束。正如您可能想象的那样，我们在 DB 中最大的项目集合是通知，而且比我们第二大的集合大 10 倍。代码执行也是如此，几乎 70%的时间我们都在管理某种逻辑，它负责在 DB +中创建新的通知，告诉 Firebase 发送新的推送通知。

所以，你不觉得是时候把这些任务分开了吗？我们有同样的想法，所以我们开始维护两个大模块:

*   一个管理社交网络+视频管理(文件上传，线程管理等)
*   又一个管理通知+推送通知的

这意味着每次我们做出新的改变，通常我们必须改变与第一个模块相关的东西和与第二个模块相关的东西。这很奇怪，因为我们通常想要添加功能或者只是改变附加到第一个模块的代码，但是随着我们的通知模块不断增长，它正在污染我们的完整代码库。最后，我们鼓励自己开始构建我们的第一个**微服务**。

## [](#dynamodb-over-cassandra-and-kotlin-over-elixir)DynamoDB 战胜了 Cassandra，Kotlin 战胜了仙丹

当我们开始阅读构建通知服务的技术时，我们清楚了两件事:

*   它需要管理每秒的**个请求(因为在 Vitcord 中我们有很多事务通知)**
*   **每秒存储数百万条记录**(因为每个交易通知都必须保存，以便用户能够显示其通知历史)

考虑到这一点，我们开始考虑构建它的几种语言(Kotlin 和 Elixir)和几种数据库技术(Cassandra 和 DynamoDB)。

很明显， **Elixir** 可能是构建通知服务的完美候选，因为它利用了 Erlang VM，这意味着它在执行时管理轻量级线程，因此具有很好的可伸缩性，并且据说 Elixir 是 Rails 的自然发展(从语法角度来看，也是由于 Rails 的 Phoenix 可能性)。所以，你可能会问**为什么你选择科特林而不是长生不老药？**答案在于团队中没有人知道 Elixir，我们希望快速构建服务，所以我们从后端团队和 Android 团队各选了一个人(他们用 Kotlin 构建应用程序),然后我们用 Kotlin + Spring 开始开发。最后，Kotlin 对我们来说是有意义的，因为它有协程(轻量级线程),可以满足我们管理数百万个请求的高可伸缩性需求。

对 DB 也采取了同样的决定。您可能知道， **Cassandra** 是基于可伸缩性和高可用性(具有出色的性能)而构建的，因此它像灵丹妙药一样适合我们的需求。当我们开始开发时，我们在考虑如何用一个 **Kubernetes** 集群管理 Cassandra 节点。我们阅读了很多关于如何管理 Kubernetes 的内容(我们的团队中没有专门负责 DevOps 的人)，最后我们讨论了我们自己管理和维护一个 Kubernetes 集群需要多长时间，所以我们决定使用 **DynamoDB** (它与 Cassandra 非常相似，但优点是不需要管理实例或集群，因为它是由 Amazon 管理的)，并承诺有一天会回到 Cassandra。

## [](#next-steps)下一步

我们对自己的决定很满意，比如现在 DynamoDB 正好满足了我们通知服务的需求，我们把管理工作交给了 Amazon(我们知道最终我们会因为 Dynamo 而面临巨额费用，但我们会准备好将 DB 迁移到 Apache Cassandra ), kot Lin 工作得非常出色。

现在，我们正在讨论如何将通知与我们的单片 API 完全分离，因为现在它是通知服务的认证入口，但当然我们希望保持每个微服务彼此完全分离。

这些是我们接下来的步骤:

*   构建一个 **API 网关**，通过认证服务管理路由和认证，作为我们微服务的入口点
*   添加一个**事件队列**到我们的 infraestructure(我们正在考虑 RabbitMQ 或 Apache Kafka)来交流微服务动作
*   将通知从单一 API 中完全分离出来
*   添加新的微服务(可能是管理视频和文件的微服务)

我们将在下一篇文章中介绍更多我们的进展。

敬请期待！！