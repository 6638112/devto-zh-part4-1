# 关于在 iOS 13 中处理后台任务的所有信息

> 原文：<https://dev.to/tejeshwargill/all-about-handling-background-tasks-in-ios-13-4gc0>

UIApplication 后台任务机制允许你防止你的应用短时间暂停。虽然所涉及的 API 非常小，但仍然有许多事情需要注意:

后台任务这个名称有些不恰当。具体来说，beginBackgroundTask(expiration handler:)实际上并不启动任何类型的后台任务，而是告诉系统你已经开始了一些正在进行的工作，即使你的应用程序在后台，你也希望继续。您仍然需要编写代码来创建和管理这项工作。所以最好把后台任务 API 想象成提出一个“不要挂起我”的断言。

您必须结束开始的每个后台任务。不这样做将导致您的应用程序被看门狗杀死。因此，我建议您为启动的每个后台任务附加一个名称(通过调用 beginBackgroundTask(with name:expiration handler:)，而不是 beginBackgroundTask(expiration handler:))。当事情出错时，一个好的名字对于追踪问题是至关重要的。
警告无法结束后台任务是 iOS 上后台任务问题的头号原因。这通常涉及簿记中一些容易忽略的错误，导致应用程序开始后台任务，而不是结束它。例如，您可能有一个存储当前后台任务标识符(UIBackgroundTaskIdentifier 类型)的属性。如果您不小心创建了第二个后台任务，并将其存储在该属性中，而没有对当前存储在该属性中的标识符调用 endBackgroundTask，应用程序将会“泄漏”一个后台任务，这将导致它被看门狗杀死。

后台任务可以以两种方式结束:
a .当你的应用程序完成了它设定的任务。
b .当系统调用任务的到期处理程序时。

在这两种情况下，您的代码都负责调用 endBackgroundTask(_:)。所有后台任务都必须有一个到期处理程序，系统可以用它来“调入”任务。后台任务 API 允许系统在任何时候这样做。

你的到期处理器是你清理东西的机会。在所有东西都被真正清理干净之前，它不应该返回。它必须运行得很快，也就是说，不到一秒钟左右。如果时间太长，你的 app 就会被看门狗杀死。在主线程上调用到期处理程序。

在任何线程上开始和结束后台任务都是合法的，但从辅助线程上这样做可能会很棘手，因为您必须用到期处理程序来协调这项工作，该处理程序总是在主线程上调用。

系统对使用后台任务防止暂停的总时间有严格的限制。iOS 13 测试版将前台值减少到了 30 秒。在目前的系统上，你可以期待这样的值:
a. 3 分钟，当你的应用程序从前台移动到后台
b. 30 秒，当你的应用程序在后台恢复
警告:我引用这些数字只是为了给你一个大概的概念。目标值在过去已经发生了变化，将来也很可能发生变化，而您实际获得的时间取决于系统的状态。这里要记住的是，只要您的后台任务有一个有效的到期处理程序，确切的值并不重要。

您可以通过查看 UIApplication 的 backgroundTimeRemaining 属性来粗略估计您可用的时间。
重要提示:backgroundTimeRemaining 返回的值是一个估计值，可以随时更改。无论返回值是什么，您都必须将应用程序设计为正常运行。使用此属性进行调试是合理的，但我们强烈建议您避免将用作应用程序逻辑的一部分。
警告:基于 backgroundTimeRemaining 返回值的应用行为是 iOS 上后台任务问题的第二大原因。

系统不保证任何后台任务执行时间。您可能无法创建后台任务(尽管可能性不大，在下一点中会提到)。即使您设法创建了一个，也可以随时调用它的到期处理程序。

beginBackgroundTask(expiration handler:)可能会失败，返回 UIBackgroundTaskInvalid，以指示您系统无法创建后台任务。虽然这在后台任务首次引入时是一种真实的可能性，当时一些设备不支持多任务处理，但你不太可能在现代系统中看到这种情况。

后台时间“时钟”只有在后台任务生效时才开始滴答作响。例如，如果您在应用程序处于前台时启动后台任务，然后停留在前台，后台任务将保持休眠状态，直到您的应用程序移至后台。这有助于简化后台任务跟踪逻辑。

你获得的后台执行时间是你的应用的属性，而不是后台任务本身的属性。例如，连续启动两个后台任务不会给你 6 分钟的后台执行时间。

尽管有前面的观点，创建多个后台任务仍然是有意义的，只是为了帮助您的跟踪逻辑。例如，通常为应用程序正在完成的每个任务创建一个后台任务，在任务完成时结束任务。

不要创建太多的后台任务。多少才算多？创建几十个后台任务是绝对没问题的，但是创建几千个并不是一个好主意。
重要提示:iOS 11 引入了一个进程可以拥有的后台任务断言数量的硬性限制(目前约为 1000 个，但具体数值可能会在未来发生变化)。如果您看到异常代码为 0xbada5e47 的崩溃报告，那么您已经达到了这个极限。
注意:这里最有可能看到的实际限制是调用到期处理程序所花费的时间。watchdog 对运行后台任务到期处理程序所用的总时间有严格的限制(几秒钟)。如果您有数千个处理程序，您很可能会遇到这个限制。

如果您在无权访问 UIApplication(一个应用程序扩展或 watchOS)的环境中工作，您可以使用 performExpiringActivity(with reason:using:)获得类似的效果。如果你的应用程序“泄露”了一个后台任务，它可能会被看门狗杀死。这会导致崩溃报告，异常代码为 0x8badf00d(“吃了变质的食物”)。
重要提示:泄漏的后台任务并不是 0x8badf00d 崩溃的唯一原因。您应该查看主线程的回溯，看看主线程是否卡在您的代码中，例如，在同步网络请求中。然而，如果主线程在 run 循环中被愉快地阻塞，那么泄漏的后台任务应该是您的主要怀疑对象。

在 iOS 11 之前，任何未完成的后台任务的信息都会出现在生成的崩溃报告中(查找文本 BKProcessAssertion)。iOS 11 及更高版本不包含此信息，但您可以在系统日志中找到等效的信息。

您可以使用 macOS 上的控制台应用程序以交互方式监控设备的系统日志。系统日志也包含在 sysdiagnose 日志中，因此，如果您有只在现场显示的问题，您可以要求用户发送给您。有关系统诊断日志的更多信息，请参见
错误报告>概要文件和日志页面。

系统日志非常嘈杂，所以给每个后台任务取一个容易找到的名字很重要。

在后台启动的任务的时间限制要短得多。虽然确切的限制没有被记录下来——它在过去已经发生了变化，并且很可能在将来再次发生变化——但是如上所述，当前的值大约是 30 秒。事情是这样的:

系统会在后台恢复(或重新启动)您的应用程序，因为用户进入了您所在的地区。

你安排了一个 3 分钟的计时器，并启动了一个后台任务来防止应用程序被挂起。
30 秒后，后台任务到期。此时会发生两种情况之一:
a .如果你有一个到期处理程序，它将被调用。它必须结束后台任务，此时你的应用程序将暂停(A)。
b .如果你没有到期处理程序，或者没有及时结束后台任务，看门狗会杀死你的 app (B)。
这意味着定时器在 3 分钟后不会运行。要么你的应用被暂停(这将阻止计时器运行)，要么你的应用被终止。
这种状态一直持续到用户离开你所在的地区。此时会发生两种情况之一:
a .在情况 A 中，系统会在后台恢复你的应用程序。你的计时器早就该启动了，所以现在就启动。
b .情况 B，系统会在后台重新启动你的 app。由于这是一个新过程，计时器不再存在。
重要提示:如果你想测试这个，确保从主屏幕而不是 Xcode 运行你的应用。Xcode 调试器会停用看门狗，防止您的应用程序挂起，等等。

务必阅读并分享！！