# 破损数组协方差

> 原文:[https://dev.to/vijesh_salian/broken-array-covariance-46p4](https://dev.to/vijesh_salian/broken-array-covariance-46p4)

*数组协方差坏了？*没错！

我在这里展示的代码例子适用于 C#也适用于 Java，因为我认为 Java 是第一个做出(break？)这个。C#不得不在自己的语言中做同样的事情。

方差(协方差，逆变，不变性)是一个很难解释的话题。但无论如何我都要试试。

当设计一种带有类型的语言时，设计者必须设置一些关于类型及其相关类型如何替换的规则。任何处理类型的操作都要遵守这些规则。运算可以是协变的、逆变的或不变的。注意，操作不仅仅是一个函数/方法，也可以是一个赋值。

考虑这些类。`Small`和`Little`都是`Big`的子类。

```
public class Big
{
}

public class Small : Big
{
}

public class Little : Big
{
} 
```

如果我可以将一个`Small`类型赋给一个`Big`类型，那么这个赋值操作对于这些类型是协变的。

```
Big a = new Small();
Big b = new Little(); 
```

对于上述操作来说，情况正好相反。逆变是协方差的逆。协变感觉比逆变更直观。赋值操作与这些类型并不矛盾。如果你试图这样做，编译器会警告你，因为变化的规则是明确定义的。

```
Small s = new Big(); 
```

这些是非常简单的例子。如果你想让我在另一篇文章中详细讨论这个话题，请在评论中告诉我。

在这篇文章中，我将只谈论破碎的数组协方差。

语言设计者决定让数组协变。下面的代码是完全可以编译的。

```
Big[] bigArray = new Small[10]; 
```

上述赋值操作是合法的，因为它遵守方差规则。

现在考虑下面的代码。我们使用前面代码中定义的`bigArray`。这个代码也完全合法。因为一个`Small`对象可以赋给一个`Big`类型。它满足协方差规则。

```
bigArray[0] = new Small(); 
```

`Little`赋给`Big`也遵循协方差规则。

```
bigArray[1] = new Little(); 
```

这就是问题所在。上面的代码仍然是完全有效的代码。可怜的编译器不知道运行时不同意。

如果你运行这个程序，它会以一个试图将`Little`赋值给`Big`的异常结束。这就是数组协方差被破坏的原因。问题是，即使类型是`Big`，底层存储也是`Small`。`Small`和`Little`不可相互替代。

语言设计者能避免这个问题吗？可能是。让我们创建`List`而不是数组。

```
List<Big> bigs = new List<Small>(); 
```

上面的代码无法编译。为了保证类型的安全，编译器完全避免了这个问题。

如果您正在使用具有相关类型的数组，在将对象插入数组之前，请先检查其类型以避免运行时错误。下一次当你用数组检查代码的时候，记住数组协方差是坏的！

希望你对此感兴趣。感谢您的关注。

干杯🍺