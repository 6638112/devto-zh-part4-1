# VueJS 生态系统(超级)快速指南——从高级 Java 开发人员的角度

> 原文:[https://dev . to/lilianaziolek/a-super-quick-guide-to-vuejs-ecosystem-from-senior-Java-dev-point-of-view-1k mo](https://dev.to/lilianaziolek/a-super-quick-guide-to-vuejs-ecosystem-from-senior-java-dev-point-of-view-1kmo)

# [](#javascript-ecosystem-in-a-nutshell)概括地说 JavaScript 生态系统

2016 年底或 2017 年初，我看到了这篇[博文](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f)。这是我开始考虑建造 [OSBO](https://www.onestopbeauty.online) 的时候，我知道这将涉及到最终离开我在整个航母上愉快地占据的 Java/后端堡垒，并且至少在某种程度上进入“敌人的领地”。这篇博文很有趣，但在某种程度上也很吓人。它证实了我对它会是什么样子的所有担忧——必须做任何前端工作。这听起来简直太疯狂了。

现在，2.5 年过去了，在许多行 Vue 代码之后，我想让前端世界对像我这样的人(当时)来说不那么可怕。有能力的/资深的 Java 开发人员，由于这个或其他原因(选择或环境)，他们没有太多做前端工作的经验，并且不确定从哪里开始。

# [](#java-ecosystem-in-a-nutshell)概括地说 Java 生态系统

当你停下来想一想的时候，一旦涉及到 HelloWorld 之外的任何东西，Java world 也不仅仅是 Java。我曾经指导过一些初级开发人员，最近我对他们必须面对的陡峭的学习曲线感到有点遗憾。如果你最近加入了一个现代项目，从第一天开始，你可能会遇到以下几个名字(排名不分先后):

Maven/grad le；春天，春天的 JDBC，春天的 MVC，Spring Boot，春天的云，春天……；冬眠；龙目岛，番石榴，阿帕奇公地；杰克逊、GSON、Jaxb 火花；骆驼；JMSTomcat，Jetty，Netty 尤里卡、海斯特里克斯、丝带；JUnit，Mockito，AssertJ，黄瓜；Slf4j，Logback，Log4jDocker

*更不用说*了:传统 DBs+SQL；MongoDBElasticsearch 卡珊德拉；Neo4jCouchbase 卡夫卡；Ehcache、…

*还有* : AWS、Google 云平台、Azure——都有各自的数百款产品。

这只是我脑海中的东西，冰山一角。还有更多的。

我们中的大多数人并没有真正考虑它，因为我们已经熟悉了这个堆栈。当我们需要时，我们添加工具和框架，我们学习另一件事，我们继续前进。从一个新手的角度来看，当你在一个地方看所有这些东西时，你会意识到所涉及的活动部件的数量。

经过这个小小的迂回之后，我承认:老实说，我不知道为什么我认为 JavaScript 世界会有所不同:)

# [](#making-sense-of-both)两者兼而有之

幸运的是，很多东西在概念上很容易映射到我们已经熟悉的东西，其余的在逻辑上是有意义的。我们目前的堆栈由 Vue/Nuxt/Vuetify 组成，因此，我将从这个角度出发。

于是二话没说:

*   到 Java 世界的映射并不总是显而易见的，我认为 Vue vs React vs Angular 是严格意义上不可翻译的事情之一。也许最接近的是 Java vs kot Lin vs clo jure vs Scala vs…-你仍然有底层核心(JVM +字节码)，就像 web 框架一样，你有浏览器、HTTP、HTML、CSS、JavaScript/Typescript 在最终运行的核心。为什么你需要 Vue 而不仅仅是 HTML/CSS/普通 Javascript/其他更简单的 Javascript 库？对我来说，这是一个类似于人们问“我为什么需要 Spring portfolio”的问题。从技术上来说，你并不需要它——但是如果你不使用它(或者只使用一个简单的依赖注入框架，比如 Guice ),在任何更复杂的项目中，你很可能最终会编写你自己版本的各种 Spring 库，带有大量的错误和大量的时间浪费。我真正喜欢 Vue 的是它的反应能力，我不知道，也许它和 React 相似。也就是说，你可以告诉 Vue 这部分 UI 依赖于这个特定的变量(你**将它绑定到这部分数据)，然后你可以简单地修改数据，UI 组件自动更新——没有奇怪的监听器、回调或任何其他样板文件。它使得创建可爱的、交互式的用户界面变得极其简单。**
*   **NodeJS** -想想:Tomcat/Jetty 之类的。就像你不需要为每一个 Java 应用程序都使用它们一样，一旦你遇到更复杂/动态的项目，你很可能会使用它。
*   这就像是 Vue 世界的瑞士军刀。这就是 Spring Boot 对于爪哇的意义。固执己见的框架，你最好遵守约定——但是当你这样做的时候可以节省很多时间。它集成了许多其他好东西，从 VueX、Vue 路由器到 webpack，以及许多其他东西，并且工作正常。我喜欢它。以下所有内容都是免费的(否则就要靠你来让这些东西很好地结合在一起)
    *   **验证** -一个材料设计组件库。Vue 本身主要是用“语言”来描述你的应用。思考循环、条件句和结构。Vuetify 为您带来了开箱即用的漂亮的按钮、表格、迭代器、标签和许多其他构建模块，使您的页面看起来很漂亮。你可以将 Vue 与纯 HTML/CSS 一起使用，或者许多其他组件库，或者上面的一些简单的 CSS 层——这完全取决于个人品味。我们发现 Vuetify 对初学者非常友好，所以如果你不是 CSS 忍者，从这里开始不会错。
    *   状态管理库，有点像 Vue 应用程序的内存全局可用缓存。你可能需要它来处理比只有很少数据的静态页面更复杂的应用程序。
    *   VueRouter -有点像 Spring MVC/Controllers routes -基本上，指示你的代码的哪一部分负责你的应用程序的哪一部分
    *   SSR vs 客户端模式 vs 静态呈现内容 -这真的值得自己的帖子，深入本质细节，但现在有一件事需要理解。Nuxt 为您提供了三个运行 Vue 的选项:
    *   *静态渲染站点*，意思是你用 Nuxt+Vue 写代码，然后你创建一个漂亮的静态页面，也就是没有 Node.js，你只提供普通的 HTML/CSS/Javascript，甚至是来自 S3 这样的东西。想象一下，你硬盘上的静态 HTML。
    *   *全 SPA(单页应用)模式*，也就是说，你的应用作为一个非常空的外壳交付给浏览器，浏览器执行 Javascript 来动态创建 HTML/DOM
    *   *通用模式* -对页面的第一次点击将在 Node.js 服务器上执行(因此名为:SSR，服务器端渲染)，然后这个客户端会话中的后续页面/路由(准确地说:直到有人关闭/重新打开标签，或者点击刷新)将由浏览器处理

生成静态站点的好处是显而易见的——它更容易服务。但是，您不能将它用于高度动态/数据驱动的应用程序。如果不能用那个，那么通用/SSR 模式相对于 SPA 有什么好处？简而言之:SEO。如今，搜索机器人在 Javascript 方面比过去好得多。如果你有一个只有一点 JS 的页面，你可能仍然会得到很好的页面索引。不幸的是，在我们的经验中，对于任何更复杂的东西，当你从相当多的数据调用中驱动你的页面时，机器人不会等待足够长的时间/足够充分地处理一切以正确地索引它。Nuxt 让 SSR 的使用变得非常简单，当我们意识到我们需要 SSR 时，我们开始使用 Nuxt，因为没有它我们会陷入痛苦的世界。

*   **Axios**-Axios = ~ Spring rest template。一个用于 HTTP 调用的简洁的库。很好地集成到 Nuxt 中，这样只需很少的配置，您就可以在任何需要的地方访问它。
*   **PWA(渐进式网络应用)**——根据谷歌的说法，*渐进式网络应用(PWA)是一种使用现代网络功能向用户提供类似应用的体验的网络应用。* Nuxt 附带了一个模块，使得创建 PWA 更加容易。(我们在这里的旅程才刚刚开始，但我以后可能会写更多关于它的内容)
*   npm/yarn + webpack -我把它归结为一点，尽管这些都是独立的技术-因为对我来说，这一切都符合“我如何管理我的依赖关系并构建这个东西”。也就是 Maven/Gradle 等同。这里的中心是 package.json(想想:build.gradle / pom.xml)。当你使用 Nuxt 时，webpack 部分不是你需要考虑的事情——所以我们不需要——但是你可以在需要的时候配置它。
*   **巴别塔**——和上面有点关系。你会乐于停留在 Java 1.4 或 5.0 上，而不能使用 Java 6、7、8 中的所有东西吗？(反问)毫不奇怪，JavaScript 爱好者也不喜欢拘泥于一些旧的 JavaScript 语法。但是与 Java 世界不同的是，您很难控制您的代码将在什么环境(浏览器)中运行。所以在某些方面，Babel 有点像一个聪明的 Java 编译器，它将你的全新代码转换成旧的 JVM……我是说旧的浏览器……仍然可以理解的东西。干净利落。哦，最棒的是？如果你使用 Nuxt，所有的魔法都会在你不经意间发生。顺便说一句，你有没有注意到我在这里一直使用“JavaScript”——公平地说，我可能应该说 JS、EcmaScript、TypeScript… -但这只会在现阶段混淆事物，所以让我们坚持将 JS 作为一种思维捷径，知道它不仅仅是那样。
*   有点像 Java 世界中的 Findbugs、PMD 和代码风格检查器。我们实际上没有打开它们，因为它们在默认配置下非常吵，我也没有时间去微调它——但这是我(永无止境的)待办事项清单上的事情。
*   **Jest 和 Cypress** -测试测试测试。Jest 就像 JUnit、Cypress 一样，对高级/功能测试很有用。外面有许多选择，这些似乎最符合我们的想法。

坦白说，就是这样！这就是您开始 Vue/Vuetify/Nuxt 之旅所需了解的全部内容。是的，当然有更多的方法，尤其是当你开始更多地寻找引擎盖下的东西，或者有不寻常的需求时——但是仅仅是模糊地熟悉以上内容就完全有可能变得富有成效。这是你构建一个应用程序所需要的一切，而不仅仅是一个超级简单的 Hello World！

# [](#bonus-1-why-vuejs-and-not-react-or-angular)加成 1:为什么 VueJS 和没有反应或者有棱角？

我经常从我的开发朋友那里得到这个问题，所以不妨在这里解决一下。Angular 很简单——我绝对讨厌谷歌放弃项目的倾向，我相信他们还会这样做，所以我甚至没有进一步研究它。坦率地说，我并不反对 React 本身——也许除了它是由一个邪恶的公司制造的，我宁愿保持一定的距离。但除此之外，我确信这是一项杰出的技术。为什么不呢？

我们的项目是由两个人构建的，我自己和一个全新的开发人员，一个在项目开始时可以声称拥有在 Dreamweaver 中做 HTML 网站的经验的人。我先调查了 React，但是整个“只使用 Javascript”的态度让我有点害怕。即使对我来说，获得一个简单的应用程序只是稍微超出“你好世界”不是一个 5 分钟的工作，我不明白发生了什么。事实上，Vue 将 HTML(结构)+ CSS(样式)+ Javascript(动作)结合成组件的概念对于一个新手来说似乎更容易理解，这对我来说非常有意义。还有很多关于 HTML 和 CSS 的基础资料可供选择。你可以逐渐了解更多。反应？一开始就觉得曲线太陡了。

*一个有趣的事实*:当我们刚开始的时候，因为我是一个“铁杆 Java ”,我们甚至没有使用 Nuxt。我们没有使用 Node.js。我们从一个应用程序开始，这个应用程序是一个 Spring Boot，上面有一点 FreeMarker，还有普通的 Vue。Webjars 提供 Javascript 库的时代。然后手动添加 Vue 路由器和 VueX。那是有趣的时光，我通过那种方式学到了很多关于堆栈的知识——但如果你珍惜你的时间，我不一定会推荐这种方式；)我认为 React docs 现在可能会好一点，但在当时，它真的会把你推向全栈路线，而我根本没有准备好。

所以我们在这里。我从未后悔过这个决定。是的，从“有更多工作”的角度来看，拥有反应技能可能会更实际一点——但除此之外，我们对 Vue 的工作方式非常满意。

# [](#bonus-2-what-are-the-gotchas)加成 2:有哪些骗术？

## [](#environment)环境

到目前为止，关于 Nuxt/Vue 组合，有一个主要的“问题”让我很困扰，而且作为一个后端开发人员，你很可能会被它绊倒。“构建一次部署多次”的概念。目前这确实是一件棘手的事情，它涉及一堆黑客攻击，而不是一个整洁、标准的解决方案。在你通常的 Java 应用程序中(不要对 Spring Cloud Config Server 之类的东西太着迷)，你经常会有 properties/yml 文件形式的外部化配置，和/或传入环境变量。后者可能会给你带来无限的痛苦，因为 Nuxt 某些部分的*环境变量在构建时就已经被固化了。让我重复一遍。Nuxt/Webpack build 在构建时间获取您的环境变量**，并将它们放到生成的资源中。它们不是在运行时从环境中获取的。***

更令人困惑的是，并非所有应用/用例都是如此。Nuxt 有一个[插件](https://www.npmjs.com/package/nuxt-env)，允许你读取和使用运行时环境变量。一个很好的经验法则是:如果你在你自己的代码中使用某些东西，在你的组件中——你可以使用运行时$env 变量。然而，这就是事情变得糟糕的地方，如果你使用第三方 Nuxt 插件或模块(例如，用于 google analytics ),并且它是在 nuxt.config.js 中配置的——你就完蛋了。目前还没有一种优雅的方法可以让你使用环境变量来达到这个目的。这非常令人困惑，因为 nuxt.config.js 运行了两次——在构建期间，然后在您的(构建的)服务器启动时。所以如果你有类似
的东西

```
console.log("Full environment we're running in: " + JSON.stringify(process.env)); 
```

在 nuxt.config.js 的开头，env 变量似乎设置正确。除此之外，在这段代码运行时，配置中的变量已经被硬编码为构建过程中出现的值。

那就更(！)令人困惑，因为如果您在 dev 模式下运行(在 localhost 上测试时通常使用的模式),一切都会正常工作，因为构建和运行实际上是同一个过程——所以为这个过程设置一个环境变量就可以了。

呸。这使得在 Docker / cloud 中运行事情变得不那么简单，并有效地迫使您在部署时重新构建(至少是部分)应用程序(或者使用许多可能的方法中的一种，我可能会在未来的帖子中讨论)。我真的希望 Nuxt 团队能在某个时候找到一个更整洁的解决方案，就像现在这样，感觉真的很糟糕。

## [](#reactivity)反应性

当你开始使用 Vue 时，可能需要一点时间来了解 Vue 的*魔法*反应到底是如何工作的。我们曾经有过这样的情况，我们试图使用一个动态值，但是它并没有按照我们期望的方式更新视图。它不再发生在我们身上，所以我认为现在我们直观地理解了反应是如何工作的——但在过去这并不总是显而易见的。如果人们想出任何反应不起作用的例子，我想我可以试着找出原因，也许把它分解成更直观的规则/看待它的方式。

# [](#code)代码

从技术上讲，这里没有多少代码可以展示。Nuxt 为一个框架项目提供了一个很棒的生成器，你所需要做的(安装 yarn 和 node.js)就是运行:

```
yarn create nuxt-app plain-nuxt-app 
```

它会问你几个关于你想在你的项目中包含什么的问题。在 [examples/plain-nuxt-app](https://github.com/lilianaziolek/blog-examples/tree/master/plain-nuxt-app) 中可以找到一个与我们项目中的选项相当的示例。默认启用的林挺配置非常严格，因此如果您刚刚开始，您可能想要跳过它——否则，您可能会得到一些看起来令人害怕、令人困惑的错误和警告。

各位，今天就到这里。如果上面的任何观点或主题特别有趣，请在下面评论/请求更多信息！