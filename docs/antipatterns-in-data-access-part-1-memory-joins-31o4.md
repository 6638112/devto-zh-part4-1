# 数据访问中的反模式，第 1 部分——内存连接

> 原文：<https://dev.to/vbilopav/antipatterns-in-data-access-part-1-memory-joins-31o4>

我很久很久以前就想写这个了...

因此，在过去十年左右的时间里，我不得不从事各种项目——我注意到他们中的许多人在与他们的数据库通信的部件上遇到了麻烦和问题。

作为系统中如此脆弱的一部分——通常是完全不可能修复和重构的。或者至少非常困难和冒险。因此，在我见过的大多数情况下，开发人员甚至不敢碰它——就让它保持原样。

现在，当然总是有可以做的事情，然而，从一开始就避免那些反模式总是最好的策略。

那么它们是什么呢？

围绕这个话题的文献和博客很少，而且有点不确定。讨论这个重要问题细节的文章并不多。

通过[https://www . infoq . com/articles/Anti-Patterns-Alois-reit Bauer/](https://www.infoq.com/articles/Anti-Patterns-Alois-Reitbauer/)找到了这个

但在我看来，它仍然有点笼统，而且仅限于性能。虽然这些反模式确实对性能有巨大的影响，但严格地说，它们不仅仅是性能反模式。我认为它们本质上也是结构性的。

我将尝试详细描述我几十年来在处理破损应用程序时所记得的所有问题。一次又一次的重复出现。

因此，这将是一系列的文章，因为我试图描述每一个人，因为我记得他们。

如果您不同意我的观点，并且认为其中一些方法不是反模式，请礼貌地告诉我。我总是支持不同的观点。

## 反模式 1:在数据库客户端连接数据集。

将不同的数据集连接成一个数据集一直是数据库的核心功能之一。因此，它得到了 ORM 库的出色支持。然而，出于不同的原因，一些开发人员会选择不使用该连接功能，并构建类似于以下内容的解决方案:

*   **查询第一个数据集**并将数据提取到数据库客户端(您的程序)。

*   **查询第二个数据集**并将数据提取到数据库客户端(您的程序)。

*   在你的程序中构建算法，将这两个数据集连接成一个(根据需要)——在你的程序内存中。

现在，开发人员采用这种方法的原因可能有所不同。例如:

*   在某些情况下，ORM 工具对于如此复杂的查询缺乏表达能力(例如 Django ORM ),开发人员认为必须不惜一切代价避免使用 SQL。

*   出于某种原因，开发人员已经得出结论——连接(或合并)操作是域责任的一部分。例如在 DDD 方法论下工作时。

*   他们只是不知道更好的方法。缺乏适当的指导和不切实际的信心。

所以，不管原因是什么，这种方法的问题是什么，为什么是这种反模式？我认为有几个原因:

*   它很慢。很慢。我很快会解释...

*   它的可扩展性不是很好。数据越多，进入系统的速度越慢，直到达到完全无法使用的临界点。那么你别无选择，只能彻底重写你的应用程序的大部分，否则你会失去重要的客户。

*   这很危险。它可能会耗尽你的全部记忆。

*   它增加了可维护性和复杂性。你得手动写一个复杂的算法。与一个数据库指令或指示相比。

那么是什么让它如此缓慢呢？

首先，有一个带宽的问题，你需要通过网络传输相当数量的数据，然后你必须再次迭代，至少三次(假设你缩小了算法的时间复杂度)。

有人曾在推特上形象地描述过——你可以这样想:

**数据有一个质量**(不，不是真的，但我们可以这样看——考虑到数据大小和网络上数据传输的时间是成比例的)。一个大的数据集可以被看作一座山。

在这种情况下，我们实际上有两座山。你用这种方法真正要做的是把两座大山移到你的工具箱里，以便能够在它们上面工作。本质上，就是这样。怎么会有人认为这是高性能或可扩展的呢？它不是。

不仅如此，你真的是在移山倒海，以达到你想要的结果。当您将工具箱移动到山区时(即，使用直接在数据库上工作的 SQL)，数据库算法将总是优于您在程序中编写的任何算法，这至少有两个主要原因:1)显然直接在数据库上工作 2)数据库优化器在大多数情况下会选择比您更好的算法，因为它是基于表统计的可用数据选择的。这意味着，如果生产中的数据比开发数据库中的数据大得多，那么所选择的算法可能会有所不同，而且更加合适。

通过将这个反模式重写为 SQL 查询，我在中等数据集(大约 50 万条记录的表)上获得了 50 到 200 倍的性能提升(甚至不涉及索引)。

所有这些代码减少了 2 到 3 倍，从而简化了未来的维护工作。

我还必须指出两件重要的事情:

*   重写这个反模式在任何情况下都是不可避免的(由于不可用而失去客户)

*   重写这个反模式总是极其乏味和困难的，并且经常需要多次测试和修复循环。

*   需要修改的代码通常分散在整个系统中，并且经常被混淆和伪装成其他东西——这使得重写和重构变得如此困难和危险。尤其是在动态语言中。

因此，为了避免这种不良情况，应该从一开始就避免这种反模式。简单地用你的数据库语言写下你的查询。数据库语言是你的数据 API，它应该返回你的程序需要的所有数据，而不需要任何进一步的数据操作(连接、合并、联合等)。

如果您正在使用 ORM，好吧，首先探索 ORM 是否支持您需要的那种类型的操作(连接、合并、联合等等)，并且不会强迫您将数据拖到程序内存中。

如果没有，那么你必须编写适当的数据库查询，返回你需要的一切，通常是 SQL(还有其他像 CQM，塞弗等)。如果混合使用不同的语言让你感到不舒服，并且你认为这是一种代码味道——把它分离到另一个文件中。好吧，一切都比把堆积如山的数据拖到你的程序里要好。

并围绕该查询编写一些测试，这将使进一步的优化更加容易。

你觉得怎么样？

您认为这种方法是反模式吗？生产中遇到过这种情况吗？我很想听听一些想法。

下周我将讨论另一个令人讨厌的数据访问反模式，不幸的是，这种模式非常普遍。Markus Winand 将其称为“嵌套循环反模式”，这是非常准确的。克里斯蒂安·博恩称之为“机关枪数据访问”。无论如何，它有相同的症状，并且经常与我刚刚描述的反模式结合在一起。

所以，直到下一次...