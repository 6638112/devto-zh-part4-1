# API 规范的问题(以及如何构建一个更好的规范)

> 原文:[https://dev . to/acunniffe/problems-with-API-specifications-and-how-to-build-a-better-one-8g8](https://dev.to/acunniffe/problems-with-api-specifications-and-how-to-build-a-better-one-8g8)

# API 规范的问题

### [](#and-how-seamless-built-a-better-one)又是怎样天衣无缝的建造了一个更好的...

当我们着手为 API 构建更好的工具时，我们首先要问自己的一个问题是，我们是应该创建自己的 API 规范格式，还是选择与现有标准进行互操作。

OpenAPI/Swagger 势头强劲，选择它作为 Seamless 的后台表示似乎是事实上的“正确之举”也有一些有趣的智慧将我们推向现有的标准，如 OpenAPI、RAML、API Builder 或 API Blueprint。

## [](#what-is-a-specification)什么是规范？

在选择一门课程之前，我们花时间从基本原则出发思考这个问题。

规格或“规格”具体而精确地描述了一个软件的行为。对程序员来说，最有用的规范是机器和人都能读懂的规范。

API 规范描述了可以通过网络访问的程序接口。当代的例子包括 OpenAPI 文件、protobuf 定义或 graphQL 模式。理想情况下，它们应该:

*   便于人们使用，并提供出色的开发人员体验。
*   忠实地编码他们描述的 API 的接口。
*   具有丰富抽象的领域的代表，这些抽象对于手边的任务(设计、代码生成、文档生成)是有用的。
*   稳定。对于用户和工具制造者来说，复杂规范中的突破性变化是非常昂贵的。
*   基于规范构建的工具很容易查询他们需要的数据。接口应该稳定很多年，领域逻辑不应该在工具本身中重复。

## [](#retiring-an-old-idea)隐退旧观念

如今，每一个相互竞争的 API 规范都包含了一个主要假设，即这些规范必须以人类可读、机器可读和人类可写的格式保存。在实践中，这最终会以一个大型 YAML 或 JSON 文件的形式出现。

在这三个相互竞争的关注点之间找到一个健康的交叉点是很难实现的，并且充满了权衡。以下是一些重要的例子:

*   **人类** **可读性权衡:**API 很自然的表现为图形。不相信我们？控制并计算“$ref”在您的规范中出现了多少次。人类很难阅读线性文本形式的图表，因此 API spec 标准使用树来更好地交流结构和关系。
    *   **对机器可读性的影响:**这给每个工具制造者带来了巨大的负担，在对你的规范做任何有趣的事情之前，要解决$refs 并重建图形。
*   人类 **可写性权衡:**如今，spec 标准中有很多人试图让它们更容易编写。示例包括定义身份验证模式的关键字和使用$refs 来帮助 DRY(不要重复)。
    *   **对机器可读性的影响:**当规范不明确，并且包含 auth 的“oauth”或其他由规范标准本身定义的语义时，工具需要保持当前状态，并自行重新实现领域逻辑。
    *   **对人类可读性的影响:**今天的 API 规范很难阅读，因为正是这些特性使得它们更容易书写。看到一个响应是$ref: OrderType 意味着我必须找到 OrderType，那里引用的其他三个类型，然后在我的头脑中构建扁平化的模式。
*   **机器可读性权衡:**要使 API 规范对机器可读，它们必须使用严格的语法(JSON 或 YAML)并符合严格指定的模式。
    *   **对人类可读性的影响:** JSON 不好读，尤其是 10k +行的时候。
    *   对人类可写性的影响:没有人天生会写 YAML 或对 API 规范标准有完美的直觉。即使是专家也会花很多时间来对抗工具。

> 这个问题的这种形状意味着你不能用普通的思维去解决它。你对可写性的优化越多，你就越难让机器和人类阅读。对机器和工具来说越好，对人类来说就越不好写。

## [](#cqrs-to-the-rescue)CQRS 前来救援

透过这个镜头，当前 spec 标准的根本问题变得显而易见。只有一个模型既用于读又用于写，它还必须支持人类和机器的需求。我们都同意，从一个单一的数据模型来看，这是很现实的期望。

我们需要针对以下方面优化的模型:

*   人类可读性:这样程序员可以容易地阅读和理解 API。
*   人类 **可写性:**这样程序员可以用高效的抽象快速编写和修改规范。
*   **机器可读性:**因此工具可以查询规范中与它们相关的信息，最好是用 graphQL 之类的东西。

但是我们怎样才能同时得到这三样东西呢？

输入 CQRS(命令-查询-责任-分离)。微软的文档解释说，CQRS“将读取和写入分离到不同的模型中，使用命令更新数据，使用查询读取数据。”

一旦我们勾画出一个围绕 CQRS 和事件源原则构建的 API 规范，事情很快就水落石出了。分离关注点允许我们优化每个用例，而不引入折衷。

新的设计和对旧规范的反思以一种允许真正进步的方式改变了问题空间的形状。

## [](#making-it-concrete)使之具体化

我们实现的核心是开源的无缝域引擎。它可以在 JVM 或 Node 上运行，这使得它几乎可以移植到任何地方。在高层次上，域引擎解释命令并处理查询。你可以认为这是一种活的规范。它不是一个平面文件，而是一个实际的程序，可以回答您的查询，并根据您的命令修改内部 API 规范。这个内部 API 规范是自从开始使用 Seamless 以来您对 API 所做的每一个更改的事件流。每当您启动域引擎来构建 API 的当前规范时，都会回放这些事件。这些事件中的每一个都是关于 API 的不可变事实，如 RequestAdded、RequestBodyContentTypeSet 等。我们不必争论语法、语义或结构，甚至不必关心人类直接阅读或书写这些内容。事件是对 API 领域的纯粹描述。

API 规范域的命令可能是 AddQueryParameter、CreatePath、ChangeMethod、UseSchema、AddResponse 等。让程序员按顺序编写所有命令不是很人性化，所以我们也发布了一个开源 API 设计工具，类似于 Stoplight 或 RedHat 的 Apicurio。无缝 API 设计者响应于在 UI 中采取的动作向域引擎发送命令。Visual OpenAPI 设计器现在正在爆炸式增长。似乎不可避免的是，大多数团队都会采用一种，尤其是当 OpenAPI 格式变得更加复杂的时候。

### [](#try-designer)[试设计师](https://design.seamlessapis.com)

## [](#query-what-you-need)查询你需要的东西

在 CQRS，查询返回预测(为特定用例高度优化的自定义读取模型)。一些示例预测可能是:

*   端点列表—这就是您所能得到的全部。没有你不需要的东西。
*   模式/类型列表
    *   表示为规则列表(非常适合构建测试套件)。
    *   所有引用都被展平。
    *   作为 JSON 模式。
*   用 OpenAPI 表示的 API 传统的 spec 格式只是核心数据模型的另一种投影。甚至 Seamless 的一些更高级的特性，比如对泛型的支持，也可以投射到 OpenAPI 上。
*   自 API 的上一版本以来所做的更改。
*   为生成而优化的投影
    *   客户。
    *   API 实现。
    *   测试套件。
    *   自己做。

因为这些查询基于用于持久化的事件流，所以它们被保证是稳定的，原因有二:

*   作为一个工具构建者，你可以将你需要的查询和预测内建到你自己的代码库中。想象一下，如果 OpenAPI 以一种更清晰地映射到你为它构建的工具领域的方式来构建，这是永远的保证。
*   我们不会接受在主要项目的预测突破性的变化。如果您需要以中断的方式更改投影，您将被要求为查询命名其他名称。

## [](#benefits)好处

我们刚刚解开了很多关于架构的东西，现在让我们来讨论以这种方式表示我们的 API 的实际价值。

### [](#developer-experience)开发者体验

无缝既支持也需要更好的 API 设计工具，因为没有人手动运行命令。市场已经向结构化 API 编辑器发展，改善开发者体验的战斗已经开始。一旦您去除了解析和改变传统 API 规范的复杂性，您的团队就可以专注于构建一个伟大的 UX(参见我们的编辑器及其源代码作为示例)。

无缝还使得围绕 API 设计体验构建的专用工具的爆炸成为可能。由于投影和命令的工作方式，可以构建一堆非常棒的模式编辑器，它们只关心相关的事件/命令。用于生成测试的工具可以围绕它们自己的一组专用事件/命令来构建。有了这种架构，如果工具只关心与它们的领域相关的查询和命令就好了。

### [](#richer-abstractions)更丰富的抽象概念

随着关注点的适当分离，实现更丰富的抽象来表示 API 就变得更容易了。许多 API 架构师希望为诸如分页之类的事情定义可重用的标准，但是 JSON Schema 不容易支持这一点。在无缝中，我们很容易支持泛型。现在我们的模式可以将其他模式作为类型参数，比如`InfiniteScrollPagination[UserType]`或`PageBasedPagination[UserType]`。泛型使得 API 标准可以在团队的 API 之间共享。

OpenAPI 领域一个主要的未解决的挑战是区分规范。适当的差异将有助于防止破坏性的变更，生成语义变更日志，并为使用代码优先工作流的团队提供安全性。除了复杂的数据结构之外，这里的一个主要挑战是，对平面 JSON/YAML 文件的更改失去了它们的意图。你怎么知道一个查询参数被重命名为‘foo’→‘bar’？JSON 的一个普通 diff 会显示删除了“foo”并添加了“bar”。

在 Seamless 中，每个变化都是一个捕获意图的事件，因此您可以轻松地构建一个语义差异作为投影。事实上，有一个开放的特性请求，每当您提取 repo 时，它都会显示 API 规范的更改。

最后，在现实世界中，团队使用 REST、graphQL、Websockets 和 RPC 的组合，通常在相同的 API 中。一个结合了所有这些范例的传统规范会在自身复杂性的重压下崩溃，但是 Seamless 支持多个范例和它们之间的公共组件是可能的。我们怀疑这种互操作性在未来几年将变得更加重要，尤其是在企业环境中。

### [](#governance)治理

建立无缝域的方式意味着贡献者只需要回答一个问题“关于 REST API 我们能说些什么？”

如果它可以有请求，那么我们需要一个 RequestAdded 事件。

如果每个请求都可以有查询参数，那么我们需要为 QueryParameterAdded 添加一个事件。

如果每个查询参数都可以有一个形状，那么我们需要 ParameterShapeSet。

我们需要支持泛型吗？这只是 2 个新事件和 1 个查询。

保持领域的简单性、代表性和纯粹性是我们最重要的任务，与传统的 spec 标准相比，这对一组贡献者来说更容易管理。

一旦领域建模得到关注，工具制造者的需求将指导构建的命令和查询的开发。

## [](#tradeoffs)权衡取舍

这种设计也有一些明显的权衡。

*   无缝依赖于围绕它构建的 GUI API 设计器。我们已经发布了一个很棒的开源解决方案，但我们需要更具竞争力的解决方案来并行发展。
*   在 CQRS 思考很难。不熟悉这些概念的投稿人将不得不投入时间和精力来学习。但是，用 OpenAPI，RAML，或者 API Blueprint 来思考也很难。我们认为让一小组贡献者学习 CQRS 更容易，这样数百万需要设计他们的 API 的开发者可以从更好的工具中受益。
*   虽然 CQRS 自然支持协作编辑，但跨客户端分发事件所需的基础设施很复杂，并且依赖于最终的一致性。微软很好地解释了在这里使用 [CQRS 表示数据的利弊。](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)

## [](#openapi-support)OpenAPI 支持

我们已经使用 OpenAPI 很多年了，并且相信它将会持续很长时间。为了更容易开始使用 Seamless，我们构建了一个支持版本 2 和 3 的 OpenAPI 导入器。你可以[在这里上传你的规格来尝试无缝](https://design.seamlessapis.com/upload-oas)。

还有一个项目正在进行中，它输出有效的 OpenAPI 3，应该可以很好地与您现有的工具配合使用。

除此之外，导入器的架构受 GraphQL 的启发，允许我们直接从规范中查询我们需要的信息。解析器管理版本 2 和版本 3 之间的差异。[点击此处查看来源](https://github.com/seamlessapis/seamless/blob/master/oas/src/main/scala/com/seamless/oas/Schemas.scala)。

# [](#closing)关闭

> 传统的规范围绕相同的模式形成社区。我们希望通过我们的规范，围绕类似的工作形成社区。

没有人醒来后会想，“今天我们要构建另一种方式来规范 API。”我们当然没有。

我们相信每个 API 都应该无缝地互操作。除非使用 API 像安装节点模块和设计它们一样容易，否则情况不会如此。

尽管服务器生成器、SDK 生成器和 spec 标准已经存在了十多年，但是对于大多数团队来说，连接 API 和客户端并不容易。不要误解我们，有许多团队拥有很好的端到端流程，并获得了巨大的收益。外面有很多很酷的工作。正如他们所说，“未来就在这里，只是分布不均匀。”

我们认为一个更好的 API 规范能够支持一个全新的工具生态系统，这是一个关键的基础设施，我们很乐意将我们的工作开源并提供给社区。

我们期待听到您的意见、想法和顾虑，并努力将它们融入到项目中。

*   [GitHub](https://github.com/seamlessapis/seamless)
*   [问题](https://github.com/seamlessapis/seamless/issues)