# 算法面试问题内幕指南

> 原文:[https://dev . to/fahimulhaq/the-insider-s-guide-to-algorithm-interview-questions-9b 7](https://dev.to/fahimulhaq/the-insider-s-guide-to-algorithm-interview-questions-9b7)

算法是编码面试的重要组成部分，尤其是在五大科技公司(谷歌、微软、脸书、苹果、亚马逊)。我们将看看一些你在即将到来的面试中需要知道的常用算法，让它们更有效的方法(因为这是面试中常见的问题)，最后我们会给你一些练习题。

让我们开始吧。

### [](#overview-of-the-basics)基础知识概述

您需要回顾的基本概念有:

*   条件语句:if-else 语句、switch 语句和条件表达式
*   循环:for 循环，while 循环，do-while 循环
*   数据结构:数组、链表、哈希表、二叉树、二分搜索法树等。
*   函数:迭代函数和递归函数

一旦你有了基本的东西，你就可以开始进入你在安排技术面试前应该知道的中间概念；具体来说，这篇文章将向你展示一些关键的算法范例(以及提高它们效率的方法)，这些范例对于学习如何在面试中解决任何编码问题都是非常重要的。以下信息假设您已经熟悉了数据结构。如果你还没有，看看这些关于数据结构的复习课程。

准备好通过编码面试了吗？查看这门课程，[c++中的算法:面试复习。](https://www.educative.io/collection/5642554087309312/5745541363269632)

### [](#asymptotic-analysis-boosting-the-efficiency-of-your-program)渐近分析——提高程序的效率

在深入算法范式之前，应该说一下与算法相关的计算机程序的时间复杂性和效率——一个被称为**渐近分析**的概念。在面试中，你可能不会被要求直接计算一个算法的复杂度，但是你可能会被要求计算你写的算法的复杂度，或者改进给你的算法的复杂度。

复杂度是算法效率的近似度量，与你写的每一个算法都有关联。这是所有开发人员必须时刻注意的事情。复杂有两种:时间和空间。时间复杂度和空间复杂度本质上分别是算法处理特定输入所需时间和空间的近似值。通常，需要解决三个层次的问题:

*   最佳情况——表示为大ω或ω(n)
*   平均情况—表示为大θ或θ(n)
*   最坏情况—用大 O 符号或 O(n)表示

大 O 是分析算法的首选，因为对于大多数用例来说，一般情况和最佳情况并不能洞察算法的效率。

[编码面试的大 O 符号](https://www.educative.io/collection/5307417243942912/5630721452408832)

### [](#finding-the-big-o-complexity-of-an-algorithm)求算法的大 O 复杂度

如果你在面试中被要求找出一个算法的复杂性，这里有一个通用的经验法则:

*   删除前导常量
*   忽略低阶项

例:
求时间复杂度为 3n + 4n + 2 的算法的大 O 复杂度
这简化为 O(n)。

### [](#asymptotic-analysis%E2%80%8A%E2%80%8Ahow-to-calculate-time-complexity-without-an-equation-given-to-you)渐近分析——没有给你方程怎么计算时间复杂度

计算算法的时间复杂度时，您需要采取三个步骤:

*   列出代码中所有的基本操作
*   计算每个人被执行的次数
*   将所有的计数相加得到一个等式

这里有一个简单的例子，它测量大小为“n”的 for 循环的时间复杂度。这里有一个大小为“n”的循环:

```
#include <iostream> 
using namespace std; 
int main(){ 
   int n = 10; // 0(1) 
   int sum = 0; // 0(1) 
   for (int i=0; i<n; i++) 
      sum+=2; // 0(1) 
   cout << sum; // 0(1) 
   return 0; 
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

首先，将代码分割成单独的操作，然后计算它被执行了多少次，如下所示:

[![alt text of image](../Images/68799a70ef93fb2ff2589a3083aac96e.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--8H6UuSWN--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1600/0%2ADs_LBumRx06wx2bY.png)

在计算了每个操作执行了多少次之后，你只需要把所有的次数加起来，就可以得到这个程序的时间复杂度。

时间复杂度= 1+1+1+(n+1)+n+n+1 = 3+(n+1)+2n+1 = > 3n+5

渐近分析的一般提示:

*   每次列表或数组迭代 c×length 次，最有可能是 O(n)次。
*   当您看到问题空间中的元素数量每次减半时，很可能是在 O(logn)运行时。
*   每当你有一个单独嵌套的循环时，问题最有可能出现在二次循环中。

计算算法时间复杂度的有用公式:
[![alt text of image](../Images/18128844421483794e27c14a32887e4d.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--vx1Aks9S--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1600/0%2AE2la86vR_QWURVjj.png)

### [](#what-are-algorithmic-paradigms)什么是算法范式？

算法范例是“构造问题有效解决方案的一般方法”；换句话说，它们是解决问题的方法、策略或技术，对每个程序员来说都是必不可少的。花时间学习这些，因为你在面试中很可能会用到其中的一两个算法。

算法范例是伟大的，因为它们奠定了一个框架，适合于解决各种各样的问题。例子包括:

*   **分而治之** —一种将问题分解成更小的子问题的模式，这些子问题随后被递归地解决和组合(非常适合树排序)。
*   **回溯** —一种解决问题的算法技术，通过尝试逐步建立一个解决方案，一次一个，删除那些不满足问题约束的解决方案。
*   **动态规划** —递归函数的优化算法。使用动态编程，您可以存储子问题的结果，这样我们就不必在以后需要时重新计算它们。

### [](#what-algorithms-should-i-be-aware-of-for-my-interview)面试需要注意哪些算法？

*   **蛮力** —这种方法要求我们通过所有的可能性来找到我们想要解决的问题的解决方案。这通常是第一个想到的算法，即使它可能是效率最低的，也能保证你有一个解决方案。
*   贪婪算法(Greedy Algorithms)—一种算法范式，一点一点地构建解决方案，这意味着它会选择下一个提供最明显、最直接利益的部分。
*   **动态编程**(如上所述)
*   **分而治之**(上面提到的)
*   **搜索排序算法** —合并排序、快速排序、选择排序、冒泡排序、插入排序、拓扑排序
*   **图算法** —广度优先搜索(BFS)遍历、深度优先搜索(DFS)遍历

准备好测试你所知道的了吗？试试这些练习题。

### 如何进行技术面试

*   确保你记下了最基本的东西。
*   理解如何用渐近分析优化你的程序。
*   请注意您可以使用的不同算法，以及它们对复杂性的影响。

### [](#sample-algorithm-questions-to-get-you-ready-for-an-interview)示例算法问题让你为面试做好准备

注意:你可以通过提供的超链接找到一个交互式编码平台和这些问题的答案。

渐近分析:
计算下面给出的代码片段的复杂度。

```
int main(){ 
  int n = 10; 
  int sum = 0; 
  float pie = 3.14; 
  for (int i=1; i<n; i+=3){ 
    cout << pie << endl; 

    for (int j=1; j<n; J+=2){ 
      sum += 1; 
      cout << sum << endl; 
    } 
  } 
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

[排序和搜索算法:](https://www.educative.io/collection/page/5642554087309312/5745541363269632/5009123663937536)
实现一个函数，取两个排序后的变长数组，求两个数组的中间值。

[图形算法:](https://www.educative.io/collection/page/5642554087309312/5745541363269632/5770275285106688)
实现一个函数，返回无向图中给定级别的节点数。

[贪婪算法:](https://www.educative.io/collection/page/5642554087309312/5745541363269632/5046585039781888)
给定无限数量的 25 美分硬币、10 美分硬币、5 美分硬币和 1 美分硬币，实现一个函数来计算代表 Vcents 的硬币数量。

[动态规划算法:](https://www.educative.io/collection/page/5642554087309312/5745541363269632/5291006528323584)
一个小孩跑上 n 级楼梯，一次可以跳 1 级、2 级或 3 级。实现一个函数来计算孩子跑上楼梯的可能方式。

[分而治之算法:](https://www.educative.io/collection/page/5642554087309312/5745541363269632/5733493980004352)
给定一个 k 行 44 列的 2D 数组和一个 k∫n 大小的空 1D 输出数组，使用分而治之方法将 k 个排序数组中的所有元素复制到 k∫n 输出数组中。

### [](#wrap-up)总结起来

如果你要参加一个技术面试，你必须准备好展示你对不同算法的知识，并理解每种算法的复杂性。熟悉上面提到的算法范例(即，分而治之、蛮力、贪婪)，正如老话所说，“熟能生巧”，所以一定要花时间练习实现不同的算法并计算它们的复杂性，因为这是开发人员在编写代码时必须意识到的事情。

以下是你可以采取的一些步骤，以确保你在下一次面试中获得成功:

**熟悉不同的算法:**不要只是死记硬背解法。花点时间去理解每种算法背后的模式以及应该采取的方法。

做功课:你练习得越多，你就会感觉越舒服。

**下一步..学习、准备和练习:**简单地浏览旧的面试问题和博客来准备面试是不够的，你需要真正的实践经验。查看这门课程，[“c++中的算法:面试复习”](https://www.educative.io/collection/5642554087309312/5745541363269632)，深入了解这篇文章中涉及的主题，以及真实世界的挑战和测验来测试你的理解。