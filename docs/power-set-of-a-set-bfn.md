# 集合的幂集

> 原文：<https://dev.to/brunooliveira/power-set-of-a-set-bfn>

**简介**

为了跟进我的面试问题系列，我们今天来看看这个问题:

> 这个问题是 Google 问的。
> 集合的幂集是其所有子集的集合。写一个函数，给定一个集合，生成它的幂集。
> 例如，给定集合{1，2，3}，它应该返回`{{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}`。
> 你也可以用一个列表或数组来表示一个集合。

让我们看看如何解决这个问题。

**初步观察:发电机组的规模**

在我们开始之前，我们需要知道对于给定的初始集合，幂集的大小是多少。

这很简单，因为它写在问题陈述本身上:*它是所有子集的集合的大小*。所以我们需要计算初始集合中所有子集的数量。

这是通过对我们集合的所有子集进行计数而获得的。但是怎么才能做到呢？

我们看到，当构建某个子集时，对于我们在原始集中遇到的每个数字，我们可以做两件事之一:

*   我们认为这个数字在我们的子集；

*   我们不考虑子集里的数字。

所以，对于每一个数字，我们有两种选择。

如果我们对每个数字取这些选择的乘积，我们就得到子集的总数。因此集合的子集总数，例如，`{1, 2}`将是:

`{}, {1}, {2}, {1,2}`

与`2^(num elements of initial set)`相同

**如何枚举每个集合:2 的幂的性质**

现在我们知道了需要枚举的子集的实际数量，剩下的就是实际枚举它们了。

为了做到这一点，我们可以注意到我们可以选择或者不选择集合中的单个元素，这就是我们如何首先得到总计数的。如果我们用二进制从 0 数到(原始集合中的 num 个元素- 1)，我们可以对这个确切的属性进行编码。
将二进制数中的 1 相加等同于将 1 加到该数的最右位，将进位加到最高位组左侧的位，并将所有其他位设置为 0。这就是为什么 3 是 11b，4 是 100b:从最高设置位的进位到上面的位，其他的都设置为 0。
为了生成幂集，当我们在位置 I 有一个集合比特时，我们把第 I 个元素作为我们子集的一部分。

然后，为了解决原始问题，我们从 1 到`2^(num elements of initial set)`进行迭代，取每个数字的二进制表示，用前导零比特向左填充以匹配 2 的最大幂的长度(循环的最后一个元素)，将原始集合的元素保留在集合比特上，并省略 0 比特位置上的元素。最后，我们将空集添加到结果中。

**Python 实现**

下面是所描述方法的 Python 实现:

```
zipFunction = lambda a,b: b if a=='1' else None
def powerSet(s):
  powerset = []
  for i in range(1,2**len(s)):
    zippedList = [ zipFunction(a,b) for (a,b) in list((zip((['0']*(len(s) - len(list(bin(i)[2:])))+list(bin(i)[2:])),s)))]
    powerset.append(list(filter(lambda v: v!=None ,zippedList)))
  powerset.append([])  
  return sorted(powerset) 
```

运行它会产生:

```
>>> powerSet([1,2])
[[], [1], [1, 2], [2]]
>>> powerSet([1])
[[], [1]]
>>> powerSet([])
[[]]
>>> powerSet([1,2,3])
[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] 
```

**结论**

为了解决这个问题，我们需要理解决定选择或不选择原始集合中的某个元素如何映射到以二进制计数到`2^(num elements in original set)`，并使用这些位来选择我们的值。
希望你喜欢阅读！下次见！