# 架构微服务的案例研究

> 原文：<https://dev.to/jeastham1993/a-case-study-in-architecting-microservices-2cm9>

在我的日常工作中，我几乎涵盖了软件开发生命周期的所有方面。从设计系统一直到交付和支持它们。我工作的公司很小(我们有两个人)，所以我们都扮演各种角色。

我目前正处于一个新项目的设计和开发的早期阶段:一个基于云的接收电子邮件的解决方案，将它们发送到识别服务，然后将结果导出到第三方 API。

该解决方案将在微软 Azure 中运行，并使用微服务构建。

部分是为了自我检查(读者们，在接下来的几篇文章中，你们是我的荣誉橡皮鸭)，部分是为了让人们了解设计系统的世界，我决定通过博客文章来绘制这个项目的整个生命周期。

在我进入具体细节之前，有几件事情需要注意:

*   我仍在学习构建微服务的最佳实践和设计原则。如果你正在读这篇文章，看到我可以做得更好的地方，请评论并告诉我
*   我已经模糊了该项目的一些细节，因为这是一个将在现实生活中使用的系统。在我能做到的地方，我会尽可能地保持真实的生活。

# 案例研究

那么我们在建造什么？我公司实现的软件是基于光学字符识别(OCR)软件。

简而言之，我们从文档中读取数据，并用它做有用的事情。

我们接触的客户每天都会收到数百封电子邮件，其中包含来自不同供应商的预订详情。电子邮件可以包含预订详细信息的附件，或者详细信息可以在电子邮件的正文中。

简单总结一下我们的需求列表:

*   在中接收通过[云邮件发送的电子邮件内容，并将数据和附件解析到存储器中](https://www.cloudmailin.com/)
*   将物理文件发送到 OCR 引擎进行识别
*   从包含预订数据的 OCR 软件接收响应，将预订数据传递给客户端 API**为了方便起见，我将对 OCR 引擎的细节保持模糊。但是，如果您感兴趣，我们将使用 [ABBYY Flexicapture Cloud](https://www.abbyy.com/en-us/flexicapture-cloud/) 。*

最初，我们将处理相对少量的电子邮件。但是一旦投入生产，这将会迅速增加。因此，系统的组件需要易于扩展，以应对容量的增加和减少。

# 为什么要微服务？

除了微服务是目前构建软件的“时髦”方式这一事实之外，这种基于云的系统与微服务架构完美契合。

## 可伸缩性

我最喜欢微服务及其通信方式的一点是可扩展性。随着入站电子邮件数量的增加，我可以简单地添加更多的“邮件处理程序”服务实例来应对这一数量。

由于 mailhandler 服务将是完全无状态的，所以运行一百个实例并不重要。

如果这个系统是一个传统的整体，在一个系统中具有所有的功能，缩放是困难的。运行多个实例也不行。唯一真正的选择是更大的功率，这可能会很快变得昂贵，最终仍会达到极限。

## 完全不同的成分

阅读功能需求列表，系统的不同部分之间实际上有非常清晰的界限。

*   接收电子邮件
*   发送进行 OCR
*   从 OCR 接收
*   发送到第三方 API

接收电子邮件的代码根本没有理由关心从 OCR 系统返回的索引信息，或者这些数据是如何传递给第三方 API 的。

它所关心的是如何解析一封入站电子邮件，然后告诉全世界。

我们已经看了为什么，让我们进入如何。

# 使用微服务进行设计

在设计基于微服务的架构时，我总是遵循相同的流程。我遵循的原则来自理查德·罗杰的精彩著作《微服务之道》。

## 消息

微服务应该以一等公民的身份设计消息。理解系统需要处理的消息为理解所需组件提供了一个不可思议的起点。

| 名字 | 描述 | 同步或异步 |
| 收件箱电子邮件:接收 | 从 CloudMailIn 接收新的处理请求 | S |
| 数据存储:保存 | 将电子邮件索引数据保存到数据存储中 | S |
| 数据存储:列表 | 列出数据存储中的数据 | S |
| 数据存储:addindexdata | 将 OCR 索引数据添加到数据存储中 | A |
| 文档存储:保存 | 保存入站电子邮件附件 | S |
| 文档存储:检索 | 检索入站电子邮件附件 | S |
| ocr:创建 | 创建新的 OCR 任务 | S |
| ocr:接收 | 从 OCR 引擎接收完整的响应 | S |
| 导出:发送 | 发送要导出的 OCR 索引数据 | S |
| info:newdocument | 引发通知新文档已保存的事件 | A |
| 关于:documentsentforocr | 引发事件，通知文档已被发送进行 OCR | A |
| 信息:documentfailedforocr | 引发一个事件，通知文档无法发送进行 OCR | A |
| 信息:接收的索引数据 | 引发通知已收到新索引数据的事件 | A |

对于我设计的每个新系统，我都会完成一个这样的表格。它涵盖了我认为需要传递的不同信息，以及所需的同步性。

同步性是一个棘手的问题。我使用的一般经验法则是，如果发送者关心响应，它应该是一个同步调用，如果不是，那么只是发射和忘记。

例如，当收到来自云邮件的新请求时，API 需要通知云邮件请求已经成功。这需要同步。

然而，当文档被发送到 OCR 引擎时，没有直接关心的服务。因此可以产生一条消息，说明新文档已经发送。任何关心的服务都可以监听消息并在需要时采取行动。

留言之后，是活动。

## 活动

消息本身并没有给出所需的实际功能和交互的足够细节。为此，我们需要研究不同的信息是如何连接在一起，在系统中形成一个流程的。

| 名字 | 信息流 |
| 新入站电子邮件 | 1.inboundemail:接收
2。数据存储:保存
3。文档存储:保存
4。信息:新文档 |
| 发送进行 OCR | 1.信息:新文档
2。documentstore:检索
3。ocr:create
4 . info:documentsentforocr 或 info:documentfailedforocr |
| 从 OCR 接收数据 | 1.ocr:接收
2。数据存储:addindexdata
3。信息:接收的索引数据 |
| 出口文件 | 1.信息:indexdatareceived
2。导出:发送 |

上表涵盖了整个系统的流程。它应该与功能需求列表紧密相关。

活动很好地表明了谁需要听谁的，以及互动在哪里。它还给出一个合理的逻辑分组来实际设计服务本身。

## 服务

现在我们到了有趣的部分，服务本身。

当我第一次开始设计微服务时，我总是直接投入到服务中。这并不是最糟糕的开始。但我发现，在找到正确的有界上下文之前，会有很多删减、更改和重新分解。

翻转设计，从我们这里的信息开始，使服务更加清晰。

| 名字 | 描述 | 派遣 | 收到 |
| 前面 | 处理外部 HTTP 请求，位于负载平衡器之后 | inbound mail:receive
ocr:receive
datastore:list |  |
| 入境的 | 将入站请求转换为格式化数据，并保存任何物理文件附件 | 数据存储:保存
文档存储:保存
信息:newinbounddocument | inboundrequest.post |
| 请求存储 | 处理请求和索引数据的持久性 |  | 数据存储:保存
数据存储:列表
数据存储:添加索引数据 |
| 文档库 | 处理物理文件的持久化和检索 |  | 文档存储:接收
文档存储:检索 |
| 光学字符识别 | 处理文档从存储到 OCR 引擎的移动 | datastore:list
documentstore:retrieve
ocr:create
info:documentsentforocr
info:documentfailedforocr | 信息:新建文档 |
| ocr-收据 | 从 OCR 引擎接收索引数据，并将其转换为格式化数据 | 数据存储:addindexdata
信息:indexdatareceived | ocr:接收 |
| 出口 | 处理将索引数据导出到第三方系统 | 导出:发送 | 信息:接收的索引数据 |

正如您所看到的，从消息开始在不同的服务需求之间给出了非常清晰的界限。

有两列结尾也有助于阐明每个消息和活动将由某人处理。

# 总结

这是这个系统开发和部署的早期阶段。

我这么说，是因为我知道第一个版本需要在 10 月 1 日上线。哦，伙计，我真的喜欢紧张的截止日期！

随着系统的发展，随着我进入实际编写代码的细节，我将开始充实这篇文章。

但在此之前，我希望这已经很好地向您介绍了设计任何基于微服务的系统的奇妙的三个步骤。

请记住:

*   信息
*   活动
*   服务