# Matt 的花絮# 35——调试复杂单元测试失败的策略

> 原文:[https://dev . to/mpeng 3/matt-s-tidbits-35-a-strategy-for-debugging-complex-unit-test-failures-16fd](https://dev.to/mpeng3/matt-s-tidbits-35-a-strategy-for-debugging-complex-unit-test-failures-16fd)

上次我在 Kotlin 中分享了一个关于断言的快速技巧。本周我想分享一个调试复杂单元测试失败的策略。

有时一个单元测试失败了，为什么它不起作用是显而易见的——也许你忘了模仿一些东西，或者你改变了一个简单的方法，现在返回一个不同的值，等等。

然而，有时变更的范围太大(或者代码太复杂)，以至于很难准确地找出导致失败的原因。为了解决这种情况，我想分享以下策略:

1.  首先，保存您的更改，并检查通过测试的最新版本的代码。
2.  接下来，使用调试器一次一行地通过测试，并在整个测试过程中记下每个(重要的)方法调用/变量状态。
3.  现在，重新应用您的更改并再次通过测试，执行与步骤#2 相同的文档练习。
4.  现在，比较两个版本之间的每个方法调用和变量状态。寻找任何不同之处。识别并挑战您可能做出的任何假设——您是否忘记了调用方法或设置变量，您是否在更改代码时引入了非预期的行为，或者测试是否需要更改？

只有通过仔细的分析和彻底的理解代码以前做什么，代码现在应该做什么，测试实际上在测试什么，你才能正确的解决问题。

最近我自己做这个练习时，我发现我遗漏了对一个重要方法的调用——在这个例子中它被称为`checkIfConnected()`。在我对代码的(不完全)理解中，我确信蓝牙设备已经连接上了(确实连接上了)，但不幸的是`checkIfConnected()`方法不仅仅检查它是否连接上了——它还初始化了应用程序的许多其他部分。添加该检查修复了测试失败！

这个故事的寓意是:

1.  在你试图改变代码之前，一定要理解它。
2.  使用任何可用的工具(包括铅笔和纸)来帮助提高你的理解，并仔细检查你的工作，看看你是否遗漏了什么。
3.  总是**总是** *总是*质疑你的假设。
4.  注意如何命名方法——如果`checkIfConnected()`被命名为`initializeConnection()`,我可能不会删除我认为是多余的语句！

我用铅笔和纸来追踪它，但是我很好奇——有人有基于软件的解决方案来分析和比较代码流吗？如果你有，请在下面的评论中告诉我！此外，如果你有兴趣获得未来花絮的通知，请通过媒体关注我。

*这个花絮发现于 2019 年 9 月 19 日。*