# 通过算法思考

> 原文:[https://dev.to/nwdunlap17/thinking-through-algorithms-hc0](https://dev.to/nwdunlap17/thinking-through-algorithms-hc0)

## 你的大脑对于简单的算法来说太聪明了

我想大多数人想开始编程的原因和我一样。在成长的过程中，我认为计算机是可以模拟整个世界，学习如何解谜，并保存数百万本书的信息的聪明的东西。这让我很难意识到编程的一个非常基本的事实。电脑是白痴。

这个事实是新程序员最常见的障碍之一。他们看到一个相对简单的算法，他们甚至不知道从哪里开始。这并不是因为他们太蠢而找不到解决方案，问题是他们太聪明了，根本看不到问题的存在！

这是世界上最简单的算法之一。以下列表中最大的数字是什么？

3, 7, 4

七点了。明明是七。如果我问你怎么知道是 7，你可能会看着我，就像我刚才问你天空是什么颜色一样。你只要看着它就知道是 7！这就是问题所在，你的大脑如此聪明，它跳过了所有它做过的工作，给了你答案。但是电脑是低能儿，它做不了你能做的事。算法设计的第一步是训练自己如何在较低的层次上思考。问问你自己“我是怎么知道的？”次数多了，最终你会达到计算机能理解的程度。(假设你没有转向哲学，那是笛卡尔的领域)。

这里又是同一个问题，求列表中最大的数。但是这一次，想想你到底在做什么，如果有必要的话，自言自语，尽可能缓慢地完成这项任务。

9, 1, 16, 2, 3, 7, 14, 5, 10, 15, 7, 12, 8, 4, 19, 10, 17, 8, 13

当然，答案是十九。但有一段时间，你可能认为答案可能是 16。你可能看到 16 是左边最高的数字，然后去寻找一个大于 16 的数字。你达到了 15，在你的内心深处，不管你是否知道，你认为“15 并不比 16 大。十六仍然是最大的数字”。当你到了 19，相反的事情发生了，你知道 19 是最大的数字。

所以基本上，你记住了你看到的最大的数字是什么，你对照它检查了所有其他的数字。当你找到一个更大的数字时，你反而记住了那个数字。这种简单程度绝对是你可以和你的电脑交流的。

```
biggest_number(number_array)
      biggest_number = first number in number_array
      for each next_number in number_array
            if(next_number > biggest_number)
                  biggest_number = next_number
            end
      biggest_number
end 
```

诚然，这并不算太多。在一个列表中找到最大的数字听起来并不令人印象深刻。但是这些技巧适用于更难的算法。让我们试一个。

## [](#making-assumptions)做出假设

我会给你几个 2D 坐标。你必须设计一个算法来确定哪条直线通过的点数最多。

[1,3], [2,1], [3,2], [4,3]

[2,2], [2,4], [3,2], [2,3], [3,3], [2,5], [4,4]

我太粗鲁了，不是吗？毕竟，在一个 2D 网格上有无穷多条线，你怎么能告诉你愚蠢的计算机不要看所有的线呢？让我们从引出这个问题开始，看看我们能否解决它。

```
|                               |      o            o
|o                 o            |      o      o
|            o                  |      o      o 
|      o                        |      o
|___________________            |___________________ 
```

那好多了！很容易看出，在第一张图中，右边的 3 个点构成了最长的线，而在第二张图中是 4 个垂直点。您当然不需要查看每一行来找出答案！事实上，我敢打赌，你在看第一张图表的时候，根本没有想到垂直线。

你的眼睛被吸引到要点上，而不是空白。大概发生的情况是，你的眼睛发现了两个点，*跟着他们做的线*走。就像前面的算法一样，你记录下哪条线的点数最高，当你查看了所有你关心的线后，你就知道哪条线最长了。

```
best_line(points_array)
      for every point in points_array
            for every other_point in points_array
                  Find the line between the points (y = mx+c)
                  count = 0
                  for every potential_point in points_array
                  if (potential_point is on line) {count += 1}
            end
      end
end 
```

你的大脑已经进化了数百万年，擅长寻找模式，解决大多数算法，你只需要把它正在做的事情分解成简单而具体的步骤。如果你养成了弄清楚你的大脑在做什么的习惯，你将能够快速而仔细地构建你的算法。

这篇文章的下一部分是关于让算法更快。这伴随着一个很大的警告。
**很多时候，最重要的只是找到解决方案。**在面试和应聘中，最重要的是迅速找到解决方案。这允许你向面试官展示你的理解，或者测试你代码的其他部分。当你有了一个有效的算法后，你只需要担心如何提高你的算法的性能。

## [](#what-makes-an-algorithm-good)什么让一个算法好？

有几个标准可以用来判断算法。应用程序中的“最佳”算法形式可能会严重依赖于这些标准中的一个。对于面试来说，通常没有“最佳”答案，但好的答案往往会平衡这三者(或者至少，在所有标准上保持合理的表现)。能够在面试中评估你的答案也是一个巨大的优势，因为这表明你很好地理解了你可以尝试改进它的方法。

*   简单性:当你在代码中看到算法时，理解它是多么容易。
*   可伸缩性/速度:算法完成需要多长时间？以及当数据量翻倍时，需要多长时间才能完成。
*   大小:计算机完成算法需要多少内存。

这篇文章的其余部分将关注可伸缩性/速度。如果你根据“我的大脑在做什么”的原则设计一个算法，那么你可能已经有了一个非常简单直观的算法。并且显著减少算法的大小通常涉及一些特定于该语言的非常技术性的技巧。

## [](#start-answering-before-they-stop-asking)在他们停止提问之前开始回答

如果你看过《危险边缘》,你就会知道最成功的参赛者是那些在亚历克斯·崔贝克读完问题之前按下蜂鸣器的人。遵循上述方法将有助于您获得问题的答案，但它们可能无法帮助您获得最快的答案。以下两个问题直接取自谷歌访谈，它们都是关于尽快解决问题的。

影响算法速度的最大因素之一是迭代时间。你需要浏览你的数据多少次？当我们寻找最大的数字时，我们只需要浏览列表一次。如果我们将列表的长度增加一倍，找到最大数所需的时间也会增加一倍。当我们寻找最密集的线时，我们必须检查每一对点。如果我们把点数增加一倍，找到这条线所需的时间将会增加四倍。显然，我们更喜欢前者而不是后者，因为时间累积得非常快。

### [](#getting-as-much-information-as-possible)获取尽可能多的信息

如果你从未听说过，链表是一种数据结构，其中每个成员指向下一个成员。它们非常有用，因为它们可以无限扩展，而且它们占用的内存尽可能少，因为没有管理它们的开销。链表的缺点是导航起来很痛苦，因为你只能从头开始，一次只能前进一个条目。

google 的问题是这样的:在一个链表中找到中间节点，但是只能使用一个循环。这个限制立即阻止了显而易见的解决方案:遍历列表，计算元素的数量，然后遍历一半的节点数，找到中间点。

这里的技巧是从每个节点获取尽可能多的信息。如果我们在每一步停下来仔细考虑我们所知道的，我们可以在一个循环中解决这个问题。一种方法是假设我们访问的任何一个节点都可能是最后一个节点，并准备一个答案来回答这个问题。

让我们看一下它是什么样子的:

我们从第一个节点开始，如果这是列表中的唯一节点，那么它也是中间节点。

当我们到达第二个节点时，第一个节点仍然是中间节点。

当我们到达第三个节点时，我们知道第一个节点不可能是中间节点。如果这是最后一个节点，则第二个节点是中间节点。

如果我们到达第五个节点，第三个节点就是当前的中间节点。

由此推断，我们每前进两个节点，中间节点就前进一个。我们可以继续这种模式，直到到达列表的末尾，然后立即返回我们准备好的中间节点。

```
Find_middle(linked_list) 
fast_pointer = linked_list.first 
half_pointer = linked_list.head
while (fast_pointer != null)
      fast_pointer.next
      fast_pointer.next
      half_pointer.next
end 
```

### [](#finding-the-sum-with-a-hash-table)用哈希表求总和

给定一个数字列表，找出其和是一个选定数字的一对数字。

在下面的列表中找出总和为 12 的数字:

2, 5, 8, 6, -3, 14, 4, 1, 3, 12

根据与上述算法类似的理论，如果我们记住潜在的答案，我们可以很快解决这个问题。例如，第一个数字是 2，这意味着如果我们在列表中找到 10，我们可以安全地忽略列表中的任何剩余数字，因为我们已经找到了答案。最终，我们将达到 4，并意识到我们已经有了 8，从而完成了求和。

这个问题的关键是如何比较我们已经找到的潜在答案和我们当前的数字。如果我们将可能的答案存储在一个数组中，那么我们实际上并没有节省任何时间，因为我们将对原始数组中的每个数字检查一次数组。相反，我们必须使用哈希表。

哈希表是一种特殊的数据结构。与数组不同，遍历一个散列代价很高，但是检查一个特定的值非常快。要解决这个问题，我们只需检查当前数字是否已经存在于潜在答案的散列中，如果不存在，则将下一个潜在答案添加到散列中。

```
Find_sum(array, sum)
potential_answers = {}
For each num in num_array
      if (potential_answers[num] == true) { return [num, sum-num] }
      else{ potential_ansers[sum-num] = true }
end 
```