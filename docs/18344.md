# 书评:神话中的人月(1995)

> 原文:[https://dev . to/awwsmm/book-review-the mythic-man-month-1995-1 hpn](https://dev.to/awwsmm/book-review-the-mythical-man-month-1995-1hpn)

*注:以下所有页码均为该书的 Kindle 版本。*

这本书一开始绝对是痛苦的。20 周年纪念版(1995)没有更新任何参考资料(很明显),因为这是作者在开发大型软件项目中学到的东西的回顾。不幸的是，对于我们这些生活在 21 世纪的人来说，那个软件项目是 IBM 的 [OS/360](https://en.wikipedia.org/wiki/OS/360_and_successors) 的开发。准备好迎接缩微胶片、汽车中的“地图灯”等令人兴奋的讨论吧。“结构化编程”是作为“另一套重要的新思想”引入的(146)。我在读这本书的时候做了笔记，有一次，我写道:

> *因老化不良基本不可读*

这里有几个引语来说明我的观点。

> 如果需要一台独立的机器，那是一件相当奇特的事情——它不需要很快，但至少需要一百万字节的主存储器、一亿字节的联机磁盘和终端。只需要字母数字终端，但它们必须比打字机每秒 15 个字符的速度快得多。 (132)
> 
> *“系统编程应该用什么高级语言？今天唯一合理的候选人是 [PL/I](https://en.wikipedia.org/wiki/PL/I) 。”* (138)
> 
> “我确信在许多应用中，交互系统永远不会取代批处理系统。” (139)

一个特别恶劣的例子是作者建议在程序的源代码中添加注释，但不要太多，因为这会显著增加程序在磁盘上的大小(177)。(我想这在技术上是正确的，但在现代计算机上不再是一个问题。)作者还建议用箭头代替文字来说明程序流程:

[![](../Images/7df3f4fce471913c2bb572b6914f4134.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--ian7-uCo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/iff7ff6k3fi7bizman7w.png)

我很难想象有哪一条建议会让程序可读性更差、更加混乱。所以，并不是这本书里的所有东西都保存得很好。

...也就是说，一旦你努力读完了前几章，这本书确实有一些好的建议。我将在这里列出我发现的最有用的主题。

## 创建可理解的代码是困难的，但是必要的

“数据处理的基本原理告诉我们试图保持独立文件同步是多么愚蠢”(171)。作者建议不要将文档和代码分开，而是提倡源代码文件本身应该包含代码的散文式解释。他称之为“自我记录的程序”，我们今天称之为“良好注释的代码”。确保你解释了任何不能自我解释的代码。

> 作为一个主要目标，我们必须尽量减少文件的负担，这个负担是我们和我们的前辈都无法成功承担的 (172)

为此，作者建议我们“使用程序中无论如何都必须存在的部分”:使用空格和括号来格式化代码，澄清范围，等等。给你的变量、方法和类起一个合理的、不言自明的名字。“展示，不要说”让阅读和写作变得不那么痛苦。

不要多此一举。“尽可能参考标准文献来记录基本算法”(176)，而不是“自己动手”。如果您必须从一个大的包中提取一个算法以避免导入整个包，那么就这样做。只需参考原始来源，以便以后需要时可以找到它。

不要怕太啰嗦。如果有一点代码不清楚，就写一行注释。如果一个部分或算法需要解释，写一段:**“使用行注释或备注任何不明显的东西”(176)。太明确远比太模糊好。**你未来的自己，回到那些评论，会心存感激。

## 编程是一项天生的智力挑战

这本书的一个中心论点是，一旦编程的所有附带挑战都被自动内存和文件管理、富有表现力的高级语言、广泛可用的算法和数据结构等所克服或抽象掉，那么程序员还剩下什么挑战呢？剩下的只是简单地用一种机器可以解释的方式来表达要解决的问题。换句话说:

> “表现是编程的本质。” (110)

在 2019 年，编程最难的部分不是学习语法或管理资源或任何低级的东西，真的。它能够完整而明确地表达你希望解决的问题，这样机器就可以帮助你找到解决方案。当然，集合、类和 lambdas 可能*帮助*你表达问题，也许是以一种不太容易出错或者更全面的方式，但是它们*不会替你做工作*。他们只是工具。作为程序员，使用这些工具进行创作仍然取决于您。

> “我们可以用任何工具编写好的或坏的程序。除非我们教人们如何设计，否则语言没什么意义。” (221)

## [](#software-development-is-complex)软件(开发)复杂

我在高中有一个老师，他总是说“重复是你的朋友”。她的意思是，人类需要看到概念和想法被重复，有时以不同的方式重复，以便充分理解和吸收它们。机器不需要这个。如果你写了一次函数或者类定义，你就不需要再写了。

> 软件实体在规模上可能比任何其他人类构造都要复杂，因为没有两个部分是相同的(至少在语句层面上是如此)。如果它们是，我们就把这两个相似的部分变成一个子程序……” (183)

许多软件开发人员信奉的枯燥(不要重复自己)的咒语促进了这样一种思想，即经常使用的代码块应该封装在易于调用、调试和记录的方法中，而不是在代码中一遍又一遍地复制和粘贴这些代码行。以这种方式组织的代码绝不会重复任何大于一个语句或一行的内容。[信息论](https://dev.to/awwsmm/a-primer-on-data-compression-46c2)说这种代码最大熵。通过尽可能少地重复代码，我们最大化了代码的“信息密度”。

这意味着“好的”代码，根据定义，*尽可能的复杂。我在这里使用“复杂”一词，并不是指“令人困惑”或“混淆”，也不是指代码具有难以理解的语法。我的意思是，没有一段代码是重复的，所有的东西都是独一无二的，所有的东西都携带着新的和不同于以前的信息。制作好的软件必然意味着制作复杂的软件:*

> *...软件实体的升级不仅仅是相同元素在更大尺寸上的重复；它必然是不同元素数量的增加。在大多数情况下，这些元素以某种非线性方式相互作用，整体的复杂性比线性增加得多。”* (184)

因此，实现程序员效率的显著提高就是使用更少的代码行表达复杂的关系和对象变得更容易。不是更好或更快的编辑器，不是新的语法或框架或语言*本身*，而是用那些框架和语言以更容易、更不容易出错的方式表达更高级概念的能力。*那个*是未来提高程序员效率的东西。

## [](#maintaining-conceptual-integrity)保持概念的完整性

软件项目，就像团队一样，随着规模的增加，复杂性也呈超线性增长。一个程序的规模翻倍，增加了一个比 2 大得多的因素，即 API 可以被使用、滥用和连接到其他包的方式的数量。类似地，一个 4 人的团队在其成员中有 9 个可能的沟通渠道(2 人或更多人的独特子团队)。一个 8 人的团队有 49 人。一支 16225 人的队伍。复杂性呈二次方增加。

当一个项目由一个人构建时，维护概念的完整性相对容易。只有一个人需要确保代码的格式是统一的，文档使用相同的措辞，UI 是一致的，等等。当一个项目团队只有两个人时，沟通对于保持整个项目的一致性是必不可少的。因此团队之间的交流对于保持概念的完整性是至关重要的。

在本书的早期，作者推荐了一个开发团队的彻底重新设计，对于只有几个人的项目——外科医生的团队。在这个项目结构中，只有一个人负责项目的概念远景。这个人，“外科医生”，做结构和设计工作，而另一个熟练的程序员通过构建二级代码来提供帮助:低级子例程、后端数据管理框架等等。外科医生可以自由地专注于她的项目“愿景”,而其他人则支持和帮助外科医生。

当然，这对于大多数团队来说是行不通的(尽管作者有所推荐)，尤其是大型团队，其中一个“有远见的人”无法处理所有要求他们做的工作。因此，应该尽可能地记录和解释设计决策，以便参与项目的每个人都可以参考它们。正如我之前所说，过于明确总比过于模糊好。

> *“准备这一小组中的每一份文件都是为了集中思想和明确讨论。写作这一行为需要数百个小决策，正是这些小决策的存在，将清晰、准确的政策与模糊的政策区分开来。”* (240)

但是没有必要让每个人都知道 T2 关于这个项目的所有事情。事实上，如果尽可能地遵循德米特的[定律(或“最少知识原则”)](https://en.wikipedia.org/wiki/Law_of_Demeter)，那就更好了:

> *...大家看到一切的目标*完全错了；*部件应该被封装，这样任何人都不需要或者不被允许看到除了他自己以外的任何部件的内部，而应该只看到接口。”* (236)

换句话说，你不需要知道*一个子程序是如何工作的*，只要知道它是如何工作的就行了。您应该关注函数的输入和输出，而不是它在内部做什么。这增加了代码的可重用性和模块化。

## [](#grow-dont-build)长不大，长不大

虽然传统的“瀑布式”软件开发方法贯穿全书，但作者在 20 周年纪念版中承认了这一点，并或多或少为此道歉(265)。时代在变化，在不到 80 年的时间里，软件开发的发展可能比文明史上任何其他行业都要快。

事后看来，作者现在推荐了一个更敏捷的框架:首先构建一个不做*任何事情*的端到端系统——它只是以正确的顺序调用正确的子例程。然后，一次建立一个子程序，测试，清洗，重复。这样，你将*总是*拥有一个可以被用户不断测试的工作系统(尽管功能有限)( 202)。

> 士气的影响是惊人的。当有一个运行系统时，即使是一个简单的系统，热情也会高涨。” (202)

除了“成长”软件，我们还应该成长伟大的软件开发者。如今，很少有公司习惯于努力从全新的开发人员开始，并将他们培养成经验丰富的优秀开发人员。神话中的人月为这一过程提供了一些提示:

> *“尽早系统地确定顶级设计师。最好的往往不是最有经验的。指派一名职业导师负责潜在客户的发展，并仔细保存职业档案。设计和维护职业发展计划...包括精心挑选的顶级设计师学徒，高级正规教育的插曲，以及短期课程，所有这些都穿插着个人设计和技术领导任务。”* (204)

作为一名经理，与其说你的职责是培养顶尖人才，不如说你的职责是让 T2 允许他们自己发展。提供空间，为团队聚餐和会议提供便利，照顾好工作中所有平凡的方面，这样你的明星开发人员就可以继续开发工作了。但最重要的是，避免微观管理。允许员工掌控自己的项目，设定自己的截止日期，尽可能管理自己的时间和资源——结果会让你大吃一惊:

> “我再怎么强调授权的重要性也不为过。” (279)

## [](#summary)总结

一开始我非常怀疑，但是在努力读完前 20%左右后，这本书的其余部分充满了很好的建议。我不建议早期职业开发人员使用它，因为它似乎主要面向团队领导。在这本书的几乎每一页都可以找到关于管理团队、维护跨团队的发展项目以及授权员工发挥其最佳水平的技巧。但也许可以跳过前几章。