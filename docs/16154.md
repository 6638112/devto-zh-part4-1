# 你不能从这里到达那里(基于策略的路由)

> 原文:[https://dev . to/rk eene/you-can-t-get-there from here-policy-based-routing-55bh](https://dev.to/rkeene/you-can-t-get-there-from-here-policy-based-routing-55bh)

## [](#which-way-do-i-go-well-you-see-the-problem-is-you-cant-get-there-from-here)我该走哪条路？嗯，你看...问题是...你不能从这里到达那里

在服务器管理过程中，有时需要在多个网络上配置带有网络接口的 UNIX 或 Linux 系统。

从表面上看，这个问题很明显。这可能真的像听起来那么简单，这取决于您在配置网络接口后做了什么。然而，通常在配置网络接口并获得早期成功之后，有进取心的系统管理员会说他们自己“太好了，我现在在这个网络上有了一个地址，现在我希望能够从其他网络到达它！我知道了，我再加一条路线！”他们出发了。

问题是路由，标准路由，仅仅基于数据包的目的地。仔细阅读最后一句话，你会注意到几件事。首先，也是最显而易见的一点是,“目的地”地址被用来决定走哪条路线——这在明明白白地陈述时似乎是显而易见的，但微妙之处往往会被忽略。第二件要注意的事情是，它是*数据包*的目的地——注意，没有其他限定符可以表明该数据包是某个更高级别的流的一部分，因为事实可能并非如此。

你看，当大多数人添加他们认为他们想要的路由时，他们会想到像 TCP 会话或连接这样被跟踪和处理的事情。但那不是这条路线所规定的。

举个例子，假设我们有一台这样启动的机器:

```
server# ifconfig eth0 192.168.5.100 netmask 255.255.255.0 broadcast 192.168.5.255
server# route add default gw 192.168.5.1 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

然后，我们添加第二个网络接口:

```
server# ifconfig eth1 10.230.5.100 netmask 255.255.255.0 broadcast 10.230.5.255 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

然后，从我们的客户端(假设我们有一条通过网络到达 10.230.5.100 的路由)，我们尝试从另一台主机(比如 10.44.11.19)到达 IP 10.230.5.100 上的机器(服务器)。结果可能有所不同，从它的工作，它的工作有时，或根本没有工作。原因在于我们主机的路由表。

当我们将 TCP 会话的数据包从客户端发送到 10.230.5.100 时，它们会选择特定的路径通过网络，最终到达服务器的“eth1”接口。因为数据包与目的地址为 10.230.5.100 的 TCP 套接字相关联，所以返回的数据包将源地址设置为 10.230.5.100。但是，当来自该 TCP 会话的数据包从服务器发送回客户端时，仅使用目的地(10.44.11.19)。因此，数据包将通过默认路由和网络接口“eth0”离开服务器。这可能导致它采用与从客户端到服务器的数据包不同的路径返回客户端。

例如，如果路由器在该接口上不进行反向路径/出口过滤，或者如果一条路径上不存在状态防火墙，而另一条路径上不存在状态防火墙，这可能是没问题的。

这也意味着，如果路由器 192.168.5.1 不可用，您将无法从系统接收数据包(除非您碰巧连接到它所在的广播域)。

这很可能是不受欢迎的行为。

为了纠正这一点，有事业心的管理员可能会做类似于以下的事情:

```
server# route add default gw 10.230.5.1 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

并且认为，因为他们通过“eth1”添加了第二个默认网关，所以如果数据包的 IP 源地址为“eth1 ”,它们将开始从该接口发出。但这是错误的。同样，正常路由仅基于数据包的目的地址。此外，路由条目是按照从最特定到最不特定的顺序处理的，因此现在数据包可能会随机地通过“eth0”或“eth1”离开系统(这确实是 Solaris 上发生的情况)。

那么我们如何解决这个问题呢？我们如何让数据包做我们想做的事情？嗯，首先我们必须定义这个问题。到目前为止，我们只定义了症状和当前行为。

问题是数据包从“错误的”接口发出。我们如何定义哪个接口是正确的接口？很简单——正确的接口是带有数据包源地址 IP 的接口。从这个角度看，我们可以看到，我们希望我们的路由是基于源的，而不是基于目的地的。这是通过使用基于[策略的路由](http://en.wikipedia.org/wiki/Policy-based_routing)技术实现的。

那么，如何实际实现这种基于策略的路由(“PBR”)？这取决于平台。在 Linux 上，可以使用 IP 高级路由功能，在 Solaris 上，可以使用“ipf”。

要在 Linux 上使用 PBR 实现上面的示例，首先我们要删除刚刚添加的无关默认路由条目，因为它没有实现我们想要的策略:

```
server# route del default gw 10.230.5.1 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

Linux 高级路由处理基于策略的路由的方式是通过使用多个路由表。这允许配置非常灵活但定义非常明确的路由。

然而，仅仅创建额外的路由表是不够的，因为我们实际上需要告诉 Linux 路由系统何时使用哪个路由表。这是有规则的。

此外，我们不能简单地删除“主”路由表中的“默认网关”条目(“route”命令操纵的路由表路由的默认名称),因为它用于确定在创建没有明确指定源的套接字时要使用的源 IP 地址。

好了，我们有了两个概念:路由表(我们可以有几个)和规则条目(我们也可以有几个)。为了将配置更改实际传递给系统，我们使用“ip”命令，它是 Linux IP 高级路由系统的一部分，由 iproute2 包提供。

首先，我们创建新的路由表。路由表由一个数字标识(为了方便起见，名称可以与这些数字相关联，但为了清楚起见，这里我们只使用数字)。要做到这一点，我们应该这样做:

```
server# echo "Configuring eth0"
server# ip route add 192.168.5.0/24 dev eth0 table 100
server# ip route add default via 192.168.5.1 table 100
server# echo "Configuring eth1"
server# ip route add 10.230.5.0/24 dev eth1 table 101
server# ip route add default via 10.230.5.1 table 101 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

第二，我们创造自己的规则。我们的规则执行我们的政策。我们的策略是根据源地址对路由进行分类。因此，我们的规则应该是这样的:

```
server# ip rule add from 192.168.5.100 table 100
server# ip rule add from 10.230.5.100 table 101 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

然后，我们可以使用“ip route get”命令来验证我们的路由是否被使用:

```
server# ip route get 4.4.4.4 from 192.168.5.100
4.4.4.4 from 192.168.5.100 via 192.168.5.1 dev eth0
    cache   mtu 1500 advmss 1460
server# ip route get 4.4.4.4 from 10.230.5.100
4.4.4.4 from 10.230.5.100 via 10.230.5.1 dev eth1
    cache   mtu 1500 advmss 1460 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

成功了。

万岁。