# C#值类型和引用类型

> 原文:[https://dev . to/daneb/do-you-really-grok-value-and-reference-types-eck](https://dev.to/daneb/do-you-really-grok-value-and-reference-types-eck)

**价值**和**参考**类型在互联网上、博客帖子、技术文章和论坛中频繁出现。为什么？因为很容易长时间开发软件而没有停下来‘闻一闻玫瑰花’。或者在这种情况下，理解它们是什么以及它们是如何工作的。所以这是给 self 或者你的一个提示。

> 一个**值类型**是信息本身的某个对象。
> 
> **引用类型**是指向包含信息的对象的细节。细节包括物体的类型等。

## [](#an-analogy)打个比方:

让我们打个比方。金姆刚刚写了一本书。这是一本自动传记。她希望得到反馈，所以她在家打印了一份，交给了她的丈夫 Kanya。那天晚些时候，她偶然遇到一位公关人员，这位公关人员很感兴趣，并要求阅读这本书。她打开 Macbook，通过 Google Drive 分享了原文的链接。

公关久而久之反馈，并被彻底打动。她强调了一系列拼写错误，并考虑重写第四章。金立即开始工作，几天后就完成了。更新原文，并要求公关审查她的变化。

那么这与值类型和引用类型有什么关系呢？
嗯，当时金姆制作了坎耶原作的实物复制品。她向他提供了真相的独立版本。事实上，在她与公关人员接触期间发生了所有变化之后，Kanya 的副本现在已经过时了。他有一个**值类型**。源的独立副本，它是独立的，对源的修改漠不关心。

另一方面，公关人员，她有一个 Google Drive 的 URL，一个对原文的引用。事实上，随着金做出改变，公关人员可以实时看到这些变化。**引用**提供了对原件的访问，但不是原件。

## [](#some-examples)一些例子

*   数组类型是引用类型，即使元素类型是值类型(因此 int[]仍然是引用类型，即使 **int** 是值类型)
*   枚举是值类型。
*   委托是引用类型。
*   接口是引用类型，但它们可以作为值来实现。

## [](#stack-vs-heap)栈 vs 堆

> 引用类型存在于堆中。值类型存在于它们声明的地方。
> 局部变量和方法参数存在于堆栈中。

堆栈是一个简单的 FIFO 存储结构。当一个方法被调用时，CLR 在栈顶做书签标记。然后，该方法在执行时将数据推送到堆栈上。当该方法完成时，CLR 只是将堆栈重置为它以前的书签。

### [](#stack-offers)堆叠报价:

*   非常快速的访问
*   CPU 有效管理空间，内存不会碎片化
*   仅局部变量
*   内存大小的限制

一个**堆**是一堆随机混杂的对象，不会自动为您管理。它是一个自由浮动的内存区域(也更大)。在多线程应用中，每个线程都有自己的堆栈。但是所有不同的线程将共享这个堆。

### [](#heap-offers)堆盘:

*   变量可以全局访问
*   内存大小没有限制
*   (相对)较慢的访问

值得注意的是，值类型存在于它被声明的地方，所以如果你有一个实例变量为 float 的类，值类型。它将存在于对象的剩余部分所在的位置，也就是堆上。

最后一点，C#中的字符串是引用类型。为什么？因为字符串可能会变得很大，因此必须存储在堆中。

## [](#references)参考文献

1.  [C-vegit bit 中的引用类型和值类型](https://vegibit.com/reference-types-and-value-types-in-c/)
2.  深度 C 号——乔恩·斯基特
3.  [值与引用类型-约瑟夫·阿尔巴哈里](http://www.albahari.com/valuevsreftypes.aspx)
4.  [栈和堆的区别](https://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/)