# 编的！清晰的词汇表

> 原文:[https://dev . to/code mouse 92/compiled-an-ub obfuscated-glossary-2 oco](https://dev.to/codemouse92/compiled-an-ubobfuscated-glossary-2oco)

已解释。已编译。组装好了。链接器。字节码。机器代码。汇编语言。

***GAAAH！*T3】**

围绕建筑和运输的术语已经变得如此复杂，令人心痛！术语被误解和误用。新的工艺被发明出来，旧的术语被重新使用来描述它们。一个团体认为有必要通过给另一种语言贴上“翻译”的标签来贬低它。另一组人改变术语的含义，试图“捍卫”他们最喜欢的语言，哪怕只是对他们自己。

伙计们，外面是丛林。

最近我参与了很多关于这个的谈话。来源这些和更多的研究可能是健康的一天，这里有一个关于构建和部署软件的术语的**不模糊的词汇表**。

(P.S .我这里不涉及 web 开发。)

# [](#a-disclaimer)免责声明

不应该*永远不要*认为语言 A 比语言 b 更好或更差。没有一种正确的方式来发布项目。

真正的程序员写代码。我不想听到*一个关于“蝴蝶”的字*。；-)

# [](#updates)更新

这意味着是一个生活岗位。当我发现更多的术语需要定义时，我会添加它们。我还将努力保持现有定义的更新。

**如果有什么建议或者技术上的修正，请留下评论。如果可能的话，我会很感激你的更正。**

# [](#the-glossary)词汇表

## [](#abi-application-binary-interface)ABI【应用二进制接口】

一个*接口*允许一个*二进制文件*与另一个二进制文件交互。如果用户正在执行的二进制程序正在与操作系统交互，那么它正在使用 ABI。

## [](#api-application-programming-interface)API【应用编程接口】

一个*接口*，允许一个*项目*的代码与另一个*程序*或*库*(或其他代码单元)交互。API 通常在编写源代码时使用。

(对比 *ABI* 。)

## [](#architecture)建筑

官方称为**指令集架构**或 **ISA** ，这是一组特定的 *CPU* 使用的*机器码*指令。

*架构*是指抽象指令集，而*机器码*是实际的具体指令集本身。

AMD64 是 ISA 的一个例子，而 Intel 64 位微处理器和 AMD 64 位微处理器可能以不同的方式实现这些功能。

## [](#archive)存档

一种文件格式，其中多个文件被打包成一个文件，通常使用某种形式的压缩算法来减小文件大小。

例子:`*.tar.gz`、`*.exe`、`*.deb`、`*.dmg`。

## [](#assemble-assembling-assembled)组装(正在组装，已组装)

“编译”一个*汇编语言*到*机器码*的官方术语。(另见，*汇编器*。)

## [](#aot-aheadoftime-compiler)AOT【超前】编译器

一个*编译器*，在代码执行之前，*将*(通常是*汇编*)编译成*机器码*。

(对比*汇编器*，*编译器*，*解释器*， *JIT 编译器*。)

## [](#assembled-language)汇编语言

由*编译*和*汇编*成*二进制可执行文件*(由*机器码*组成)的编程语言，然后被发送给最终用户。

示例:C、C++、Ada、COBOL、FORTRAN

非示例:Java、Python

传统上(和学术上)，这实际上被称为*编译语言，*但是由于对*编译的*的现代、普通含义的混淆，我创造了这个术语来混淆其含义。

术语“汇编语言”来源于*汇编器*和*汇编器*。

(另见，*编译语言*；对比*汇编语言*。)

## [](#assembler)汇编程序

负责将和*汇编语言*组装成*机器码*的工具。

## [](#assembler-language)汇编语言

(参见*装配代码*)

## [](#assembly-code)汇编代码

(参见*汇编语言*)

## [](#assembly-language)汇编语言

一种将机器代码抽象成人类可读的基于文本的命令的编程语言。通常每种*机器语言*都有一种汇编语言。

示例:X86、X64、ARM

## [](#binary)双星

{1}仅由数字`0`和`1`组成的数字系统(基数/基数)。

{2}一个被编译成*机器码*的*可执行* *程序*或*库*，包含在*二进制文件*中。

## [](#binary-file)二进制文件

包含以*二进制*编码的*机器码*的文件。

## [](#bundled)捆绑

将多个文件打包在一起，通常打包成一个*档案*，这样它们可以更容易地一起移动(分发)或执行。

例如，有时*字节码*和它的*解释器*捆绑成一个单独的*可执行文件*，然后发送给最终用户。

## [](#bytecode)字节码

表面上看起来类似于汇编语言的代码，但是被优化为由 T2 解释器处理。

许多*解释语言*将*编译*从*源代码*到*字节码*，然后或者在*档案*中，或者在*中与相应的解释器捆绑*发送给最终用户。

## [](#compile-compiling-compiled)编译(编译，编译)

把一种形式的代码翻译成另一种形式。可以编译成*字节码*、*目标码*、*汇编码*，或者*机器码*。

在学术上，这应该是指编译成*机器码*，但这种区别几乎完全消失在常识中；当提到生产机器代码时，应该优先使用术语*装配*。

没有人能从一种*语言*的*源代码*中“编译”出另一种语言！这叫做*传送*。

(对比*汇编*、*词法分析*、*解析*、*trans file*；另见，*编译语言，*编译器*。)

## [](#compiletime)编译时

在执行程序之前，在*编译*(或*汇编*)期间执行的一个动作。

如果一个动作是作为 *AOT 编译*或 *JIT 编译*的一部分来执行的，它被称为“提前[AOT]”或“即时[JIT]”，而*从来不是*“编译时”。

## [](#compiled-language)编译语言

任何语言在发布前都要经过编译。按照现代的用法，这可能意味着许多事情。

*   Java 是一种编译语言，因为它被编译成*字节码*，这是后来*在*目标机*上组装*成*机器码*。

*   Python 是一种编译语言，因为它在执行之前被编译成字节码。

*   C++是编译语言，因为它是编译成*机器码*的。

传统上，这与*汇编语言*有相同的定义，但是由于*编译*定义的变化，这有了新的含义。

这个术语不能用于任何一种仅仅由另一种语言翻译而来的语言。

示例:C、C++、Java、Python

非示例:Bash

(对比*汇编语言*，*trans pile*；另见，*编译*，*解释语言*，*交互语言*。)

## [](#compiler)编译器

一个负责*编译*的工具。不要和*装配工*混淆。

这个术语通常指运行在开发者机器上的编译器，与运行在目标机器上的 *AOT 编译器*或 *JIT 编译器*形成对比。

该术语有时会与*工具链*混淆。

(对比*汇编器*、*链接器*、*解释器*、*工具链*；参见， *AOT 编译器*， *JIT 编译器*。)

## [](#cpu-central-processing-unit)CPU【中央处理器】

负责执行由*机器码*提供的指令的计算机硬件。参见，*微处理器*。

## [](#dependency)依赖关系

一个独立的代码单元，通常是一个*项目*所依赖的*库*。

一种语言对依赖关系的处理**与它是*汇编语言*、*编译语言*、*解释语言*、*交互语言*还是*脚本语言*没有关系**。

(参见*动态链接*、*标准库*、*静态链接*。)

## [](#disassembler)拆卸器

将*二进制文件*转换成*汇编代码*的工具。

## [](#deployment-environment)部署环境

运行*项目*的硬件(或虚拟硬件)、系统和运行时环境。有多种部署环境:

*   开发环境，开发*项目*的地方(比如程序员的个人电脑。

*   测试环境，它是为项目的健壮、受控测试而设计的。

*   试运行环境，旨在模拟生产环境，但用于发货前的最终测试。

*   成品项目运行的生产环境。这可能是面向公众的 web 服务器(用于 web 部署)，或者是最终用户计算机(在这种情况下，您将拥有多个不同的生产环境。)

## [](#dynamic-program-analysis)动态程序分析

在受监控、修改、控制或仿真的*环境*中，通过执行*程序*对其进行分析，通常是以最终编译或汇编的形式。

内存错误检测器、并发错误检测器、安全分析器和代码覆盖工具经常使用动态程序分析。

(对比*静态程序分析*。)

## [](#dynamic-analysers)动态分析仪

一个使用动态程序分析的工具。

(对比*静态分析仪*。)

## [](#dynamicallylinked)动态链接

在*运行时*解析*依赖*。这要求依赖关系对*目标机器*可用(通常以其发货形式)。

(对比*静态链接*；参见，*标准库*。)

## [](#environment)环境

(参见*部署环境*和*运行环境*。)

## [](#execute-executing-executed)执行(正在执行，已执行)

在目标系统上运行*可执行文件*。

在*二进制文件* / *机器码*的情况下，这叫做*加载*。

在使用*解释语言*的情况下，这可能涉及许多不同的步骤，包括调用 *AOT 编译器*、*解释器*或 *JIT 编译器*。

在*档案*的情况下，该步骤还可能涉及以某种方式解包档案，例如解包到临时目录或内存中。

(另见，*可执行*、*加载器*、*程序*。)

## [](#executable)可执行

配置为作为*程序*直接运行(*执行*)的文件，特别是由*目标系统*上的最终用户运行。这可能是一个*档案*，一个*二进制文件*，或者一个修改过的*源代码*文件，该文件为运行时环境提供了关于如何调用必要的*解释器*的指令。

## [](#grammar)语法

编程语言的源代码文本应该如何构造的一组规则。语法定义了语言的*语法*。

## [](#implementation)实现

一般来说，“事情是如何完成的。”你可以有一个抽象的想法或一套规则，但有许多实现。

例如，你可以有一种编程语言*(比如 Python)，但是你可以用许多不同的方式(CPython、PyPy、IronPython)构建这种语言的工作版本。*

 *## [](#interface)界面

一般来说，接口是两个事物相互作用的明确定义的方式。一个事物的*实现*被接口抽象，因此改变实现不会(不应该)以任何方式改变接口。

ABI 和 T2【API 就是两个实际例子。

## [](#interpreted-language)解释语言

一种语言，其发布的文件要么是*源代码*要么是*字节码*，并且要么(a)由*解释器(传统)*或*虚拟机*在*目标机器*上直接*执行，要么(b)只在*目标机器*上执行*汇编的*到*机器码*。

一些解释语言在目标机器上使用 *AOT 编译器*或 *JIT 编译器*。其他语言使用*解释器(繁体)*直接执行代码，不存储机器码。通常，这归结于*实现*细节；对最终用户来说，差别不大。

解释语言要么以*源代码*的形式发布，要么以*字节码*的形式发布，并且需要一个*解释器*或*虚拟机*要么发布给最终用户(要么是*独立*或*捆绑*)，要么预安装在机器上。

例子:Java，Python，Javascript，Ruby，Perl。

(对比*汇编语言*；参见*编译语言*，*交互语言。)

## [](#interpreter)解释器

作为与*解释语言*相关的通用术语，可以实现或包括 *AOT 编译器*、*解释器(繁体)*、 *JIT 编译器*、 *REPL 外壳*或*虚拟机*。

从广义上来说，这是必须安装在目标机器上的软件，它负责最终执行发送给最终用户的*字节码*或*源代码*。尽可能使用更具体的术语。

(对比*解释器(繁体)*， *REPL 外壳*；又见，*释文*。

## [](#interpreter-traditional)解释器(繁体)

一个处理*源代码*或*字节码*并直接在*目标机*上执行的计算机程序，无需先*编译* / *汇编*成*机器码*。

(对比 *AOT 编译器*、*解释器*、 *JIT 编译器*、*虚拟机*。)

## [](#interactive-language)互动语言

一种主要在*交互式外壳*环境中使用、执行和解释的语言。

这是我创造的另一个术语，用来区分“解释语言”的组成部分，它有助于区分主要通过*解释器(传统的*和*交互外壳*)使用的语言，以及通过 *AOT 编译器*或 *JIT 编译器*使用的语言。

示例:Bash、Python

(对比*解释语言*。)

## [](#interactive-shell)交互外壳

一个外壳包裹着一个*解释器(繁体)*，用来直接执行*源代码*，或者按需执行一个包含*源代码*的文件。

## JIT 编译器

一个*编译器*，当代码被执行时，*将*(通常是*汇编*)编译成*机器码*，通常是一行一行。

(对比 *AOT 编译器*、*汇编器*、*编译器*、*解释器*。)

## [](#language-programming-language)语言(编程语言)

可以用来编写计算机代码的一套具体的规则(*语法*、*句法*、*语义*)。

一个*语言*可以有多个*实现*。

## [](#lexer)雷克塞

执行*词法分析*的工具。这通常是*编译器*或*解释器*的一部分。

## [](#lexical-analysis-lex-lexed-lexing)词法分析(Lex，Lexed，Lexing)

一串文本，如*源代码*，被分解成*令牌*以被*解析*的过程。

这之后通常是*句法分析*。

(另见，*语义分析*，*句法分析*。)

(对比*解析*；参见，*词汇*，*语法*。)

## [](#library)库

一个独立的，通常是由*编译的*代码集合，只打算用作*的依赖*。

在*汇编语言*中，一个库可以是*静态链接*或*动态链接*。在*解释语言*中，一个库可以以多种方式被解析为一个依赖关系。

一个库通常有一个定义好的 *API* 。

## [](#linter)棉绒

一个*静态分析器*，它检查*源代码*中的错误和错误。

## [左](#linker)

负责*链接*的工具。*工具链*的一部分。

## [](#linking)链接

*依赖*的解析，尤其是作为*编译*过程的一部分。

## [](#loader)装载机

执行*加载*机器码*的*到内存执行的工具。

## [](#loading)装载

CPU 将*机器码*加载到*目标系统*内存供*执行*的过程。

## [](#machine-code)机器代码

由 CPU 直接执行的**指令集**。这完全由数字代码组成，通常以*二进制*编码。(另见，*建筑*；对照*装配代码*。)

## [](#machine-language)机器语言

(参见*机器代码*；参见*建筑*。)

## [](#microprocessor)微处理器

作为单个集成电路(我们通常称之为“芯片”)或几个相连的集成电路存在的*中央处理器*。大多数现代计算机都有微处理器。(参见， *CPU* 。)

## [](#object-code)对象代码

尚未被*链接器*链接到其*依赖关系*的*机器码*。

(另见，*机器代码*；对比*字节码*。)

## [](#operating-system)操作系统

本质上是一个*程序*的集合，其中大部分在*机器码*中，它管理和运行特定机器上的计算机硬件和软件。一个操作系统也提供多个*ABI*来允许与它交互，从而与它管理的硬件和软件交互。

(另见，*运行时*；对比*虚拟机*。)

## [](#optimization)优化

提高代码运行效率的过程。这可以由程序员手动完成，尤其是对*源代码*，或者由任意数量的工具自动完成，对任意形式的代码。

## [](#optimizer)优化器

一个执行*优化*的工具，特别是对*字节码*、*目标码*，或者(偶尔)*机器码*。

## [](#package-noun)包{名词}

包含单个*项目*的文件集合，有时(尽管不总是)与执行项目的工具捆绑在一起；然而，一个包很少包含它的*依赖*。

一个包通常采用*档案*的形式。

## [](#package-packaging-packaged-verb)包(打包，打包){动词}

一个*项目*准备作为*包*分发给最终用户的过程。

## [](#parse)解析

(见*句法分析*。)

## [](#parser)解析器

一个执行*语法分析*(也称为*解析*的工具。

## [](#processor)处理器

见 *CPU* 。

## [](#preprocessor)预处理器

一个以各种方式转换*源代码*的工具，为*编译*做准备。不同的语言可能有也可能没有这个工具，它可能执行多种功能。

这通常是在支持这些特性的语言中处理宏和“包含”指令的工具。

## [](#program)程序

一个*项目*的完整*可执行文件*最终结果，尤其是交付给最终用户时。可能有外部*依赖*。在*解释语言*的情况下，也可能是*捆绑*。

与*库*相反，程序通常旨在与用户交互。

## [](#project)项目

将作为单个*程序*或*库*发布的*源代码*的完整主体。

这个术语主要是为了清楚起见。这也可以称为“解决方案”。

## [](#repl-readevaluateprint-loop-shell)REPL(读取-评估-打印循环)外壳

见*交互外壳*。

## [](#runtime)运行期

在*目标系统*上*执行*时发生。

(对比 *AOT* 、*编译时间*、*JIT*；参见*运行时环境*。)

## [](#runtime-environment-runtime-system)运行时环境(Runtime System)

提供给正在执行的*程序*的环境。在非学术性的、简化的意义上，这是程序可以“看到”的一切，包括*API*、*依赖*、*接口*(包括那些由*操作系统*、*库*和其他*程序*提供的接口)。

(另见，*部署环境*，*操作系统*，*虚拟环境*。)

## [](#scripting-language)脚本语言

传统上指的是一种只在特殊运行时环境中使用的语言。

通常，脚本语言*不是*用于编写独立的项目，而是为另一个程序提供运行时指令。然而，这种区别是模糊的，难以确定。

示例:ActionScript、BASH、FraggleScript、VBScript。

非举例:Python、Java、Ruby、Javascript(这些是*解释的*语言，而不是*脚本*语言；同样，区分是困难的。)

**注:**不幸的是，这个术语在常识中几乎完全失去了它的定义，并且通常被不恰当地替换为*口译语言*。在文化上，这个术语通常用来表示“不是真正的编程语言”，因此已经成为不喜欢的语言的贬义词。因此，在可能的情况下，最好使用更具体的术语。

(另见，*交互语言*；对比*的口译语言*。)

## [](#semantics)语义

在编程语言中，*语法*在计算上代表什么，以及它如何表现。

换句话说，*句法*是结构，而*语义*是意义。

运行时错误和警告通常是由语义错误引起的。

(对比*语法*。)

## [](#semantic-analyser)语义分析器

执行*语义分析*的工具。

## [](#semantic-analysis)语义分析

检查由*语法分析器*生成的“解析树”的实际含义(*语义*)的过程。

这通常是*编译器*或*解释器*的一部分。

(另见，*句法分析*，*词法分析*。)

## [](#shell)外壳

通过基于文本的实时输入和输出与用户交互的*程序*。

见*交互外壳*。

## [](#source-code)源代码

遵循特定编程语言*的*、*语法*和*语义*编写的文本文件。

(对比*字节码*，*机器码*；参见，*汇编代码*。)

## [](#static-analyser)静态分析仪

执行*静态程序分析*的工具。

## [](#static-program-analysis)静态程序分析

出于各种目的自动分析*源代码*的过程，包括检测错误、bug、低效或与特定编程标准或风格指南的不一致。

(另见，*棉绒*；对比*动态程序分析*。)

## [](#standalone)单机

可独立执行，尤其是不需要外部*依赖*或在*运行时环境*中可用的额外工具或程序。

(对比*捆绑*。)

## [](#standard-library)标准库

由大多数或所有用特定编程语言编写的*项目*使用的*库*。标准库通常作为一个*动态链接库*发布，尽管在某些情况下，它可能包含在*解释器*中，或者在更罕见的情况下，静态链接*到使用它的二进制文件中。*

(另见，*依赖*，*库*。)

## [](#staticallylinked)静态链接

在*编译时*解析*依赖*。这意味着**而不是**的依赖关系不需要在*目标机器*上以某种其他形式可用；依赖项的*机器码*包含在使用它的*项目*的*机器码*中。

(对比*静态链接*；参见，*标准库*。)

## [](#syntax)语法

组成编程语言的*源代码*的*标记*，以及它们应该出现的顺序，如*语法*所定义的。

编译时的错误和警告通常是由语法错误引起的。

(对比*语义*；*亦见，语法*。)

## [](#syntactic-analysis)句法分析

对照*语言*的*语法*(或*语法*)规则，验证*词法分析*输出的*标记*(或“标记流”)的过程。

通常，这一步包括构建一个“解析树”，它更容易编译，特别是对于*字节码*或*机器码*。

这通常是*编译器*或*解释器*的一部分。

在这一步之后(通常)是语义分析。

(另见，*词法分析*，*语义分析*。)

## [](#target-machine)目标机器

正在执行完成代码的物理计算机；通常，这是最终用户运行附带软件的计算机。

## [](#token)令牌

编程语言*中的一个意义单位*，由该语言的*语法*和*句法*定义。包括符号和关键字。

(另见，*词法分析*，*语法*，*句法*。)

## [](#tokenization)标记化

(参见*词法分析*。)

## [](#transpile)运输文件

将从一种编程语言编译成另一种。这在技术上是这种情况的正确术语；这个语境中的“编译”是错误的。

例如，Typescript 被*转换*为 Javascript。

从不编译**涉及编译成*字节码*、*汇编代码*、*目标代码*或*机器码*。**

 **(另见，*汇编*，*编译*。)

## [](#toolchain)工具链

将*源代码*转换成*机器码*的工具集合，尤其是通过一个单一的、不间断的过程。也称为“编译器工具链”

在*汇编语言中，工具链通常由*编译器*、*链接器*和*汇编器*组成。

## [](#virtual-machine)虚拟机

一个*程序*，*虚拟化*一个 *CPU* ，有时还有额外的硬件。可能执行*机器码*，也可能执行*字节码*，就好像它是机器码一样。

(另见，*解释器*；对比*解释器(繁体)*，*编译器*。)

## [](#virtualize-virtualization-virtualized)虚拟化(Virtualized，虚拟化)

通过软件模拟一个 *CPU* 的过程，经常这样*机器码*可以被执行，或者*字节码*可以像机器码一样被执行。***