# 你要么有，要么没有

> 原文:[https://dev . to/decudio ly/you-either-have-it or-you-don-t-44ef](https://dev.to/deciduously/you-either-have-it-or-you-don-t-44ef)

# [](#reading-material)阅读材料

## 又一场静态对动态的狂欢

本周，我偶然看到了 Eric Normand 写的一篇关于“静态与动态”之争的精彩文章，作者有着独特的视角，他曾在 Clojure 和 Haskell 中工作过。

这篇文章值得一读，但我想特别关注让我印象深刻的一行。我并不完全理解它，我希望 DEV 可以提供一些额外的信息。

作者引用了一段丰富的吻痕谈话。对于外行人来说， [Rich Hickey](https://purelyfunctional.tv/programmer-profiles/rich-hickey/) 是 [Clojure](https://clojure.org/) 的创建者，这是一种用于 JVM 的动态功能 Lisp 方言，也是 [Cognitect](https://cognitect.com/) 的现任 CTO。他的个人崇拜部分源于他所做的相当出色和相当固执己见的演讲，这些演讲专门讨论 Clojure 和他个人对软件生态系统现状的看法，以及它如何应用于他所解决的各种问题。(其余部分源于他的[非凡发型](https://purelyfunctional.tv/wp-content/uploads/2016/09/Rich-Hickey.jpg)。)

这是一个巨大的收获，Normand 特别注意去识别:Rich Hickey 并不是在谈论一般情况下静态和动态类型的优点。他关心的是**如何应用到他的问题空间**。当这些争论爆发时，这是一个经常被忽略的细节，但在做出任何技术决策时，这是一个绝对重要的因素，在进行这种讨论时，记住这一点很重要。

## [](#the-efficacy-of-maybe)也许的功效

特别引起我注意的一行是当他讨论在 Haskell 这样的语言中使用`Maybe`来处理可选值的概念时。你应该键入你的字段`Maybe String`，而不是`String`。现在 if 既可以包含字符串也可以不包含字符串，并且仍然可以被正确地键入。当您的代码需要做一些事情时，您使用模式匹配和析构来获得实际值。当您不确定该值是否会一直存在于给定的记录中时，可以使用它。

里奇·希基不喜欢这样。他不同意这种方法，说“你要么有，要么没有”。也有道理。对于 Clojure 旨在解决的各种程序来说，*一切*都将被包装在`Maybe`中。这些都是长期运行的系统，具有很高的容错能力和不断变化的业务需求。这些系统不适合超刚性的漂亮的强类型结构。如果规范发生变化，您不希望必须对项目中的每个文件进行结构更新。你希望能够处理不同形状的物体。

我可以理解为什么在每个值上显式地包含一个`Maybe`会很麻烦，但是我不太清楚为什么它实际上代表了一个不准确的系统模型。事实上，不知道[科特林](https://kotlinlang.org/)它实际上似乎就是他们要做的——将一个可空类型的开销减少到一个[单字符](https://kotlinlang.org/docs/reference/null-safety.html)。

这听起来对我来说是可行的，但也感觉 Hickey 的观点是正确的。当你的系统在运行，你有记录，他是对的。在运行时，这里没有“可选”的字符串。你要么有要么没有。那是真的。看起来基于`Maybe`的模型确实是方便程序员的一种变通方法，而不是真实世界现象的精确模型。不过，与此同时，它似乎确实模拟了预期的行为，并且在运行时，您仍然需要根据给定字段是否存在来调度逻辑。

你同意吗？不同意？我一直觉得`Maybe`是这个问题的有效解决方案，这篇文章让我想退一步，更仔细地考虑这个问题，并收集一些观点。

marc liu 在 Unsplash 上拍摄的照片