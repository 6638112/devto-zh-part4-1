# 为什么我认为反应钩是光滑的

> 原文:[https://dev.to/kayis/why-i-think-react-hooks-are-slick-44p4](https://dev.to/kayis/why-i-think-react-hooks-are-slick-44p4)

约翰·赖特在 Flickr 上的封面图片。T3】

前段时间 React 得到了一个新的主要特性叫做**钩子**。它们是向组件函数添加状态的一种方式。需要生命周期方法和组件类的东西现在可以用一个调用钩子函数的组件函数来实现。

这个事实本身已经是一个巨大的恩惠。我们用组件函数编写了第一个 UI 草案，然后不需要重新构建任何东西，放下钩子，就可以完成了。

它还消除了深层组件树。必须用**高阶组件**和**渲染道具**完成的事情，是用组件类及其生命周期方法构建的设计模式。身份验证、UI 状态、服务、国际化等。一切都是嵌套在组件中的组件。

钩子为嵌套增加了另一个维度。这个新的维度允许从我们的应用程序的**不可见**行为的嵌套中分离出**可见** UI 组件的嵌套。

但是我觉得这些点并不是钩子的主要卖点。

它们的强大之处在于它们提供了一种不同的方式来思考组件的生命周期。

在 hooks 出现之前，我们会考虑生命周期事件。

第一次渲染时，我需要组件做些什么吗？我们把代码放在`componentDidMount`里吧！

组件会被移除吗？放入`componentWillUnmount`！

更新吗？放入`componentWillUpdate`或`componentWillReceiveProps`或`getDerivedStatesFromProps`...或者...现在事情变得有点复杂了...

钩子一劳永逸地解决了这个问题。

使用钩子，焦点从我们想要**钩入**的不同生命周期事件转移到我们想要**观察**的实际状态。

我们用`useState`创建我们需要观察的状态，并用`useEffect`在它改变时触发代码。

我们唯一关心的是状态的变化以及组件是否从 DOM 中移除。

当我们使用生命周期方法时，仅仅知道我们想要**观察**什么是不够的，我们还需要知道**在生命周期的什么地方**它会发生。这个额外的步骤可能会导致 UI 错误。

例如，React 会重用一个已经渲染过的组件，改变道具并且`componentDidMount`不会被再次调用。`useEffect`钩子将识别改变的属性并重新运行它的代码。

这听起来像是对组件行为的一个相当乏味的改变，但我认为这是一个非常出色的改变，极大地简化了基于组件的 ui 的创建。