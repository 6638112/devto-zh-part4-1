# RWG:半自动 AI(？)Genkai Shiritori Mobile 的代理

> 原文:[https://dev . to/blueset/rwg-an-experiment-on-semi-automated-ai-agent for-gen kai-shiri tori-mobile-549m](https://dev.to/blueset/rwg-an-experiment-on-semi-automated-ai-agent-for-genkai-shiritori-mobile-549m)

日前，一款新游戏*Genkai shiri tori Mobile(GSM)*由 Baton Co .，Ltd .与一家网络媒体和 YouTubers 团队 QuizKnock 合作发布。Shiritori 是一种传统的日本单词游戏，每个玩家说一个新单词，以前一个单词的最后一个字母(或者更确切地说是*假名*)开始。Genkai Shiritori 是一款源于 QuizKnock 的游戏，他们在简单的 Shiritori 游戏的基础上添加了一些新规则，包括:

*   包括扑克牌的一个随机因素:下一个玩家必须说一句话，说出抽到的牌上的卡纳数。
*   时间限制:每个玩家每场比赛总共有 5 分钟的时间

在 Genkai Shiritori 视频系列在 YouTube 上获得人气后，QuizKnock 进一步修改了规则，并制作成了一款手机游戏。本文介绍了我在构建半自动人工智能系统方面的分析、尝试和思考。)代理，我后来将其命名为*随机字生成器*。

# [](#analysis-of-the-game)游戏分析

类似于其他流行的游戏，如拼字游戏和拼字游戏，Shiritori 强烈依赖于字典。幸运的是，这款游戏的开发者@imadake398yen 公布了一条推文中使用的基本词典。

液体错误:内部

推文中的文章链接到了 GitHub 的一个用于 NLP 的字典库，`mecab-ipadic-NEologd`。该存储库也包含在应用程序的信用部分。构建存储库，我们可以得到一堆 CSV 格式的字典。在这种情况下，我们只对单词的类型和发音感兴趣。

对于 Shiritori 的通用规则，只从字典中提取名词。这些单词然后通过 python 脚本发送，并进行一些后处理:

*   转换成平假名
*   过滤掉以ん结尾的单词
*   根据起始单词和单词长度分成多个槽

## [](#iterations)迭代次数

### [](#iterations-0-simple-lookup-script)迭代 0:简单的查找脚本

刚开始的时候，我只见过在我的 iPad 上运行的 iOS 版本的应用程序。我首先选择了一些看起来更有可能包含在真实数据库中的名词词表，只提取出发音，排序并删除重复项以供进一步处理。

```
cat Noun.csv Noun.adverbal.csv Noun.org.csv Noun.place.csv Noun.proper.csv Noun.verbal.csv mecab-user-dict-seed.\* \> words.csv cat words.csv | cut -d ',' -f12 \> ./words-kana 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

之后，编写一个非常简单的脚本来遍历文件中的每一行，将片假名转换为平假名，然后将单词添加到表中相应的位置。这个表非常容易构建，用 Python 类型提示符号来说，它是一个`Dict[str, Dict[int, Tuple[str, ...]]]`。外层字典是针对假名的，应该只包含有效的假名作为单词的开头假名，这样可以过滤掉一些其他无效字符，比如字母和数字(尽管这在这个数据集中并不常见)。内部字典是单词的长度，根据 GSM 的规则，唯一有效的长度是 2 到 7 和“8+”，后者采用任何 8 个假名或更长的单词。tuple 与其他常见选项(如 set 和 list)一起使用的原因是，tuple 在为查询加载时更节省内存，同时对标准库中的随机选择方法有效。

> 💡有趣的事实
> 
> 与普通的 Shiritori 规则不同，GSM 将非常规ゔ作为一个选项。Twitter 上的一些玩家甚至抱怨说，由于过时的手机型号，他们的手机无法输入假名。但事实上，他们可以在 Play Store 上安装另一个类似 Gboard 的键盘，而不是仅仅为了一个游戏而更换手机。

然后用 pickle 将该表转储到一个文件中供以后使用。

对于查找脚本，它甚至更简单。一个无限循环的脚本继续查询一个假名和一个数字，然后打印 5 个随机选择的有效单词。我相信写出来应该很简单，所以我不会在这里张贴出来。

在第一次迭代中，我只是从字典中查询单词，然后自己打出来。后来，我意识到我在 iPad 触摸屏上的打字速度仍然不够快。所以我开始了第二次迭代。

### [](#iteration-1-auto-typing-ios)迭代 1:自动打字(iOS)

我正试图寻找一些自动化打字过程的方法。 **USB HID** 对我来说太难处理了，因为我没有带任何 Arduino 或类似的设备。我还试图研究适用于 macOS 的**蓝牙 HID** 解决方案，比如`noble`和 [`bleno`](https://github.com/noble/bleno) ，直到我意识到我可以使用现成的**无线键盘**来发送网络请求。

在 App Store 上搜索了一番后，我发现这个漂亮的免费的 [AirType](https://apps.apple.com/us/app/airtype-type-from-your-computer/id922932291) 可以很好地完成这项工作。

AirType 启动一个网络服务器，监听键盘上显示的端口。查看托管网页的流量，看起来 AirType 正在使用 websocket 发送键入的文本，没有任何编码或格式。因此，我只是写了一个 4 行代码，使用一次性 websocket 客户端和 [Python Websockets](https://www.notion.so/1a23/RWG-an-Experiment-on-Semi-Automated-AI-Agent-for-Genkai-Shiritori-Mobile-c343878070364096bbdfd50ef1ab1263) 将文本“输入”到游戏中。

此时，我能够部分自动输入，但我仍然需要激活文本框并手动点击发送。

由于缺乏可定制性，我几乎放弃了我的非越狱 iPad，我发现有一个游戏的 Android 版本。然后我开始进入下一个迭代。

### [](#iteration-2-auto-submission-android)迭代 2:自动提交(安卓)

一旦我上了 Android，我可以用它做更多的事情。当然，我尝试过普通的反编译和数据包嗅探，但这个游戏是用 Unity + Firebase +证书锁定构建的，我不想深究所有那些硬二进制/汇编的东西，然后我只是回到自动化 Android，这似乎更容易开始。

令人惊讶的是，Android 已经提供了一些用于键入(`input text`)和屏幕点击(`input touch`)的命令。有了它，我就可以读出屏幕上的内容，然后输入下一个“命令”，剩下的工作就交给脚本了。

这样的话，仍然需要生命中的几分钟来完成一个游戏。然后，我研究了进一步自动化游戏。

### [](#iteration-3-automate-a-full-game)迭代 3:自动化一个完整的游戏

为了自动化一个完整的游戏，有 2 个因素需要考虑:我的回合是什么时候，以及键入什么。两者都依赖于当前的屏幕内容。好在 Android 也已经提供了一个命令(`screencap`)来获取当前截图。

为了解决第一个问题，我们只需要监控屏幕上特定像素(标记像素)的颜色，即闪烁框中您的回合准备好的任何像素。只有当像素为红色时，我们才开始我们的回合。

要解决第二个问题，这个问题比第一个问题更难，我们需要知道对手给出的是什么单词，我们需要发出的假名数量是多少。我首先想到的是 OCR(光学字符识别)，以及它最流行的本地解决方案， [Tesseract](https://github.com/tesseract-ocr/) 。Tesseract 是一款出色的本地 OCR 解决方案，内置了多种策略和语言训练数据。但可悲的是，宇宙魔方预先训练好的日文语言数据，在平假名方面，似乎和游戏中使用的字体， [M+ Type-1 重](https://mplus-fonts.osdn.jp/) ( [谷歌字体](https://fonts.google.com/specimen/M+PLUS+1p))不太搭。

由于我们需要识别的字符集很小(只是大多数平假名、数字和加号)，我决定为这个游戏训练我自己的“语言”。当我试图在我的 macOS 上构建宇宙魔方训练工具包时，总是有一些错误阻止我构建它。我别无选择，只能在我的笔记本电脑上安装 Docker，并在一个容器中运行培训工具包。训练结果最终在截图上表现得非常好，除了有时它把き和ぎ搞混了，并且出于某种原因漏掉了ほ。

在 OCR 引擎准备好之后，我可以从截图中裁剪出相关的框，并使用 [PSM 10](https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc) 运行 Tesseract 来获得所需的数据集。

### [](#iteration-4-speed-up-the-automation)迭代 4:加速自动化

当我试图让我的自动化运行一些游戏时，我发现脚本运行得非常慢。截图命令每 10 秒钟只运行几次，输入命令也是如此。

对于截图，我已经尝试让命令发出原始图像数据，而不是编码的 PNG 图片。这样，当标记像素不活动时，我可以放下图片的其余部分。但当我尝试这样做时，未完成的`screencap`命令很快耗尽了我的内存，并在可能的时候启动了我手机中的所有其他应用程序。当我试图等待前一个进程完成后再发布一个新的进程时，这个进程反过来也不会提高那么多。

然后，我开始寻找一些方法将屏幕传输到我的电脑上。经过一番搜索，我发现 Genymotion 背后的公司 Genymobile T3 的 [`scrcpy`可以通过亚行提供非常不错的流媒体服务。可悲的是，这个应用程序是用 C 写的，](https://github.com/Genymobile/scrcpy)[没有打算公开任何 API](https://github.com/Genymobile/scrcpy/issues/399) 。然后我不得不从操作系统中截取屏幕截图。使用 [PyObjC](https://pypi.org/project/pyobjc/) — Python 对 Objective C 接口的包装器，在我的笔记本电脑上截图速度可以达到 15 fps 左右。我把代码从[这个答案](https://stackoverflow.com/questions/12978846/python-get-screen-pixel-value-in-os-x/13024603#13024603)修改了一点到[把原始图像馈入`pillow`](https://stackoverflow.com/questions/3397157/how-to-read-a-raw-image-using-pil) 。

对于输入部分，每个输入命令实际上都是[在后台启动一个 Java applet](https://stackoverflow.com/a/34443868/1989455) ，这对于连续的操作来说确实很慢。许多人建议使用 sendevent 来代替，但当发出复杂的触摸命令时，这可能非常乏味，并且似乎不适合键盘输入。对于键盘输入，我注意到我可以采取与 iOS 类似的策略，使用特殊的键盘进行输入。有一个名为 [ADBKeyBoard](https://github.com/senzhk/ADBKeyBoard) 的应用程序，旨在使用 ADB 向键盘输入文本，它甚至强调了它的 Unicode 支持(输入文本实际上是发送键码而不是字符串，所以它必须依赖键盘应用程序来输入 Unicode 内容)。

经过一些研究，我发现了一个更好的解决方案，[UI Automator](https://developer.android.com/training/testing/ui-automator)——Android 中的一个工具包，用于执行基于 UI 的自动化测试。使用[的 Python 包装器](https://github.com/xiaocong/uiautomator)，触摸输入会非常快。UI Automator 还可以操作 EditText 小部件中的内容，甚至可以跳过任何键盘开销。

#### [](#side-note-a-guess-on-gsms-time-lapse-bug)旁注:对 GSM 延时 bug 的一种猜测

在游戏过程中，我也经历了游戏时间疯狂的错误:每一个答案都意外地下降了 10 秒以上。当时我用的是一个相当普通的名字。然后我把我的名字改成了一个相当不常见的名字，从那以后我再也没有遇到过那个奇怪的 bug。我猜在服务器的某个地方，后端程序正在使用一个人的名字作为密钥来存储他们的计时器，而不是唯一的 id。

### [](#iteration-5-automation-between-games)迭代 5:游戏间的自动化

既然我已经在这里了，为什么我不能更进一步甚至在游戏之间实现自动化呢？在支付大约 2 美元来删除游戏之间的广告后，其他事情就变得相当简单了。我在上面设置的标记像素似乎也可以检测游戏结束状态(当像素变成深灰色时)。那么过程将会是这样的:

1.  当标记像素变成深灰色(匹配结束)时，点击“タイトルへ”(返回主屏幕)。
2.  等到像素变白(在主屏幕)，点击“ランダムマッチ”(随机匹配)。
3.  等待，直到像素变成浅灰色(当它实际上开始寻找匹配)。
4.  等待，直到像素再次变色为黑色或暗红色(发现匹配并准备开始)
5.  等待 4 秒钟，然后开始新游戏。

这样就完成了一个游戏周期。

### [](#miscellaneous-dictionary-update)杂项:字典更新

尽管使用的字典是基于 GSM 也在使用的，但似乎仍然有一些单词在我的字典里，但没有被游戏识别，另一方面，对手提交的一些单词也不在我的字典里。我写了一些脚本来添加和删除字典中的单词。

深入 app 的存储部分，在共享的偏好设置文件夹中有一个特别大的偏好设置文件。它将游戏双方使用的过去 300 个单词存储在一个 JSON 字符串中，该字符串使用 URL 编码作为首选项值，首选项文件本身是一个 XML。尽管有点奇怪，但用 Python 中的所有标准库处理起来还是有些容易的。我编写了一个脚本，使用 ADB 的 Root 权限检索偏好文件，并自动将对手的未知单词添加到表格中。

## [](#pitfalls)陷阱

由于游戏交互的设计方式，单独使用屏幕截图很难包含对无效单词的检查，因为错误只会通过晃动的文本框来显示。这就是为什么代理被认为是“半自动”的原因。一旦一个单词没有被游戏识别，它就会停留在那里，什么也不做。代理也可能在网络拥塞时卡住，并吐出一个已经被对手用过的词。(代理本身使用的词语已经被记录下来以防止冲突。)

## [](#possible-future-improvements)未来可能的改进

*   发出一个单词后，可以设置 3-5 秒的计时器，并检查是否仍然是我们的回合。当我们提交了一个游戏无法识别的单词时，这可以作为一种变通方法。
*   我们可以在回合开始时识别对手的单词，以避免与对手的单词发生冲突。
*   一旦新的[游戏内键盘](https://mobile.twitter.com/imadake398yen/status/1164789183807778816)发布，打字策略可以被 UIAnimator 滑动命令取代。(但是如果他们没有从服务器端停止，为什么不继续使用旧版本呢？:P)液体错误:内部
*   观察游戏之间的广告模式，以便在没有其他广告拦截策略的情况下完全自动化游戏。(或者在系统范围内或路由器上安装广告拦截器应该更容易，当然也更快)
*   使用屏幕大小的百分比，而不是硬编码的坐标来从屏幕截图中检索信息。
*   清理代码并添加更多注释以提高可读性。

## [](#trivia)琐事

*   这个项目的名字，随机单词生成器，来源于一个流行的虚拟 YouTuber 项目，绊爱。我只是发现这个名字和这个项目非常匹配，所以选择了这个名字。
*   排名靠前的应用程序的主要策略是使用键盘应用程序的用户词典。该策略利用了这样一个事实，即您可以分别分配您的输入序列和文本(更像一个快捷字典，其中“omw”可以分配给“on my way”)。以类似于我们的*表*的方式将具有困难的开头假名和长度的单词添加到字典中，例如，“あま”给出“あんとにおいのき”(ま在 T9 布局上的按钮 7 上)。这种方法的缺点是，它容易受到对手对单个起始字母的攻击，并且人们可能会没有词来反驳。

## [](#source-code)源代码

这个项目中使用的源代码和编译的表可以在下面的代码库中找到。注意有很多硬编码的值，代码读起来超级乱。当你迷失在寻找源头的时候，试着回头参考这篇文章。

### [](#files)文件

*   `lookup.py`:主脚本
*   `lookup.adb.py`:最后一次基于 ADB 的迭代中的主脚本
*   `lookup.ios.py`:最后一次基于 iOS 的迭代中的主脚本
*   `addword.py`:将单词添加到表格中，用作`python3 addword.py たんごいち たんごに たんごさん`
*   `rmword.py`:从表格中删除单词，用作`python3 addword.py たんごいち たんごに たんごさん`
*   `addxmlword.py`:从 Android XML 首选项文件中添加单词。
*   `table.pkl`:单词查找表。
*   `count-words`、`kana-words`:tessera CT 用于获取计数或 kanas 的单词列表
*   `kana.traineddata`:平假名上的 Tesseract 训练模型(v3)，M+ 1c 粗字体上的数字和加号。

#兰瓦生

RWG:一个关于半自动人工智能的实验？)Genkai Shiritori Mobile 的代理首先出现在 [1A23 博客](https://blog.1a23.com)上。