# 闰年之前先看看

> 原文：<https://dev.to/yawpitch/look-before-you-leap-year-no4>

## 闰年是愚蠢的

实际上，[闰年](https://en.wikipedia.org/wiki/Leap_year)是*荒谬*，因而*极其*愚蠢。从那天起，一些死了很久的天文学家 <sup id="fnref1">[1](#fn1)</sup> 和占星家 <sup id="fnref2">[2](#fn2)</sup> 仰望着同一个天空中的太阳和月亮，把两个和两个放在一起，并意识到他们上次是在同一个地方*这该死的寒冷* <sup id="fnref3">[3](#fn3)</sup> ，我们就一直被他们*困住*，不管我们是否意识到这一点。尽管如此，在假装一个*椭圆* <sup id="fnref4">[4](#fn4)</sup> 是一个*圆*的可悲探索中，我们注定自己永远不得不*也许*在向前或向后看足够远的时候偏移我们的心理时钟，以免*历史*和*现实*危险地失去同步。

在现代西方，闰年通常被归功于朱利叶斯·凯撒，他如此成功地推广了这个概念，以至于罗马人在他死后五十年才把闰年可靠地纳入到现在历史试图遗忘的儒略历中。不幸的是，凯撒和他的学者们——都是相当糟糕的程序员——犯了一个小小的舍入错误，因此在 1582 年，教皇格列高利十三世被迫“纠正”这种情况，将平均年从 365.25 天改为 365.2425 天。就这样诞生了我们都知道并沿用至今的公历 <sup id="fnref7">[7](#fn7)</sup> 。对教会来说，这种近似已经足够好了，所以从那以后，历史上就经常有 2 月 29 日的事件发生。

我对闰年感到*蔑视*。那我为什么要写这个呢？

### 这是一个理想的编程练习

事实证明，确定一个特定的公历年<sup id="fnref8">[【8】](#fn8)</sup>是否是闰年是一个问题，它具有一些*不寻常的*属性，这使得它成为一个*优秀的*测试程序员对他们可用的一些最基本工具的掌握程度。这反过来意味着，这不仅对初露头角的程序员来说是一个非常好的挑战，而且它也可以——我认为*应该*——在技术面试中作为一个令人印象深刻的诊断性问题问应聘者。

在我所遇到的每一种编程语言中，都有一个简短、简单、性能最优的解决方案。事实上，在大多数情况下，最佳实现是单行长的 <sup id="fnref9">[9](#fn9)</sup> ，但是大多数尝试这样做的人在第一次尝试时会以非常不优雅的方式结束。而且，不像大多数有这样一个理想答案的问题，如果解决得不优雅，也几乎肯定解决得效率低下。

这个练习的美妙之处在于，通过使用那种直接的推理，可以很容易地找到通向理想解决方案的途径，而这种推理是专业编程的基础。通过首先*理解*你试图解决的问题，它鼓励你*思考*你的解决方案。

#### 这一切为什么重要？

> 从受虐狂到虐待狂:“伤害我吧。”
> 
> 从虐待狂到受虐狂:“没有。”
> 
> <cite>拿可利夫·巴克来说</cite>

也许你刚刚加入了[运动](https://exercism.io)。或者也许你只是在寻找一个好的代码形。或者您被分配到一个处理日历的团队。也许你只是一个受虐狂。或者更糟，也许你的面试官是个虐待狂。

不管怎样，让我们假设您刚刚被分配了一项任务，即实现一个函数`is_leap`，该函数接受一个*整数*自变量**年份**并返回一个*布尔值*结果。

### 幸运的是，有一种算法可以解决这个问题

> 除了能被 100 整除的年份，每一个能被 4 整除的年份都是闰年，但如果能被 400 整除，这些百年就是闰年。
> 
> 美国海军天文台

不寻常的是，对于一个编程问题来说，基本算法很可能会提前呈现给你，你只需要实现它。该算法非常古老，几个世纪以来一直以或多或少精确的方式陈述，因此将其转录为伪代码会有所帮助:

```
IF the year is a multiple of 4 THEN
    IF the year is a multiple of 100 THEN
        IF the year is a multiple of 400 THEN
            RETURN True
        RETURN False
    RETURN True
RETURN False 
```

注意到多层嵌套产生的人字形 **>** 形状了吗？事实证明，这是算法的第一遍心理模型的典型特征，至少在缩进有意义的语言中是如此。这不是最优雅的形式——我们会谈到——但它传达了我们算法的一些重要特性:

1.  **很简单***:你有一个参数，你用一个基本的数学运算对它进行(多达)三次测试，这是所有三次测试的*相同的*运算。你*需要*知道来解决的最复杂的事情是*你的语言*如何执行[模](https://en.wikipedia.org/wiki/Modulo_operation)运算。一旦你掌握了这些，与零的比较，简单的条件，以及如何用你选择的语言返回一个布尔值，你就是*黄金*。经过五分钟的精心指导，任何高级语言的新手都应该能够写出一个模仿上述伪代码的通用解决方案。*

**   **这是*渐进*** :每次连续测试后，你要么知道答案，要么知道下一个问题是什么。大多数算法——实际上是大多数非平凡的问题——远没有那么一成不变。不需要复杂的分支，或者你的语言版本的`else_if`，你只需要继续前进，直到你*确定*你知道答案。

    *   **是*健壮*** :没有 bug，没有怪异或者异常的边缘情况；每一个可能的(整数)输入都直接映射到一个单一的、稳定的输出。此外，没有副作用，没有状态突变…你甚至不需要结转每个模数测试的结果。这是一个函数所能得到的最纯粹的*了，而且如此受约束，以至于你看一眼就能知道它是否总能返回正确的答案。** 

 *### 知己知彼

理解算法是很好的，但是理解它所解决的问题更好*，并且上面获得的见解没有告诉我们关于我们正在处理的*领域*的任何事情。我们已经将各种模数测试视为黑盒，但实际上它们是专门的过滤器，适用于特定的、逐渐变小的、公历年整体领域的子集。*

 *那么，通过更仔细地观察这些测试，我们能收集到什么呢？

1.  答案是*通常是*不:从第一次测试中我们知道每 4 年中有 3 年*不会是闰年*。通过查看其余部分，我们可以看到每 4 个世纪中另外 3 个世纪也不会是……默认返回 False 将正确回答所有可能问题的 75%,而无需任何额外的努力。
2.  他们*迅速*宰杀牛群:每 4 年才有一年是*潜在的*闰年，每 100 年才有一年是一个世纪，每 400 年才有一年是一个世纪也是一个闰年……我们对我们的一年了解得很快。
3.  它们有一个*自然*顺序:每一个测试都是前一个测试的特例，从上面我们知道每一个都适用于数量越来越少的情况。当然，如果我们首先测试除以 400，我们在*极少数情况下很快解决了问题，但是如果*没有给我们答案*也没有给我们任何关于所提问题的有用知识。然而，按照自然的顺序进行，每一步都会完善最后一步。*

牢记第一点，我们可以重写我们的伪代码，这样我们只需要考虑通往正确答案的路径:

```
IF the year is a multiple of 4 THEN
    IF the year is NOT a multiple of 100 THEN
        RETURN True
    IF the year is a multiple of 400 THEN
        RETURN True
RETURN False 
```

但这很有趣。浏览以上内容，我们现在可以看到有*确切地说*两个标准导致一年是闰年，并且这些标准是排他的。因此，对于任何给定的年份，如果*以下任一*为真，则答案为真:

1.  年份是 4 的倍数，但不是 100 的倍数
2.  年份是 4、100 和 400 的倍数

### 正义之路

从以上任何一个方面来看，通往理想形态的道路都会在你面前整齐地展开。尤其是如果我们引入一些抽象，将我们的三个测试**称为 a** 、 **b** 和 **c** 。

例如，如果我们将*布尔逻辑*操作逐步引入我们的伪代码:

```
IF a THEN
    IF NOT b OR c THEN
        RETURN True
RETURN False 
```

…变成了…

```
IF a AND (IF NOT b OR c) THEN
    RETURN True
RETURN False 
```

…在允许你返回表达式的语言中变成:

```
RETURN a AND (NOT b OR c) 
```

哦，那很简洁。

### 或者我们可以走另一条路

如果我们从我们单独得出的标准开始呢？

```
IF a AND NOT b THEN
    RETURN True
IF a AND b AND c THEN
    RETURN True
RETURN False 
```

…可以与另一个布尔逻辑运算符组合，如:

```
IF (a AND NOT b) OR (a AND b AND c) THEN
    RETURN True
RETURN False 
```

…这使我们能够提取常见的操作:

```
IF a AND ((NOT b) OR (b AND c)) THEN
    RETURN True
RETURN False 
```

…但是没有理由两次执行相同的布尔测试，所以:

```
IF a AND (NOT b OR c) THEN
    RETURN True
RETURN False 
```

…因为我们正在返回表达式，所以我们又回到:

```
RETURN a AND (NOT b OR c) 
```

### 条条大路通这里

这是最终的、最佳的形式。在有*短路*布尔运算的语言中，这也是最具性能的形式，因为在大多数情况下`or`的两边都不会被评估。值得庆幸的是，大多数语言要么进行短路布尔运算，要么倾向于提供另一种短路运算符，如`and_also`和`or_else`，所以如果你不确定你的语言是否这样做，你需要做一些研究。

说到研究，你*可能*会忍不住去掉那些括号，这样看起来确实更好。但这是你能学到的最后一课；你省略这些括号的能力完全取决于你的语言的评估策略和运算符优先级规则。如果你的语言从左到右求值，并且以与`and`相同或更低的优先级绑定`or`，那么不，你不能删除那些*重要的*括号。至少不用为一年连 4 都不除尽而付出检查除数 400 的代价。

这就像闰年一样，是愚蠢的。

* * *

* * *

1.  那些仰望夜空，发现布满了*东西*的人。 [↩](#fnref1)

2.  那些仰望夜空，发现充满了*废话*的人。 [↩](#fnref2)

3.  他们从来没有*实际上*两次占据相同的绝对位置，当然，也永远不会，但是角动量和轨道力学对我们的原型 *yutz* 来说都是不可用的。 [↩](#fnref3)

4.  实际上，一个更接近椭圆的东西在一个想象的二维平面上被疯狂地一遍又一遍地画出来，在四维时空里被艺术家拉走。 [↩](#fnref4)

5.  著名的发生在公元前 44 年 3 月 15 日的凯撒遇刺事件，相当程度上推迟了闰年的采用。事情变得有点不稳定，直到公元 8 世纪，因为在这个时期没有人可以被依赖于持续写下任何东西，我们知道他确切的死亡时间，只是不知道我们日历上的时间。 [↩](#fnref5)

6.  格列高利十三世在礼拜仪式上可能是一贯正确的，但我们后来不得不引入*闰秒*的事实似乎暗示他在数学上也不是一贯正确的。 [↩](#fnref6)

7.  除非你使用印度教、伊斯兰教或佛教的历法，你是泰国人或中国人，认同朝鲜的主体思想，或者用 Unix 时间衡量一切。 [↩](#fnref7)

8.  具体来说，对于真正迂腐的*、*预言的*公历加上*天文年份编号*和一个零年。这对于练习来说是很好的。为了准确反映人类实际观察到的闰年，你至少需要一个公元 9 世纪前的非常复杂的查找表，可能还需要一个时间机器。 [↩](#fnref8)*

9.  您的里程可能会有所不同；在 Perl 中甚至可能更少，但是没有人会知道，因为有大括号。如果你是用 8086 汇编语言写的，那么，老实说，*你为什么要读这个呢？ [↩](#fnref9)***