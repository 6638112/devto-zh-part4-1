# 使用自上而下定义的归纳规范

> 原文：<https://dev.to/dwayne/inductive-specification-using-a-top-down-definition-63p>

**归纳规范**是一种强大的指定一组值的方法。

并且，**自顶向下的定义**是编写归纳规范的一种方式。

例如

给定由 5 的倍数组成的集合，即`S = { 5n | n ∊ ℕ }`，我们可以使用自上而下的归纳规范定义`S`,如下所示:

自然数`n`在`S`中当且仅当:

1.  `n = 0`，或
2.  `n - 5 ∊ S`。

我们可以用这个定义来确定`S`中有哪些自然数。`0 ∊ S`按条件 1。`5 ∊ S`自`5 - 5 = 0 ∊ S`通过条件 2。`10 ∊ S`自`10 - 5 = 5 ∊ S`通过条件 2。诸如此类。

3 呢？3 在`S`吗？

我们知道`3 ≠ 0`，所以条件 1 不满足。此外，`3 - 5 = -2`不是自然数，因此不是`S`的成员。因此，不满足条件 2。由于 3 两个条件都不满足，`3 ∉ S`。

你能看出为什么 8 不是`S`的成员吗？

你能看出为什么只有 5 的倍数是`S`的成员吗？

## 何苦呢？

计算机科学中的许多离散结构，列表、二叉树、lambda 演算表达式、正则表达式等等，都可以使用归纳规范来定义。

感应规格使我们能够:

1.  证明关于值或结构的集合的性质。
2.  编写操作它们的函数。

自顶向下的定义尤其可用于测试值集中的包含性。

例如，上面对`S`的说明可以用来写下面的谓词:

```
inS : Int -> Bool
inS =
  if n == 0 then
    True
  else if n >= 5 then
    inS (n-5)
  else
    False 
```

Enter fullscreen mode Exit fullscreen mode

## 挑战

为集合`S = {2n + 3m + 1 | n, m ∊ ℕ}`写一个自顶向下的归纳规范。

**N.B.** *这篇文章基于我对第一章的[人民笔记。](https://github.com/dwayne/eopl3/blob/master/03-ch1.md)*