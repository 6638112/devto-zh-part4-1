# 我最喜欢的计算机理论来创造例子

> 原文：<https://dev.to/sierisimo/my-favorite-computer-theory-to-create-examples-15cn>

在大学里，我学了很多不同的东西，但在“*计算机理论*课上，我最喜欢的话题之一是 **URM** (无限注册机)。

## 理论

**URM** 用来演示一些关于计算机的概念和一些运算的*可计算性*。我不会深入历史或理论的细节，但它类似于[都灵机器](https://en.wikipedia.org/wiki/Turing_machine)的理论，即给定一组有序指令(称为算法)和一个无限磁带，机器能够运行该算法并给出有效输入的结果。

## 寄存器

URM 寄存器的工作方式非常类似于按位置枚举的无限数量的连续单元格。您只能在寄存器中输入数字。关于这个寄存器的先决条件或信息主要取决于作者，但大多数人都同意，如果寄存器没有被触动；它不包含数据。其他作者更喜欢说每个寄存器在被机器接触之前都包含一个零。

## 操作

为了获得一个可计算算法的结果(或者证明它是不可计算的) **URM** 为我们提供了 3 个基本运算。一些书或作者提到了第四种操作，但我在纸上看到的第四种操作只需要 3 个基本操作就可以实现(名字或字母可能因作者而异):

*   `Z(position)`零点操作。用 0 替换`position`寄存器中的内容
*   `I(position)`增量操作。在`position`寄存器上加 1。如果我们是严格的……如果寄存器中什么都没有，它就不能加 1(所以你需要先调用`Z(position)`)。
*   `J(positionX, positionY, instruction)`跳转操作。比较`positionX`和`positionY,`处寄存器的值，当值相同时，在`instruction`处继续执行。发送一个`instruction`有效超出范围，这将指示执行的立即结束

## 指令

这也因作者不同而不同，但想法是相同的:您有一个有序的、可识别的对代表您的算法的寄存器的操作的调用列表。一旦名单结束，URM 将停止。

使用一个通用的符号(没有正式或标准的符号)，这个列表看起来像:

```
1:  Z(5)
2:  I(5)
3:  Z(2)
4:  J(2, 5, 7)
5:  I(5)
6:  I(2)
7:  J(2, 2, 6) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

## 筑基

也可以为机器提供前提条件，以指示一组先前填充的数据，或者算法如何使用变量(全部小写):

```
X: [2,,,3] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

将指示位置 0 和 3 的寄存器从一个值开始。URM 将根据这一假设继续阅读说明并给出结果。

或者

```
X: [x,y] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

会用名字`x`和`y`表示未知数字的存在。这将在以后用真实值执行，变量的概念在 URM 并不存在。还有机会为`x`和`y`提供前提条件，比如:

```
X: [x,y] -> x < y 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这完全取决于作者和实现。在大多数情况下，您会在纸上(或在您的实现的一些文档中)说明这一点。

## 结果

没有正式的迹象表明结果会如何。我创建了一个小的指令集，将结果复制到寄存器的位置 0。这样，您可以在该位置检查特定的结果。复制到不同的位置可能会变得复杂，但是您可以简单地说明每组函数在不同的 urm(多台机器)上工作。有人说这是欺骗，但如果你想重用想法，这是有帮助的。记住这在理论上是可行的。

## 举例:复制功能

一组指令，前提是寄存器 1 中有一个数字，并将该值复制到寄存器 0

```
X: [,y]

1: J(0, 1, 6)
2: Z(0)
3: J(0, 1, 6)
4: I(0)
5: J(0, 0, 3) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

然后，您可以使用它作为一个新的操作来调用(您将最终编写类似的东西，但是具有不同的寄存器位置)。

几年前，我用 JavaScript 写了一个 URM 的小实现,如果你有兴趣可以试试。这是我在大学时的代码，但仍然有效(它几乎没有依赖)。

这是我想分享的东西(也是我将在后面的例子中用到的东西)，我希望它能给你和我一样多的乐趣。将此编码为一个练习很有趣。我推荐你试一试(我知道我会在科特林)。