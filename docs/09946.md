# 你需要知道的 13 个 AWS Lambda 设计考虑事项——第 2 部分

> 原文:[https://dev . to/rehan VDM/13-AWS-lambda-design-consideration-you-need-to-know-about-part-2-1 LFA](https://dev.to/rehanvdm/13-aws-lambda-design-considerations-you-need-to-know-about-part-2-1lfa)

第一部分主要介绍了技术方面的内容，比如限制和配置选项。接下来的这一部分着眼于如何使用我们在第一部分中检查出的所有技术考虑来有效地设计无服务器和 Lambda 系统。

在这篇文章结束时，你应该对围绕 AWS Lambda 进行设计时要记住的关键事项有了很好的理解。让我们开始吧。如果你已经看完了第一部分的[](https://www.rehanvdm.com/uncategorized/13-aws-lambda-design-considerations-you-need-to-know-about-part-1/)**，在进入第二部分之前，请过来读一读。**

 ****这是一篇写给** [**杰弗逊·弗兰克**](https://www.jeffersonfrank.com/) **的文章，可以在这里[找到](https://www.jeffersonfrank.com/aws-blog/aws-lambda-design-considerations-continued/)或者在我的[博客](https://www.rehanvdm.com/serverless/13-aws-lambda-design-considerations-you-need-to-know-about-part-2/index.html)上找到。**

# [](#general-design-considerations)一般设计注意事项

## 9)AWSλ误差的类型

如何处理错误和失败都取决于用例以及调用 Lambda 的 Lambda 服务。

可能出现不同类型的错误:

*   **配置:**当您错误地指定了文件或处理程序，或者目录结构不正确，缺少依赖项，或者函数没有足够的权限时，就会发生这种情况。这些问题中的大部分都不会令人惊讶，并且可以在部署后被捕获和修复。
*   **运行时:**这些通常与函数中运行的代码有关，是我们自己引入的、会被运行时环境捕捉到的不可预见的 bug。
*   软错误:通常不是 bug，而是我们的代码识别为错误的动作。一个例子是 Lambda 代码在重试三次调用第三方 API 后故意抛出错误。
*   超时和内存:它们属于一种特殊的类别，因为我们的代码通常运行没有问题，但它可能收到了比我们预期的更大的事件，并且必须做比我们预算更多的工作。可以通过更改代码或配置值来解决这些问题。

记住——某些错误是运行时环境无法捕捉的。举个例子，在 NodeJS 中，如果你在没有使用 reject 回调的情况下抛出了一个 promise 里面的错误，那么整个运行时都会崩溃。它甚至不会向 CloudWatch 日志或指标报告错误，它只是结束。这些必须由您的代码捕获，因为大多数运行时都有在退出时发出的事件，并在退出之前报告退出代码和原因*。*

当涉及到 SQS **时，一个消息可以被传递多次，如果失败，它将在可见性超时后重新排队**，然后重试。当您的函数的并发数小于 5 时，AWS 轮询函数仍然会从队列中获取消息，并尝试调用您的函数。**这将返回一个达到并发限制的异常，**，然后消息将被标记为不成功并返回到队列中——这被非正式地称为**“过度轮询”**如果您在函数中配置了 DLQ，消息可能会未经处理就被发送到那里，但我们稍后会对此进行详细说明。

> ***SQS“过轮询”:如果 Lambda 被节流，则消息未经处理就被发送到 DLQ。*T3】**

然后，对于基于流的服务，如 DynamoDB 和 Kinesis 流，您必须在函数内处理错误，否则将无限期重试；这里不能使用内置的 Lambda DLQs。

对于所有其他异步调用，如果第一次调用失败，它将重试两次或更多次。这些重试通常每隔三分钟进行一次，但在极少数情况下，可能需要长达六个小时，也可能会重试三次以上。

## [](#10-handling-errors)10)处理错误

死信排队(DLQ)救援。也许不是，dlq 只适用于异步调用；它不适用于 SQS、DynamoDB 流和 Kinesis 流等服务。对于 SQS，在 SQS 队列上使用重新驱动策略，并在那里指定死信队列设置。将可见性超时设置为函数超时的至少六倍，并将*maxreceivecount*值设置为至少五倍，这一点很重要。这有助于防止过度轮询，即当 Lambda 并发性较低时，消息被限制，然后被发送到 DLQ。

或者，您可以用 try-catch-finally 块来处理代码中的所有错误。通过这种方式，您可以更好地控制自己的错误处理，并且可以自己将错误发送给 DLQ。

既然事件/消息已经在 DLQ 中，并且错误已经修复，**这些事件必须被重放，以便它们被处理**。需要将它们从 DLQ 中移除，然后必须将该事件再次发送到 Lambda，以便可以成功处理该事件。

有不同的方法可以做到这一点，这可能不会经常发生，所以**一个提取消息并调用 Lambda 的小脚本将完成这个任务**。Lambda 还可以内置重放功能，这样它就知道自己是否从 DLQ 接收到消息，以提取原始消息并运行该功能。DLQ 和 Lambda 之间的触发器将总是被禁用，但是在代码被修复并且消息可以被重新处理之后被启用。

[![](../Images/1f29651936c1f437d8fa2437ea6e75dc.png)T2】](https://www.rehanvdm.com/contents/data/2019/08/LambdaConsiderations_2-1_DLQ_Replay.png)

AWS 步骤函数还可以让您对如何处理错误进行精细控制。我们可以控制需要重试的次数、重试之间的延迟以及下一个状态。

[![](../Images/5ff8debe0cccc1af9ca852abca781678.png)T2】](https://www.rehanvdm.com/contents/data/2019/08/LambdaConsiderations_2-2_StepFunctionsConfig.png)

有了所有这些方法，**你的函数是幂等的**是至关重要的。即使对于像信用卡交易这样复杂的事情，也可以通过首先检查具有存储的交易回调 ID 的交易是否成功，或者它是否存在，来使它成为幂等的。如果没有，那么只进行信用扣款。

如果你不能让你的函数是幂等的，考虑 Saga 模式。对于每个操作，还必须有一个回滚操作。再次以信用卡为例，具有 Create Transaction 函数的 Lambda 也必须具有 reverse transaction 函数，这样，如果在创建事务之后发生了错误，它就可以传播回来，并触发 Reverse Transaction 函数。以便状态与交易开始前完全相同。当然，在处理钱的时候从来没有这么简单，但这是一个很好的例子。

> 如果你不能让你的函数是幂等的，考虑 Saga 模式。对于每个操作，还必须有一个回滚操作。

通过查看 Lambda 中的 *context.awsRequestId* 可以识别重复的消息。它可以用来消除重复的消息，如果一个函数不能是幂等的，那么应该使用它。将此 ID 存储在 Redis 或 DB 等缓存中，以便在重复数据删除逻辑中使用；这给代码带来了新的复杂性，所以把它作为最后的手段，并且总是试图把你的函数编码成幂等的。

一个 Lambda 还可以查看***context . getremainingtimeinmillis()*函数，了解函数结束前还剩下多少时间。**这样，如果处理时间比平时长，它可以停止，优雅地执行一些结束函数逻辑，并向调用者返回一个软错误。

## [](#11-coupling)11)联轴器

耦合超越了 Lambda 设计的考虑——它更多的是关于系统的整体。微服务中的 lambda 有时是紧密耦合的，但只要微服务的小黑盒中的 lambda 之间传递的数据不是*而不是*超纯 HTTP 并且不是同步的，这就没什么好担心的。Lambdas 不应该以请求响应的方式直接相互耦合，而应该异步耦合。考虑这样的场景，当一个 S3 事件调用一个 Lambda 函数时，这个 Lambda 也需要调用同一个微服务中的另一个 Lambda，依此类推。

[![](../Images/338c941c7ee6352010562b4462942b83.png)T2】](https://www.rehanvdm.com/contents/data/2019/08/LambdaConsiderations_2-3_Coupling_1.png)

您可能会尝试实现直接耦合，比如允许 Lambda 1 使用 AWS SDK 来调用 Lambda 2 等等。这引入了以下一些问题:

*   如果 Lambda 1 正在同步调用 Lambda 2，它需要等待后者先完成。Lambda 1 可能不知道 Lambda 2 也同步调用 Lambda 3，Lambda 1 现在可能需要等待 Lambda 2 和 Lambda 3 都成功完成。Lambda 1 可能会超时，因为它需要先等待所有的 Lambda 完成，并且在它们等待的时候，你也要为每个 Lambda 付费。
*   如果 Lambda 3 设置了并发限制，并且也被另一个服务调用了怎么办？Lambda 2 和 3 之间的调用将失败，直到它再次具有并发性。错误可以一直返回到 Lambda 1，但是 Lambda 1 会对错误做什么呢？它必须存储 S3 事件是不成功的，并且它需要重放它。

**该流程可以重新设计为事件驱动:**

[![](../Images/e50aa87830773d1f548b7a8df525f3e1.png)T2】](https://www.rehanvdm.com/contents/data/2019/08/LambdaConsiderations_2-3_Coupling_2.png)

**这不仅是对直接耦合方法引入的所有问题的解决方案，它还:**

*   提供一种在每个 Lambda 发生错误时重放 DLQ 的方法。
*   没有消息会丢失或需要存储在外部。
*   需求与处理是分离的。如果一次上传超过 1000 个对象并生成事件来调用第一个 Lambda，那么直接耦合方法就会失败。这样，Lambda 1 可以将其并发性设置为 5，并使用批处理大小从队列中只取出 X 条记录，从而控制最大吞吐量。

超越单个微服务，当事件在它们之间传递时，双方都需要理解并同意数据的结构。大多数情况下，两个微服务无法同时更新，因此请确保对所有事件进行版本化。这样，您可以更改所有侦听事件版本 1 的微服务，并添加代码来处理版本 2。然后更新发射微服务以发射版本 2 而不是版本 1，始终牢记向后兼容性。

## [](#12-aws-lambda-batching)12) AWS Lambda 批处理

批处理在高事务环境中特别有用。SQS 和 Kinesis 流是一些提供批处理消息的服务，将批处理发送到 Lambda 函数，而不是单独发送每条消息。通过以大约 10 条消息而不是一条消息为一组对这些值进行批处理，您可能会将 AWS Lambda 账单减少 10，并看到系统性能吞吐量的增加。

> 通过以大约 10 条消息而不是一条消息为一组对这些值进行批处理，您可能会将 AWS Lambda 账单减少 10，并看到系统性能吞吐量的增加。

批处理的一个缺点是它使错误处理变得复杂。例如，一条消息可能会引发错误，而其他九条消息会被成功处理。然后，Lambda 需要手动将该故障放在 DLQ 上，或者返回一个错误，以便外部错误处理机制(如 Lambda DLQ)完成它们的工作。有可能整批消息需要被重新处理；在这里，幂等性再次成为成功的关键。

如果你想更进一步，有时批处理是不够的。**考虑一个用例，您有一个包含数百万条记录的 CSV 文件，需要插入到 DynamoDB 中。**文件太大，无法加载到 Lambda 内存中，所以你可以从 S3 的 Lambda 中传输它。然后，Lambda 可以将数据放在一个 SQS 队列和另一个 Lambda 上，后者可以以 10 个为一批获取行，并使用 batch 接口将它们写入 DynamoDB。

这听起来不错，对吧？事实是，如果流数据的 Lambda 函数并行写入 DynamoDB，实际上可以实现更高的吞吐量和更低的成本。开始构建批量编写 API 调用组，每个调用组最多可以容纳 25 条记录。然后可以启动这些操作，并限制在大约 40 次并行/并发批量写入，无需太多调整，您将能够达到每秒 2k 次写入。

## [](#13-monitoring-and-observability)13)监控和可观察性

现代问题需要现代解决方案。由于传统工具不适用于 Lambda 和无服务器环境，因此很难发现可见性并监控系统。有许多工具可以帮助这一点，包括内部的 **AWS 服务，如** **X 射线、CloudWatch 日志、CloudWatch 警报和 CloudWatch Insights。**您还可以求助于第三方工具，例如 Epsagon、IOPipe、Lumigo、Thunderbird 和 Datadog 等等。

[![](../Images/3e7acb8424a1505934282653bf7f55f6.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--EufTpiTe--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.rehanvdm.com/contents/data/2019/08/LambdaConsiderations_2-4_XRayConfig.png)

所有这些工具都以日志和图表的形式提供了有价值的见解，有助于评估和监控无服务器环境。你能做的最好的事情之一就是**尽早获得可见性并微调你的 Lambda 架构**。找到问题的根本原因并在整个系统中跟踪事件是非常有价值的。

## [](#bonus-tips-and-tricks)奖励提示和窍门！

*   在一个 Lambda 中，你的代码可以**进行并行工作**。如果您正在接收一批 10 条消息，不要同步进行 10 个下游 API 调用，而是并行进行。它减少了运行时间以及函数的成本。在转到更复杂的*扇出-扇入之前，应该首先考虑这一点。*
*   并行工作的 Lambdas 通常会受益于内存的增加。
*   所有函数都必须是**幂等的**，*有没有*考虑让它们**无状态**。我们可以看到的一个例子是函数需要为 API 调用保留少量的会话数据。让调用者发送带有 SessionID 的 SessionData，并确保这两个字段都被加密。然后，解密它们的值并在 Lambda 中使用它，这可以使您免于重复执行外部调用或使用缓存。
*   您**可能不需要外部缓存**；少量数据可以存储在内存中 Lambda 函数处理程序方法的上方。该数据将在 Lambda 容器的持续时间内保持不变。
*   或者，每个 Lambda 都允许在/tmp 中有 **500 MB 的文件存储空间，数据可以缓存在这里，因为文件系统调用总是比网络调用快。**
*   **将数据保存在同一个区域**，以避免为传输到该区域之外的数据付费。
*   只有当 Lambda 需要访问私有服务或需要通过 NAT 访问将 IP 列入白名单的下游服务时，才将其放入 VPC。
*   记住 NAT 数据传输是要花钱的，像 S3 和 DynamoDB 这样的服务是公开可用的。所有在 VPC 内部流向您的 Lambdas 的数据都需要通过 NAT。
*   考虑使用 **S3 和 DynamoDB VPC 网关端点——它们是免费的**,你只需为接口端点付费。
*   批处理消息可以增加吞吐量并减少 Lambda 调用，但这也增加了错误处理的复杂性。
*   **大文件可以从 S3 流式传输**。
*   **阶跃函数非常昂贵**，因此尽量避免在高通量系统中使用。
*   如果您有一个 monorepo，其中所有的 Lambda 函数都是为该微服务而存在的，那么可以考虑创建一个目录，将这些 Lambda 目录用符号链接起来。共享代码只需要在一个地方管理；或者，您可以考虑将共享代码放入 Lambda 层。
*   许多 AWS 服务利用加密来保护数据，所以考虑使用加密而不是在应用程序级别加密。
*   你写的代码越少，你积累的技术债务就越少。
*   **在可能的情况下，使用 AWS 服务，因为它们是预期的用途**，否则您可能最终需要围绕您的特定用例构建工具并操纵这些服务。这又一次增加了你的技术债务。AWS Lambda 可快速扩展，与其他系统的集成(如开放连接数有限的 MySQL 数据库)很快就会成为问题。整合可扩展和不可扩展的服务没有灵丹妙药。可以做的最好的事情是限制伸缩或者在两者之间实现排队机制。
*   **环境变量不应该持有安全凭证**，所以尝试使用 AWS SSM 的参数存储。它是免费的，对大多数用例来说都很棒；当您想要更高的并发性时，请考虑使用 Secret Manger，它也支持 RDS 的秘密轮换，但它的成本比参数存储高。
*   如果不是，考虑使用**基础设施作为代码(IaC)** 。
*   API Gateway 能够将 HTTP 请求代理给其他 AWS 服务，消除了对中间 Lambda 函数的需求。使用速度映射模板，您可以将普通的 POST 参数更改为 DynamoDB 执行 PUT 操作所需的参数。这对于 Lambda 在执行 DynamoDB 命令之前转换请求的简单逻辑非常有用。

## [](#so-whats-the-bottom-line)那么底线是什么？

无论调用类型和模型如何，总是试图让 Lambda 函数无状态和幂等。Lambdas 不是为单一的大任务而设计的，所以把它分解成小任务，并行处理。之后，最好的办法就是测量三次，切割一次；**做大量的前期规划、实验和研究**，你很快就会对无服务器设计产生良好的直觉。**