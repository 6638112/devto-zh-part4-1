# 电子应用程序的安全自动更新

> 原文：<https://dev.to/soatokdhole/secure-automatic-updates-for-electron-apps-5blk>

多亏了像 [Electron](https://electronjs.org) 这样的框架，现在有很多流行的桌面应用程序是用 Javascript 和 HTML 编写的。想到的最值得注意的例子是 [Streamlabs OBS](https://streamlabs.com/streamlabs-obs) ，它在 Twitch streamers 中很受欢迎。

许多这样的应用程序甚至包括一个自我更新机制，以确保用户总是在最新版本的软件。不过，自我更新程序是一个地雷(或金矿，取决于您的角度)的安全风险。

然而，他们绝对值得冒这个险。重要的是把它们做好。

## 了解自动更新固有的风险

一般来说，了解安全风险的最佳方式是**像坏人**一样思考，然后试图智取自己。

[![Soatok hacking](img/cdca998f0327a489ade47551d82df17a.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--OTwsjVYs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://soatok.com/static/stickers/Soatok_STICKERPACK-HACKER.png)

如果您想在数千(或数百万)台计算机上安装恶意软件，并且您感兴趣的所有目标都在运行一些具有自我更新机制的软件，那么攻击更新服务器并用您的恶意软件替换更新文件不是很有意义吗？

这不仅仅是理论上的风险。过去，[下载链接](https://www.bleepingcomputer.com/news/security/hacker-compromised-official-phpbb-download-links)和[自我更新器](https://www.theregister.co.uk/2017/06/28/petya_notpetya_ransomware/)都曾被用来传播恶意软件。

让我们假设有人入侵你的更新服务器，发布了一个包含恶意软件的虚假更新。我们如何阻止他们感染我们的用户？

> 我们可以使用加密哈希函数吗？

[**不！**哈希函数在这里帮不了我们。](https://dev.to/paragonie/you-wouldnt-base64-a-password-cryptography-terms-and-concepts-for-developers#download-verification)

有很多关于下载真实性的“老派”观点。“只验证散列/校验和”的想法是行不通的，因为没有攻击者不能访问的秘密。

> HTTPS (HTTP over TLS)还不够吗？

TLS 是好的，我认为，它是解决这个问题的必要手段。但它本身是不够的。

顾名思义，TLS 保护传输中的数据。它不能为服务器上的更新文件提供静态真实性。如果有人能黑掉另一个端点，TLS 也帮不了你。

[![I know this can seem frustrating, bear with me please](img/303b21b64112e645daa5f6df9dc25eb4.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--kdu-hfpA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://soatok.com/static/stickers/Soatok_STICKERPACK-FACEPAW.png)

### 到底什么有效？

数字签名有效！

[![Eureka!](img/a42aed736726c3973f90584b0b3fb85b.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--brJ2fSlD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://soatok.com/static/emotes/idea.png)

数字签名是一类非对称加密算法，它计算一条**消息**的**签名**，该签名由一个秘密的**签名密钥**(或学术术语中的“私钥”)生成，可以通过一个众所周知的**验证密钥**(也称为“公钥”)进行验证。

由于非对称加密的性质，只有您的签名密钥需要保密。

所以你要做的是:

1.  脱机生成更新文件的数字签名。
2.  将签名和更新文件一起上传到更新服务器。

还有维奥拉。现在，即使有人侵入更新服务器，他们也无法在没有进一步攻击的情况下将恶意软件推送给您的用户，从而窃取您的签名密钥。如果您将此密钥保存在一台从未连接到互联网的计算机中，那么对于大多数攻击者来说，窃取它的成本会高得惊人。

但是数字签名本身就足以开发一个安全的自动更新系统吗？

专家说，“不。”

*   [安全代码交付的三角](https://defuse.ca/triangle-of-secure-code-delivery.htm)
*   [自动安全更新指南(针对 PHP 开发人员)](https://paragonie.com/blog/2016/10/guide-automatic-security-updates-for-php-developers)
*   [保护 Go 模块生态系统的提案](https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md)

也就是说，数字签名是保证软件更新安全的一个基本组成部分。如果不降低系统的安全性，就无法将它们从等式中删除。

完整的解决方案由以下各项组成:

1.  数字签名
2.  可重现的构建
3.  二进制透明性(又称用户基础一致性验证)
    *   该公司使用加密分类账，但要警惕其销售手册中任何带有“区块链”的内容
4.  传输层安全性(防止中间人重放攻击，使目标系统永远易受攻击)

这听起来可能令人生畏，但我写这篇文章不仅仅是为了谈论关于电子应用程序的安全自动更新的理论。专家们之前已经详细讨论过这些问题和解决方案。

今天，我想向你们介绍**我对问题**的解决方案(它基于[为保护 WordPress 的自动更新程序](https://core.trac.wordpress.org/ticket/39309)所做的工作)。

# 项目价

Project Valence(以价电子命名)是我的自我更新电子应用程序框架。它包括三个主要项目。

1.  libvalence 是为了便于安全更新而添加到现有的 Electron.js 项目中的组件
2.  [valence-devtools](https://github.com/soatok/valence-devtools) 是一个`npm`包，你可以在全球范围内安装它来打包、签名和发布更新
3.  [valence-updateserver](https://github.com/soatok/valence-updateserver) 是一个 web 应用程序，它公开了一个 API，其他两个项目可以与之通信，以便上传/下载更新和签名

Valence 使用的密码术是 [Dhole cryptography](https://dholecrypto.com) ，一个简单易用的 lib nasna 包装器。

对于签名，Dhole 使用 Ed25519(带有一个额外的 256 位随机随机数，如果在嵌入式系统中重新实现，会使[错误攻击](https://research.kudelskisecurity.com/2017/10/04/defeating-eddsa-with-faults/)更加困难)。

## 价更新服务器

Github 上有[安装/设置说明](https://github.com/soatok/valence-updateserver#install--setup-instructions)。

这公开了其他组件与之通信的 REST + JSON API。为了在更新服务器上发布任何内容，您需要一个发布者帐户和至少一个项目。你将需要一个发布者令牌来使用开发工具。

## 价开发工具

[开发工具文档](https://github.com/soatok/valence-devtools#valence-dev-tools)非常适合 Github 上的 README。

devtools 的设计使得您可以快速运行`ship`命令来构建、签名和上传一个新的版本，或者将每个步骤分解成一个原子命令(例如，便于使用 airgapped 机器进行离线签名)。

## Libvalence

这是这篇文章的核心:让你的代码自我更新。

我这个项目的目标是确保你不需要一个密码工程背景来设置它。一旦您访问了更新服务器并安装了开发工具，剩下的工作应该只是使用一个简单的 API 来解决这个问题。

API 看起来是这样的:

```
const { Bond, Utility } = require('libvalence');

let bond = Bond.fromConfig(
  'Project Name',
  __dirname + "/app", // Path
  ['https://valence.example.com'],
  [] // Serialized public keys (generated by dhole-crypto)
);

/**
 * @param {string} channel
 * @param {string|null} accessToken
 */
async function autoUpdate(channel = 'public', accessToken = null) {
  if (accessToken) {
    bond.setAccessToken(accessToken);
  }
  let obj = await bond.getUpdateList(channel);
  if (obj.updates.length < 1) {
    // No updates available
    return;
  }
  let mirror = obj.mirror;
  let update = obj.updates.shift();
  let updateInfo = await fetch.fetchUpdate(update.url, mirror, bond.verifier);
  if (updateInfo.verified) {
    await bond.applier.unzipRelease(updateInfo);
  }
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

您还可以[确保所有更新都发布在加密分类帐](https://github.com/soatok/libvalence#usage)上，指定您自己的自动更新策略(默认策略是 semver:补丁更新是自动安装的，次要/主要更新不是)。

一个重要的(但容易被忽视的)特性是**释放通道**的概念。

您可以从更新服务器生成可以访问特定频道子集的访问令牌(例如，`public`和`beta`版本，但不能访问`alpha`或`nightly`版本)。

这个概念的实现使得开发者可以向他们的付费支持者提供对早期版本的独占访问(例如，通过 Patreon)，并将这种访问直接嵌入到他们的自动更新中。

# 想投稿？

[![Soatok appreciates you](img/f9b24a6367832d81fb760109453d6127.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--6mGigYYi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://soatok.com/static/stickers/Soatok_STICKERPACK-HEART.png)

所有这些项目在 Github 上都是开源的，但是我的开发工作是通过 Patreon 的支持者资助的。

我也在我的 Twitch 频道上流式传输我的大部分开源开发[。](https://www.twitch.tv/soatok)