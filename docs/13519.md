# TDD 难的时候怎么 TDD

> 原文:[https://dev.to/ruralocity/how-to-tdd-when-tdd-is-hard-2eea](https://dev.to/ruralocity/how-to-tdd-when-tdd-is-hard-2eea)

> 这个帖子[最初出现在日常 Rails](https://everydayrails.com/2019/07/09/when-tdd-is-hard.html) 中。我在那里写了很多关于 TDD 的文章，所以如果你喜欢这篇文章，也请看看 Rails。谢谢！

当测试驱动开发运行良好时，它是平滑流畅的，引导你在测试代码和应用程序代码之间来回切换。它暗示了你下一步需要做什么——添加什么，改变什么，删除什么。而且速度很快。流程是资产，而不是负债。

你我都知道这并不总是一帆风顺。有时，TDD 碍事，与其说是指导，不如说是混淆，或者通常只是将开发减慢到单调的爬行——让您反复盯着模糊的测试失败，或者可能只是代码编辑器中的一个空行，甚至不知道从哪里开始。

当这种情况出现时(它们将会出现)，这里有一套我用来摆脱测试驱动的挫败感并回到生产力的五个策略。虽然我主要在 Ruby on Rails 和 RSpec 测试框架中使用它们，但它们总体上非常通用，并且在概念上适用于其他语言和框架中的 TDD。

## 问题:这个测试不能告诉我任何事情

无论您称之为系统测试、集成测试、特性测试还是验收测试，高级测试通常都是 TDD 的起点，尤其是如果您像我通常所做的那样实践由外向内的测试。这个测试很好地展示了成品的预期效果，但是在实际上*驱动*开发决策方面就不那么好了。一个失败的系统测试的输出通常过于模糊，无法指出应用程序更深层次的问题。

当一个系统测试太抽象而无法理解问题时，尝试在较低的层次进行测试。在 stock Rails 应用程序中，这可能意味着下降到控制器测试，甚至进一步下降到模型测试。如果你已经提取了服务对象或者类似的东西，看看你是否能从与它们直接交互的测试中获得意义。如果测试引发了异常而不是通过/失败，那么产生的堆栈跟踪可能会帮助您决定在哪里进行测试。

理想情况下，较低级别的代码需要较少的变量和条件来理解其内部工作。使用测试作为指南，探索期望交互在一起以使特性运行的单个对象。看看你是否能测试更接近有问题的代码，然后回到系统测试。

## [](#problem-this-test-needs-too-much-setup)问题:这个测试需要太多的设置

如果你像我一样，你对考试中的嘲笑又爱又恨。大多数时候，我都很喜欢它——直到我遇到一个测试，仅仅为了运行就需要清除越来越多的东西。当我完成的时候，我的测试的设置代码比实际的测试多十倍。测试现在与应用程序代码紧密耦合，以至于对后者的任何微小改变都会引发越来越多的测试调整。

听起来熟悉吗？我稍微夸张了一点，但我觉得这是大家对嘲讽的普遍抱怨。我也认为嘲笑会因此受到不良影响。问题并不总是嘲弄——有时，这是测试中的代码有太多责任的迹象，并且是重构的候选。我在 Rails 控制器及其相应的测试中经常看到这种情况，尤其是在继承了 pre-RESTful 行为的遗留应用程序中。

当这种情况发生时，请尝试从更高的级别开始测试。不利的一面是，这种新的测试可能比它所取代的测试要慢。但是新的测试通常也更容易建立，并且为重构提供了一个安全网。使用高级测试作为指导，帮助你将复杂的代码分解成更小的、更易测试的部分。根据该练习的结果，您可能会发现不再需要高级测试。使用您的覆盖率指标和专业判断作为指南。

## [](#problem-this-test-is-confusing)问题:这个测试比较混乱

很多时候，TDD 要求您深入研究现有的测试，而不是编写新的测试。也许那些旧的测试应该告诉你软件是如何工作的，或者也许它们需要被修改以支持新的行为。但是当一个现有的测试隐藏在嵌套的`context`中，严重依赖神秘的客人，并且通常被过度重构到不可读的程度时，它只能作为现有功能的安全网。它不能随着您的应用程序一起发展。

我经常在系统测试中看到这种情况，尤其是那些用 RSpec 编写的测试。这可能发生在其他级别的测试中，但是系统测试所需的额外设置似乎会导致过度重构。没有什么比一个测试更让我沮丧的了，这个测试需要更多的时间去理解，而不是仅仅添加一个微不足道的新应用程序行为！

当我遇到这样的测试时，我试图把它重新梳理成一个绝对不枯燥的、单一的、内嵌的测试。在新文件中工作通常会有所帮助。将混淆测试的内容粘贴到新文件中。从令人困惑的测试所依赖的`before`块、嵌套和共享上下文中粘贴设置。让测试自动通过，然后花些时间了解*和*是如何通过的。

一旦您研究了测试，您可以继续进行原始的测试，更好地理解它是如何工作的，或者您可以保留新的测试并在它的基础上构建，放弃原始的、令人困惑的版本。同样，你需要考虑哪个版本更好。做这种事情没有唯一正确的方法——即使有人说有，这种规则几乎总是有例外。

## [](#problem-this-app-doesnt-have-enough-or-any-test-coverage-to-begin-with)问题:这个 app 没有足够的(或者任何！)开始测试覆盖率

这是一个棘手的问题。我不会撒谎。但这是可以解决的，如果你能花些时间的话。受卡特里娜·欧文的精彩演讲《治疗重构》的启发，我成功地解决了覆盖面不足的问题。诀窍是假设现有的行为是正确的，并使用代码的当前输出来构建高层次的覆盖率。

它并不总是美丽的，但是它将覆盖最重要的特性——然后您可以使用这个覆盖作为起点来改进测试和被测试的代码。

根据经验，高水平的测试会更快地覆盖更广的范围。但是，请记住，仅仅关注这个层次来构建您的覆盖范围可能会很快导致一个缓慢的测试套件，无法提供 TDD 流畅运行所必需的快速反馈。使用这些新的测试作为起点，但是试着将它们限制在关键的用例上——并且尽可能早地探索通过在更低、更快的级别上测试来加速反馈循环的方法。

## 问题:我不知道自己在做什么

我承认，测试优先、测试驱动的开发并不总是像宣传的那样好。有时，我甚至不知道要测试什么，或者如何编写它——更不用说编写代码让它通过了！

对于这些测试人员阻塞的情况，当一个新特性的需求不能立即适用于测试时，我做的第一件事就是要求澄清。我知道向他人寻求帮助可能很困难，但是对于处于职业生涯各个阶段的开发人员来说，这是一个需要掌握的重要工具。事先问清楚总比错误的假设好！

如果事情仍然不清楚，我允许自己稍微查看一下代码，以便更好地理解它。甚至可以尝试一些想法，看看它们在浏览器中是什么样子(或者 UI，或者 API，或者你的界面是什么)。拿出调试工具(我喜欢用[撬开](https://pryrepl.org)，但是也可以随意使用传统的调试器，或者`puts`，或者混合使用)。通常，这让我知道要测试什么。在编写测试之前对代码进行试验也可以指导*从哪里*开始测试。也许自顶向下的测试方法不适用于特定的情况，从较低的级别开始会产生更好的解决方案。

## [](#problem-i-just-dont-have-time-to-tdd-this)问题:我就是没时间 TDD 这个！

有时候，截止日期太紧迫了，不能忽视。当截止日期临近时，人们很容易将测试放在一边，将关键任务功能推出，并继续到下一个截止日期，并发誓我们会回去清理混乱的代码，建立测试覆盖范围，并使事情变得美好。

我的经验告诉我，到目前为止，我们讨论的所有其他 TDD 挑战都会导致这一点。对我来说很容易，嗯，腾出时间！所以我不打算说了，或者至少，不是用那些话。相反，让我用另一种方式来描述这个问题。问自己几个问题:你对自己在压力下编写的代码有多少信心？这种压力可能会对您的代码产生什么负面影响？如果这个代码是错误的，可能发生的最糟糕的事情是什么？

TDD 是一个双层安全网。好的测试指导好的代码。是的，有时，好的代码意味着足够好的代码——我不会假装超过截止日期。如果当你*做*的时候有时间回去清理东西，一个足够好的*测试是朝着更高性能、更好分解的代码迈出的第一步。*

前面的测试导致一个危险的斜坡。我自己也见过这种情况，在关键业务软件中被忽略的测试套件。久而久之和最初的开发人员继续前进(他们确实这样做了)，测试套件变得越来越难以复活。一个被忽视的测试套件是没有用的——它覆盖的代码库很快就会变得相同。

因此，即使时间紧迫，也要设法在每次代码更改时至少覆盖一些内容。这可能是一个单一的、高层次的快乐路径测试，或者是几个覆盖一个重要算法的重要部分的低层次测试。它们可能不是最漂亮的测试，但没关系！当您面临即将到来的最后期限时，增加可靠性，并为将来的开发留下有用的线索。