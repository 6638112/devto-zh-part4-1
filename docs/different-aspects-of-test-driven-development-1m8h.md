# 测试驱动开发的不同方面

> 原文：<https://dev.to/rlxdprogrammer/different-aspects-of-test-driven-development-1m8h>

介绍

“软件做好之前的测试？多愚蠢啊。这太疯狂了。这违背了测试理论。这些家伙应该先学会如何开发软件。”我从一个在软件行业有大约 20 年经验的软件架构师那里听到了这些句子，我认为他是一个非常好的专业人士，他只是有点保守。那一次我没有足够的经验对这个话题有自己的看法。现在我已经有了。

测试驱动开发是编程世界中的时髦词汇之一，在过去几年中变得流行起来。每个花哨的公司都在通过敏捷和做 TDD 来宣传自己。但这到底意味着什么呢？它真的改变了我们所学的关于软件开发的一切吗？

# TDD 理论

基于维基百科:“测试驱动开发(TDD)是一种软件开发过程，它依赖于非常短的开发周期的重复:需求被转化为非常具体的测试用例，然后软件被改进以通过新的测试，只是。”

实际上，这意味着你正在开发一个和平的代码，你正在创建代码和它的单元测试并行。首先，您要实现一个单元测试用例，它是针对您的代码的第一个需求进行测试的。那么你正在运行你的测试用例，它当然会失败。现在，您正在实现一个代码和平，这使得您的测试用例是绿色的。然后，您正在实现下一个测试用例，并以通过测试的方式扩展您的代码。如果你认为你可以改变你的代码，使之更干净，只要改变(重构)它，并检查测试是否仍然是绿色的。重复测试，直到你的代码不能满足所有的需求。

# 我如何解读 TDD

看看我们默认怎么发展？我们正在编写一段代码。过了一会儿，我们试着运行它来检查它是否工作。如果它是一个库或一些很难运行的东西，我们通常会实现一个简短的演示代码，它不做任何其他事情，只是用一些预定义的参数调用我们的功能，我们用它来检查我们的代码是否正确。在其他情况下，我们会在调用 are 功能的程序中找出某个场景，每次我们想要检查代码是否正常工作时，我们都会这样做。如果我们的代码没有做我们期望的事情，那么我们就改变它并再次运行它。一旦它做了我们想要的，我们就用几条新的线(一些新的功能)扩展它，并检查它是否工作。我们重复这些步骤，直到您的代码没有完全按照我们想要的那样运行。

你也是这样发展的吗？

我认为大多数开发者都在做类似的事情。

类似于测试驱动开发吗？

是的，有些相似之处。

## 我在这种方法中看到了哪些缺点？

*   运行“测试场景”通常需要很长时间
*   您总是针对相同的输入参数进行测试
*   你总是只关注最后添加的功能
*   如果其他开发人员稍后更改了您的代码，他们不会知道您的代码应该做什么

有时还需要实现单元测试(由于项目需求或其他原因)。所以你试图在一个已经存在的代码中实现一些单元用例。你正在以一种他们肯定会通过的方式实现它们。此外，如果你的代码结构不合理，用单元测试来覆盖它真的是一场噩梦。

## 遇到 TDD 是怎么变化的？

这基本上就是硬编码你的“测试场景”。您正在使用自动化的单元测试，而不是手动测试(手动运行您的场景并检查您自己的结果)。

所以首先你要弄清楚你的第一段代码应该做什么。您正在单元测试中实现您的第一个测试场景。然后，您编写代码并检查您的测试场景。如果它不起作用，那么您正在修复您的代码，否则您正在扩展您的测试场景(通过添加新的测试用例)并实现它。

有时还需要实现单元测试(由于项目需求或其他原因)。所以你试图在一个已经存在的代码中实现一些单元用例。你正在以一种他们肯定会通过的方式实现它们。此外，如果你的代码结构不合理，用单元测试来覆盖它真的是一场噩梦

唯一的一点是，在传统的方式中，大多数情况下，我首先实现，然后开始思考我的代码应该做什么。在 TDD 的情况下，首先我需要定义下一段代码应该做什么。这里我处理得有点灵活，有时我只是先实现代码，然后添加新的测试用例。我知道，这是违反 TDD 的，抱歉。

通过使用这种开发方式:

*   可以看出你在做 TDD
*   你可以在几秒钟内通过一次点击来检查你的代码是否在做它应该做的事情
*   您不需要总是重复相同的手动测试场景
*   您可以很容易地为所有拐角情况设置不同的输入参数
*   您总是在运行并专注于所有的测试场景，因此您肯定会意识到您是否破坏了一些先前实现的功能
*   如果将来有人更改您的代码，他们可以检查他们是否没有破坏您代码的原始功能
*   你的代码肯定是结构良好的可测试的，这是良好代码质量的一个标准
*   你可以在任何时候重构你的代码，而不用承担破坏功能的风险
*   你有一个良好代码覆盖率的单元测试

我能提到的唯一缺点是实现好的测试用例需要时间。但是运行 1000 次手动场景也需要时间…

没有黑魔法，对吧？你不需要改变你当前实践中的一切。

# TDD 与经典测试方法的关系

在传统的开发过程中(瀑布，V-model ),有需求。软件开发团队正在创建一个软件设计，他们正在实现它。之后，一个专门的测试团队检查软件是否满足需求。开发人员和测试人员应该是两个不同的人，这一点非常重要。这样，如果一方误解了一个需求，另一方就会意识到。

但是这些需求通常是高层次的功能需求，所以它们不是由单元测试来测试的，而是由一些更高层次的测试来测试的，比如系统测试、组件测试或者集成测试。所以测试团队做的测试是在一个更高的层次上。单元测试通常由开发团队根据软件设计来完成，而软件设计也是由开发团队来完成的。在 99%的情况下，它只是意味着实现传递已有代码的测试用例。

TDD 正在取代这种单元测试活动。但这与更高层次的测试没有任何关系。我认为在软件发布之前这样的测试仍然是有意义的，所以好消息是:你不需要离开你的经典测试过程，这并不违背 TDD。

但是让我们进一步看看:在测试阶段发生了什么？测试团队找到一个 bug 工作台，创建 bug 标签，并将它们发送给开发团队。开发团队正在修复 bug，并发布了一个 bugfix 版本。测试团队再次测试，并意识到一些行为仍然不正确，因此需要一个新的 bugfix 版本。为了改进这个过程，更高层次的测试也可以通过自动化测试来完成(至少部分地)。在软件开发完成之前实现这些自动化测试并将其提供给软件团队也是一个不错的主意。这样软件团队就可以自己运行测试用例，如果测试用例失败，他们可以在发布之前修复代码。这样他们可以为自己和开发团队节省大量时间。

最好的情况是在持续集成系统中运行所有的测试用例，但是这已经是下一个主题了(也许是下一次)。

# 总结

你可以看到测试驱动的开发与通常的开发方式没有太大的不同，它也没有伤害传统测试方法的要点。实现适当的测试用例可能需要一些时间和实践，但是从长远来看，这对您的项目确实有很多好处。所以我只能建议尝试 TDD，但是你应该总是灵活地处理它，不要期望它能解决软件开发的所有问题。