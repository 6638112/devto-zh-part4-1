# SQL 技巧:查询同一个表两次

> 原文：<https://dev.to/stephencweiss/sql-tricks-querying-the-same-table-twice-3p1b>

我最近遇到了一个创造性的解决方案，使用 SQL 查找表中不同值之间的关系。这可能是标准做法，但这是我第一次不得不考虑这个问题。随着我逐步理解这个查询，我意识到这是一个使用 SQL 解决实际问题的优秀应用程序。

解决方案是对表*中的同一个字段查询两次*，并将其与自身进行比较。

在我们进入*为什么*你可能想要这样做之前，让我们看看它是如何工作的。

假设您有一个表(`my_table`)，其中有五个值。现在，想象你想看所有这些是如何相互联系的——让我们从其他的中减去一个。然而，值得注意的是，我们不希望计算一个行本身(即没有`a-a`)。

| 名字 | 英国压力单位 |
| --- | --- |
| a | one |
| b | Two |
| c | three |
| d | four |
| e | five |

因此，`a`的一行可能看起来像:

| 从中减去的值 | b | c | d | e |
| --- | --- | --- | --- | --- |
| a | -1 | -2 | -3 | -4 |

如何用 SQL 以编程的方式做到这一点？

不要试图用 SQL 来*可视化* it，让我们把数据按顺序排好。我们试图从表中提取唯一的元组(即`[a,b]`不同于`[b,a]`)。

```
SELECT name as name1, name as name2 FROM my_table table1, my_table table2
    WHERE table1.name != table2.name 
```

这样做的结果是查看`my_table`中的*每个*的名字，并为每个名字返回 n-1 行。

我们有元组了！这里有一个 [SQL 小提琴](http://sqlfiddle.com/#!17/e3156/8)演示了这一点。

那么，我们为什么要使用它呢？

上面的例子完全是人为的，但是这样做的需要比乍看起来更常见。例如，我第一次看到这种情况是在一个应用程序中，该应用程序查看不同状态之间的关系以及它们之间可能的流程。

一个简化的例子可以设想为:

| 从\到 | 来 | 活跃的 | 等候接听 | 完成的 | 取消 |
| --- | --- | --- | --- | --- | --- |
| 来 | - | -好的 | -好的 | -好的 | -好的 |
| 活跃的 | x | - | -好的 | -好的 | -好的 |
| 等候接听 | x | -好的 | - | -好的 | -好的 |
| 完成的 | x | -好的 | -好的 | - | -好的 |
| 取消 | x | -好的 | -好的 | -好的 | - |

=可用
- =不适用
x =不可用

虽然这种关系对于可视化很有用，但我们不会将它存储在 SQL 中，因为列的数量可能会很快失控，而且大多数时候，我们对特定的关系感兴趣——由它的元组定义(例如，回答问题可以将活动转换为暂停吗？).

使用针对同一个字段查询表两次的技术可以快速而轻松地创建这个矩阵。