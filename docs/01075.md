# 本周我读过的最好的科技文章-第五名

> 原文:[https://dev . to/mohanarpit/best-tech-this-I-read-this-week-5-28ol](https://dev.to/mohanarpit/best-tech-things-i-read-this-week-5-28ol)

*我分享 TL；我每个工作日通过简讯阅读的软件工程文章的 DR 版本- [in.snippets()。在这里](https://mailchi.mp/appsmith/insnippets?utm_source=devto&utm_medium=post05&utm_campaign=is)注册，在你的收件箱里收到这些。*

* * *

我们每周的阅读围绕着软件架构和工具。在产品开发的早期就正确掌握这些原则是非常必要的。以下是热门文章的简要列表。

*#go #devdecisions*

### [](#why-go-and-not-rust)[为什么去而不锈？](http://bit.ly/goenterprisesoftware)

虽然这篇文章比较了 Go 和 Rust，但基本要点简洁地解释了 Go 的一些特性如何使它非常适合开发企业软件。企业软件项目需要时间来构建&往往会变得庞大而复杂。许多人(有时是整个团队)改变了，留下了许多质量水平参差不齐的代码。多个团队并行工作会产生冗余代码。领域随着时间的推移而变化，不可避免地使旧的假设失效，从而导致抽象泄漏。**企业软件开发都是关于规模的&处理复杂性和 Go 都是关于在规模上抑制复杂性。**这里有一些有助于驯服企业软件开发野兽的特性:

*   它的并发模型使它非常适合必须主要处理多个独立请求的服务器端应用程序。
*   对 HTTP 和相关协议的强大支持。
*   诊断并发和性能问题的优秀工具。
*   交叉编译使得在任何平台上的部署都很容易。
*   它提供了该语言内置的一组有限的功能，使其易于学习。Go 迫使人们“用更少的资源做更多的事情”,这确保了 Go 项目即使规模巨大也能被理解。
*   Go 通过 go fmt 执行单一的通用样式。
*   变量只有两个级别的可见性，唯一的并发模型是 CSP。用 Go 写东西比用其他语言更难陷入难以理解的陷阱。

点击此处阅读[全文，我相信你会像我一样喜欢作者务实的结论:](http://bit.ly/goenterprisesoftware)

> "让我们避免将我们的身份与单一语言捆绑在一起，首先要拥抱实用性."

*9 分钟读完*

* * *

*#架构#软件设计*

### [](#software-architecture-is-overrated-clear-and-simple-design-is-underrated)[软件架构被高估，清晰简单的设计被低估](http://bit.ly/simpledesignsoftware)

> “作为一名工程师，你的目标应该更多地是解决方案并从中学习，而不是选择一个闪亮的架构模式，希望这能解决你的问题。”

Gergely Orosz 是优步的工程主管。他为改写优步的分布式支付系统做出了贡献，设计并推出了 Xbox One 上的 Skype 和开源的优步移动架构框架 RIBs。在这篇文章中，他解释了当涉及到创建软件系统时，它是如何关于简单设计而不是任何软件架构模式的。领先的科技创业公司的系统设计过程都没有使用任何标准的软件架构规划工具。没有一个项目有一个人拥有架构或设计，也没有人在试图设计软件系统时谈论公共架构模式。

设计软件的过程是相当简单和开放的。它鼓励团队中每个人的投入，不管他们有多少年的经验。几乎每个人都是从解决业务问题开始，集思广益找到解决问题的方法，并在讨论和改进时将这种方法放在白板上。白板上的练习清楚地描述了系统的架构。这可以用尽可能简单的图表写成一个简单的文档。这份文件还陈述了为什么要根据手头问题的背景做出某些选择，这些选择的权衡和替代是什么。最后，这份文件会发送给工程团队，听取每个人的反馈。

没有遵循软件架构模式，只是尽可能用最简单的方式解决问题，并确保即使是团队中最初级的工程师也理解正在发生的一切。

> “你最不想做的事情就是采用一个或多个架构模式，把它当作锤子，寻找用它的钉子。”

[点击此处，详细了解整个过程。](http://bit.ly/simpledesignsoftware)
*10 分钟读完*

* * *

*#网络#性能*

### [](#an-alternative-approach-to-rate-limiting)[限速的替代方法](http://bit.ly/ratelimiting)

如果您正在构建消费者规模的 web 应用程序，您可能会发现 Figma 构建其速率限制器的方法非常有用。速率限制器限制了发送者、用户或 IP 地址在特定时间窗口内可以发出的请求数量。 Nikrad Mahdi 考虑了现有的实施方案，如令牌桶、固定窗口计数器和滑动窗口日志，但似乎没有一个方案能有效解决对团队来说很重要的两个因素:

*   准确地限制他们的 web 应用程序的过度使用
*   使用尽可能少的内存

令牌桶算法的 Redis 操作不是原子的。在分布式环境中，“先读后写”的行为会产生一种竞争条件。这意味着限速器有时会过于宽松。Redis 操作对于固定窗口方法来说是原子性的，但它有时每分钟可以通过两倍于允许请求数的请求。例如，如果速率限制为每分钟 5 个请求，用户在 11:00:59 发出 5 个请求，他们可以在 11:01:00 再发出 5 个请求，因为新的计数器在每分钟开始时开始计数。虽然滑动窗口日志方法的精确性很有用，但它会留下相当大的内存空间，因为它为每个请求存储一个值。

由于这些都不符合团队的要求，Nikrad 通过结合固定窗口计数器和滑动窗口日志实现了另一种方法。使用多个固定时间窗口对来自每个发送者的请求进行计数，固定时间窗口的大小为速率限制时间窗口的 1/60。为了减少内存占用，它们将计数器存储在 Redis 哈希中，当它们的键少于 100 个时，Redis 哈希可以提供高效的存储。当每个请求在散列中增加一个计数器时，它还将散列设置为一小时后过期。如果在一个拥有 10，000 名活跃用户的网站上，每个用户每天有 500 个请求的速率限制，他们最多需要在 Redis 中存储大约 600，000 个值。这就产生了大约 2.4 MB 的内存占用。

[查看帖子](http://bit.ly/ratelimiting)了解实现速率限制算法的实际意义。
*8 分钟读完*

* * *

这是我在 [Appsmith](http://bit.ly/2Zdv9GS) 的团队一周以来阅读的最好的科技文章列表。我每周六都在这里分享。希望听到您对此的反馈。