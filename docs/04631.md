# 减少批量

> 原文：<https://dev.to/anze3db/reduce-batch-size-3ihc>

在本系列的文章中，我们了解了通过将代码评审作为您的首要任务来减少代码评审中的摩擦是多么重要。基于约束的[理论，不解决瓶颈会适得其反。如果您的代码审查队列有备份，编写更多的代码不会让您更快地部署特性！](https://en.wikipedia.org/wiki/Theory_of_constraints)

约束理论不仅能帮助我们找出应该关注的问题，它还有一个增加产量的解决方案:尽可能减少批量。对于我们开发人员来说，批量大小是每个版本中代码变更的数量。

如果您正在审查、测试和部署成千上万的行变更以节省时间和提高特性速度，您将得到的结果可能正好相反。通过将如此多的变更和功能放在一起，您增加了每个变更的交付时间。根据 [Accelerate 2018](https://www.goodreads.com/en/book/show/35747076-accelerate) 的研究，交付周期是四个关键软件交付指标之一(其他三个是部署频率、恢复服务的时间和变更失败率)，并且根据 [Accelerate 2018](https://www.goodreads.com/en/book/show/35747076-accelerate) 的研究，交付周期与公司绩效密切相关。

说白了，你的大版本阻止了小的修正和改变更快的出现。更大的版本需要更多的测试，更多的部署准备，这使得整个过程更加缓慢。这就是你如何结束一个可能需要几个月的发布时间表，总是延迟，并在部署到产品时以阻塞程序错误的形式造成混乱。

让我们把重点放在代码审查方面，看看为什么大的拉请求从来都不是我们想要的。

# 大拉请求的问题

开发人员有这样一个笑话:一个 5 行的拉取请求将会有至少 5 个评论或变更请求，而一个 1000 行的拉取请求将会被立即接受，并附带“看起来不错”的字样。

这是因为为了正确地审查这 1000 行，审查者需要投入大量自己的时间来完全理解变化的范围。这 1000 行对于任何评论者来说都可能太多而无法完全理解，因为人脑可以记录的东西的数量仅限于 7 项左右。通常，变化的巨大规模至少会使评审者失去做好工作的动力。

通常情况下，这 1000 行或更多行并不仅仅改变系统的一个方面。它们通常是一组变化组合起来形成一个整体。对开发人员来说，将它们分组可能是实现这些更改的有效方式，但通常不是审查、测试或部署它们的有效方式。

让我们来看看如何将大的拉请求分解成更小的请求，以便于审查、测试和部署。

# 避免在单个拉取请求中批处理特性

我们经常试图在处理代码库的特定部分时修复或完成多个任务，然后将所有这些更改合并到一个拉请求中。

这方面的一个例子是修复生产问题*的拉请求，而*改进了围绕该问题的日志记录。

当查看此 pull 请求时，添加日志记录的代码的潜在问题可能会延迟修复生产问题的代码的合并。当你在修复一个你的用户甚至不知道存在的日志问题时，你的用户将会被这个错误所困扰。

当你在公关标题中写下*和*时，考虑打开两个拉动式请求。这将有助于评审者在同一时间关注一个问题，减少出错的可能性。

如果问题仅在代码部署时才出现，这一点就更严重了。如果日志记录代码有问题，您可能还需要恢复错误修复来解决问题。不是一个好地方。

# 小代码批量

如果你被上面的问题搞得焦头烂额，然后决定一次只谨慎地部署一个特性，你仍然偶尔会遇到问题。对客户有用的特性往往不仅仅是对几行代码的修改。相反，它们需要几天甚至几周的工作才能变得有用。

在数周的工作之后签入代码往往是痛苦的。您将在一个功能分支上工作，并且需要处理合并和冲突。最后，你将有一个大的合并到你的主分支中，紧接着可能是几个月的工作放到一个特性分支中的大的部署。

对此的唯一解决方案是将特性与代码变更分离开来。

# 从代码变更中分离特性

解决这些问题的唯一方法是首先避免长时间运行的特性分支。相反，所有的变更都应该被检查并尽快合并到您的开发分支中。这意味着部署尚未准备好在生产中运行的代码，因此以功能标志的形式隐藏起来。

launch crystally 今年筹集了 4400 万美元，帮助程序员实现了这一目标，但在大多数情况下，一个简单的`ENV`变量或一个设置标志就足以确保该功能在最后一部分被合并和部署之前不会启用。

上面描述的技术叫做[基于主干的开发](https://trunkbaseddevelopment.com/)，它试图解决 [GitFlow](https://datasift.github.io/gitflow/IntroducingGitFlow.html) 开发模型的一些问题。最重要的是，它帮助我们减少了代码审查的批量，并帮助我们加快了特性交付时间。

当然，它并不完美。既然您在评审后立即将东西合并到 master 中，那么当项目的优先级转移时，您可能会在代码库中留下死代码。即使这段代码受到特性标志的保护，如果您的配置有问题，它仍然会以意想不到的方式弹出，并导致生产问题，因此您需要每隔几分钟花一些时间来清理它。

你有更好的方法来处理大的拉取请求吗？请在下面的评论中告诉我。