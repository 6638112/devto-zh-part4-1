# 原型实例化与伪经典实例化

> 原文:[https://dev . to/wt Schmidt/prototypal-vs-pseudo classic-instantiation-12a 1](https://dev.to/wtschmidt/prototypal-vs-pseudoclassical-instantiation-12a1)

谈到 Javascript 实例化，有许多不同的形式，但是我选择专门研究原型和伪经典之间的区别。然而，在我们深入研究之前，首先我们必须了解什么是继承，以及为什么它如此重要。

简而言之，这是一种使用父/子配对来回收代码的方法，允许子节点访问可能已经在父节点中声明的任何变量、方法或函数。而且，因为你没有在你已经写的代码上浪费空间，这节省了内存和时间！

伪经典实例化使用构造函数和“new”运算符来创建对象，并使用“prototype”属性来创建继承链。构造函数通常用大写字母来命名，以表明它们对读者的重要性。我们可以使用“new”关键字创建一个新对象，它允许子对象继承父对象的任何属性。我们甚至可以使用。调用( )方法！

原型实例化混淆不使用。原型，但非常类似于伪经典实例化，有一些不同。我们首先创建一个对象作为我们的构造函数，它的键是我们想要共享的变量。然而，我们没有调用原始的构造函数来创建新的继承，而是使用 Object.create()从我们的动物对象创建一个全新的对象。

因此，总之，原型实例化和伪经典实例化都提供了减少内存存储的非常有用的方法。两者都减少了打字量，降低了语法错误的几率。两者都更加系统化，允许更有组织的代码。唯一真正的区别是，prototypal 使用更加面向对象的方法，而 pseudoclassical 使用更加函数化的方法。

所以，在一天结束时，他们都做同样的事情，所以这取决于你！