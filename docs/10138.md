# Rails 应用程序-习惯跟踪器

> 原文:[https://dev.to/racheladaw/rails-app-habit-tracker-1b4a](https://dev.to/racheladaw/rails-app-habit-tracker-1b4a)

当考虑我的 Rails 应用程序时，我想选择一些在日常生活中有用的东西。我一直试图在自己的生活中建立良好的习惯，比如多喝水，早起，锻炼，每天学习更多的编程知识。尽管这可能有点过头，但我决定尝试制作一个简单的习惯跟踪器应用程序，用户可以每天登录并“检查”他们一天的习惯。

# [](#overview)概述

使用这个 Rails 应用程序，用户可以查看习惯类别或创建新的类别，查看习惯或创建新的习惯，并为他们想要创建的特定习惯创建目标。该应用程序允许用户选择目标的开始日期，并允许用户输入目标的描述/注释。一旦创建了目标，用户只需点击一个按钮，就可以标记他们当天的习惯完成，并可以看到他们目标进展的一些统计数据。

# [](#setting-up-the-foundation)设置基础

我决定在我的项目中使用模型和控制器 Rails 生成器。我不想在我的项目中添加很多不必要的文件，但是我很感激通过使用这些生成器而不是手动创建所有文件节省的时间。我最终在应用程序中使用的模型如下:

*   习惯(属于:类别，拥有:目标，拥有:用户，通过::目标)
*   类别(has_many:习惯)
*   用户(has_many:目标和 has_many:习惯，通过::目标)
*   目标(属于:用户，属于:习惯，和有许多:完成日期)
*   CompletionDate(owners _ to:goal)-我后来在编写应用程序的过程中添加了 completion date，因为我想要一个表格来跟踪用户完成目标的日期，以确保用户每天只能完成一个目标。

我对我的模型进行了简单的验证，比如要求用户提供电子邮件、类别名称等。

# [](#authentication)认证

用户可以通过两种方式登录/注册习惯跟踪器。他们可以手动输入电子邮件、密码和姓名，也可以通过脸书登录。

*   对于身份验证，我使用 bcrypt gem 和 has_secure_password 宏，它也验证用户输入的密码
*   对于脸书登录，我使用了 omniauth 和 omniauth-facebook gems

# [](#nested-routing)嵌套路由

对于我的项目，我决定嵌套几条路线:

*   目标(:new，:show 和:edit)动作嵌套在对我有意义的习惯下，因为它们属于一个习惯。
*   习惯(:index 和:new)动作嵌套在类别下，因为习惯属于特定的类别。

# [](#bootstrap)自举

这个项目是我第一次使用 Bootstrap。在阅读了一些关于它的博客并浏览了文档之后，我决定安装 bootstrap gem。多亏了我找到的这个[中型博客](https://medium.com/@biancapower/how-to-add-bootstrap-4-to-a-rails-5-app-650118459a1e)，启动和运行 bootstrap 非常容易。

我使用 bootstrap 文档将样式应用到我的应用程序的列表中，添加一个导航栏，并格式化链接和按钮。除此之外，我把我的设计留得很少。

# [](#refactoring)重构

重构我的代码是我的项目中更具挑战性和回报的部分之一。有时很难在我的 Rails 应用程序的众多文件中找到模式。我能够使用一些片段来清理我的代码，以便在页面上呈现错误消息，以及呈现通过脸书登录的链接。我还使用了 partial 和 locals 来呈现我的新建和编辑目标操作的表单。

我还能够通过为控制器中的任何逻辑编写类方法，以及为重复代码编写控制器中的助手方法，使我的控制器相对精简。

# [](#things-i-got-stuck-on)我陷进去的事情

1.  在审查我的应用程序时，一位同事发现了一个错误，即当相关目标被销毁时，完成日期没有被销毁，这意味着如果她删除了一个有完成日期的目标，然后创建了一个新目标，新目标将被分配上一个已删除目标的完成日期，因为它们共享相同的 id。我花了一点时间才弄清楚发生了什么，并意识到当一个目标被销毁时，CompletionDates 表没有被更新。在 Google 了一番之后，我意识到我需要将这行代码(:dependent => :destroy)添加到我的目标模型中的 has_many 关联中，这样当一个目标被销毁时，回调将销毁相关的关联(完成日期)。感谢我的朋友测试并找到了 bug:)。

2.  处理日期被证明是令人困惑和困难的。如果我只使用 UTC 时间，日期之间的转换将发生在太平洋标准时间下午 5 点。这在我的应用程序中创造了一些不直观的行为。我决定将我的目标开始日期存储为 UTC，将我的完成日期存储为本地时间。为了简单起见，每当我比较日期时，我都使用 to_date 方法和本地时间，以消除涉及小时的复杂性。每当我的逻辑需要将日期与数据库中存储的日期进行比较时，我还会转换为本地时间。这两个策略让我的应用程序能够准确运行，即使用户在使用我的应用程序时穿梭于不同的时区。

# [](#planning-for-the-future)规划未来

如果有时间继续开发我的应用程序，我想重温以下内容:

*   我想添加一些数据可视化排序，以显示用户有多远，他们来满足他们的目标。
*   我希望允许用户为一个目标设定其他时间框架，而不仅仅是我的应用程序目前允许的 66 天，并让用户决定他们希望养成习惯的频率。
*   我想改善我的应用程序的前端，因为我获得更多的 CSS 技能。

### 如果你已经读到这里，非常感谢你！这是链接，如果你想看看，随时给我反馈。

[习惯跟踪器](https://github.com/racheladaw/habit-tracker-rails-app)

[视频演练](https://youtu.be/kg6SMv52VWk)

[![T. Hanks](../Images/dc177c434ab428ffb90275ac77e711b3.png)T2】](https://i.giphy.com/media/KJ1f5iTl4Oo7u/giphy.gif)