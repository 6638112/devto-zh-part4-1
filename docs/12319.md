# godoc 怎么了？

> 原文:[https://dev.to/ilyakaznacheev/what-s-wrong-with-godoc-3319](https://dev.to/ilyakaznacheev/what-s-wrong-with-godoc-3319)

> *这是我在 [kaznacheev.me](http://kaznacheev.me) 的博客的转贴。我欢迎新读者，也很乐意讨论我写的关于*的内容

像许多现代语言一样，Golang 有内置的文档支持工具`godoc`。

说实话，很牛逼。这是一个非常棒的工具，对日常编码过程有着真正的影响。至少如果你像我一样用带函数调用提示的插件。

但是大多数 Go 项目都有一个大问题，这个问题与`godoc`密切相关，但却不在它的范围内。

这个`godoc`真的很酷。您可以记录您的方法和包，粘贴一个代码片段，它必须在 web 页面上突出显示。一些 IDE 插件会根据函数文档给你签名提示，例如参数描述。

此外，如果您错过了包头或全局类型、函数或变量描述注释，一些代码分析器如`go vet`会警告您。它训练你，使来源更具可读性。

只有专业人士，嗯？但是有一个很大的缺点，那不是`godoc`本身的错，但是许多开发者期望它能解决这个问题。

* * *

## [](#the-main-idea-escapes-the-attention)主要思想逃脱了注意

`godoc`的主要缺点是它的声明性。您可以编写包含代码片段和参数描述的优秀文档。您可以为您的方法编写简单的用例，您可以对每个全局常量和变量给出丰富的描述。您可以测量您的文档覆盖率，并努力达到 100%。最后，您可以像许多开源项目一样，在包头中写一篇大文章，并且您将拥有很棒的文档。

但它会成为一本书。一本百科全书。*不是手册。而不是操作指南。*

有许多类似百科全书的文档的例子，即使是在大而受欢迎的项目中——例如，看看 Docker 或 Kubernetes。它们都有记录良好的特性。每个方面在文档门户上都有自己的页面。他们甚至有一些代码片段的例子。但是，如果你真的想使用它们，如果你试图理解一些边角案例或跨模块交互，你宁愿去 SO，然后通过 docks 搜索。这就是原因。

* * *

## [](#you-dont-need-a-book-you-need-a-guide)你不需要书。你需要一个向导

在过去的二十年里，编程的方式已经发生了根本性的变化。我们现在有了时尚的冰沙男孩，而不是穿着毛衣的“黑客”，他们在投资场上看起来比他们的首席执行官还要好。我们争论的不是内存泄漏和 Y2K 问题，而是哪个前端框架更好，性能现在是一个禁忌话题(试着在一些前端 meetup 上问一下性能)。现代工具和语言自己完成了大部分低级工作，我们可以专注于更抽象的任务，而无需理解每一位是如何在系统中流动的。

当然，最好是知道底层的东西。更好的理解是，编译器如何处理你的代码，何时可以优化运行时。很高兴知道你所使用的工具的技术限制，知道会发生什么。

但毕竟，你需要投入大量的时间来学习所有这些东西。以至于在你成为这方面的大师之前，它可能已经过时了。这甚至不能给你一个保证，对工具基础的深刻理解将会给你带来同样多的回报，就像你花在学习它上的时间一样多。

举个例子，我在应用程序中经常使用 Docker。我了解容器化和虚拟化的基础，但老实说，我不知道黑盒里到底在进行什么。如果我根据集装箱化原则仔细阅读所有的码头并学习每个技术方面，我会制造出更好的集装箱吗？当然可以。如果我调查源代码并试图理解甚至调试每个方法，我会做出更好的容器吗？嗯（表示踌躇等）...不确定。也许我会成为 Docker 架构和一些有趣的解决方案的专家，但这不会让你在容器配置方面强大 10 倍。你将花费如此多的时间，却几乎得不到任何与你实际任务相关的东西。

这就导致了下面的情况:你不需要知道工具是如何工作的，但是你需要知道如何在日常工作中使用它。这意味着，人们更感兴趣的是真实的用例以及特定的问题解决方案，而不是方法文档和选项描述。对于许多工具来说，堆栈溢出比官方文档有用得多。

事实上，你不需要像书一样的文档。当你想检查一些参数或不清楚的行为时，这是很好的。但一开始就不应该。你真正需要的是用例。最初步骤中应用程序或工具使用的真实示例。

我见过很多很棒的工具，它们真的很难用，因为你根本不知道从哪里开始。他们对每个函数或类都有完美的描述，但是你只是错过了主要的想法。这就像和一个患有精神分裂症的人交谈——你能听懂他的话，但不能理解他的意思。

`godoc`的问题是没有这样面向用例的文档的地方。你不能在一个包注释里放一大堆例子。至少，你不能把它们结构化。你需要一个不同于包内容树的文档层次结构。但是解决方案是存在的。

* * *

## 如何让你的文档变得有用

当一个孩子学习阅读时，他不是从课本开始的。他从童话开始。他读关于勇敢人物的有趣故事，但不读单词的定义。这就是为什么即使孩子们不知道我们使用的所有单词，他们也能理解我们。

为了让你的用户轻松开始，不要给他们一本百科全书。给他们一个故事。从头到尾引导他们。或者至少告诉他们从哪里开始。

不幸的是，用`godoc`就没那么可能了。如果你的项目足够小，你可以在你的`README`或者在包描述中这样做，但是通常情况不是这样。

那么，你能做什么？

### [](#explicit-entry-point)显式进入点

往往当你发现一个新的包，你不想做研究。你问自己:“好的，它符合我的要求吗，或者我只是需要进一步搜索？”。不要强迫用户阅读所有的文档。帮助他现在就开始使用你的工具。

你能用两行代码运行最简单的选项吗？太好了，让我们从这开始，然后一个接一个地添加新功能。

可以运行不同参数的裸模块吗？不再多言！让我们这样做，然后给用户越来越多的参数，描述他们如何帮助满足他的需求。

这种方法非常有用。一方面，你可以帮助新人开始轻松使用你的产品。另一方面，你会聚集起一个更大更有参与度的社区。

### [](#real-usecases-and-tips)真实用例及提示

正如我上面提到的，在很多情况下你不需要一个工具的详细描述来解决你的问题。你只需要解决你的问题。有时你甚至对工具或库描述一点也不感兴趣，你只是希望它能工作。

这就是人们将在你的文档中寻找的东西。他们不需要每个功能和每个参数的详细描述，他们需要一种从头开始实现它的方法。

所以给他们他们需要的。描述你的包的主要思想和用例。从使用的角度来写，而不是从功能的角度。让用户把它当成一个故事来读，一章一章地读，但是避免正式的百科全书结构。

要做到这一切，你需要更灵活的东西，然后是一个`README`文件。

### [](#hierarchical-documentation)分层文档

要轻松浏览由此产生的“tool X 用法的故事”,您需要一个灵活的结构，既能作为目录又能作为路线图。这里你需要类似于层次导航/内容树的东西。也许有其他好的解决方案，但我发现一个分层视图最适合这个任务。有几种不需要额外工作就能做到的方法:

*   GitHub、Bitbucket 或 same hosting 上的内置 Wiki 它们易于使用，支持 markdown，并且只需要您已经拥有的存储库；
*   [阅读文档](https://readthedocs.org/) -这项服务是事实上的文档标准。它支持版本控制，所以你可以同时拥有每个版本的文档，如果你想支持以前的版本，这是非常有用的；
*   包含文档的目录——你可以简单地创建一个包含一组降价文档的目录，并在根目录中添加一个目录或相同的文档。同样的事情也可以在一个文档中使用锚来完成——风格的选择由你决定。将此作为[T2 的一个好例子。](https://github.com/SAP/styleguides/blob/master/clean-abap/CleanABAP.md)

还有很多其他的选择，你甚至可以用你的`godoc`来组织这样的事情，但是我认为，最好是把每个工具都用在它的主要用途上。

* * *

## [](#so-what-about-godoc)那么，godoc 呢？

毕竟，`godoc`还是一个非常酷的写功能文档的工具。我真的很尊重那些使用像这样的内置工具编写丰富清晰的代码文档的人。

别忘了用它。从`godoc`开始你的文档，然后写更复杂和更面向使用的用户手册。作为一个很好的例子，我可以给出一个 [go-pg](https://github.com/go-pg/pg) 库，它既有很好的内联文档，也有一个包含示例和用例的 Wiki。

有时可能很难为一个包编写一个好的手册，所以从简单的问答页面开始，并从 so 和其他资源填充它。在那里你会看到，什么给用户造成困难，什么可能被误解。迭代地做这个工作，倾听你的社区，你会很好。