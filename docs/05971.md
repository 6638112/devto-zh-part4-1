# 正则表达式的 4 个实际用例

> 原文:[https://dev . to/delete man 123/4-正则表达式的实际用例-58c2](https://dev.to/deleteman123/4-practical-use-cases-for-regular-expressions-58c2)

*原文发布于此:[https://blog . bitsrc . io/4-practical-use-cases-for-regular-expressions-b6ab 140894 FD](https://blog.bitsrc.io/4-practical-use-cases-for-regular-expressions-b6ab140894fd)*

## [](#how-to-stop-fearing-the-regexp-object-and-learn-to-love-it)如何停止害怕 RegExp 对象并学会爱上它

新开发人员通常害怕正则表达式，他们看到奇怪的语法，并选择避免他们添加额外的逻辑来解决他们的需求，而不是试图理解他们背后的逻辑。

不要误解我的意思，我刚开始的时候也是这样做的，处理一种语言的语法就足够了，所以为了使用这些正则表达式而必须学习一些奇怪的额外语法的简单想法不是我喜欢的。

让我改变主意并帮助我决定尝试学习如何读写它们的主要原因是理解它们有什么样的用例。在这篇文章中，我想为你做同样的事情，所以让我们开始吧。

## 首先，快速介绍一下 JavaScript 中的正则表达式

我喜欢将正则表达式描述为类固醇中的字符串(请随意引用我的话)，这是因为与好的 ol'string 对象相比，你可以用它们做更多的事情。

而你的普通字符串可以让你做一些事情，比如连接，长度计算，甚至现在，用 ES6:templating；正则表达式允许你寻找模式，进行模糊匹配，甚至在我们信任的朋友字符串上执行选择性替换。

我知道你在想什么:*那可怕的语法怎么办？！*我同意你的观点，我已经使用它们很多年了，每次我需要做一些除了你的基本模式匹配之外的事情，我都需要在线检查正确的方法。

也就是说，否则你会如何实现它？他们在 string 实体中添加了太多的特性，以至于它们都不能成为对象 API 的一部分(更不用说正则表达式也是非面向对象语言的一部分，那么你会怎么做呢？).

让我分解基本语法，以确保我们都在同一页上，你会看到事情是如何开始有意义的。

### [](#the-anatomy-of-a-regular-expression)解剖正则表达式

作为最后的免责声明，让我确认我将使用 JavaScript 风格的正则表达式。如果您试图将下面的例子改编成另一种语言，请确保检查正确的语法，因为可能会有微小的变化。

在 JavaScript 中，正则表达式有两种定义方式:

1.  使用 [RegExp 对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)，这是一个全局对象，您可以在任何地方使用，而不必添加或要求(我正在查看您的 Node.js devs)任何额外的东西。

```
let regExp = new RegExp('a|b'); 
```

1.  使用字面符号，也就是用一对“/”来定义它

```
let regExp = /a|b/; 
```

两个版本返回相同的东西，我个人更喜欢第二个，因为它不需要额外的直接实例化。但是，如果您试图从字符串创建正则表达式，第一种方法会非常方便(例如，您可能有一个字符串，其中您基于不同的条件定义了实际的表达式)。所以确保你记住了这两个。

### [](#modifiers-or-flags)修饰语或标志

不管你怎么称呼它们，它们都给你的正则表达式增加了额外的含义。有六种，其中一些你会一直用到，其他的可能在你的生活中会用到一两次，所以让我们快速的提及它们:

*   g:执行全局搜索。换句话说，不是一找到第一个匹配就返回，而是返回在字符串中找到的所有匹配。

*   不区分大小写的搜索。这个非常简单(也很有帮助)，因为它会在匹配时忽略大小写，否则像“HELLO”和“Hello”这样的词就不会被认为是匹配的。

*   m:多行搜索。类似于第一个，但是如果字符串中有换行符，这个标志将忽略它们，并且不会在它们上面停止。

*   学生:允许。匹配换行符。通常点字符匹配任何单个字符，除了换行符。

*   u:“unicode”；将模式视为 unicode 码位序列。

*   y:从目标字符串中的当前位置开始执行匹配的“粘性”搜索。如果你一次做一个搜索，这就很方便了，因为它会从上次尝试找到的最后一个位置开始搜索。

这些标志被添加到正则表达式的末尾，就像这样:

```
//If you're using the RegExp object

let re = new RegExp('[H|h]ello', 'gm');

//If you're going with the literal syntax

let re = /[H|h]ello/gm; 
```

这就是我对正则表达式的自定义介绍，如果你想详细了解它们是如何工作的，[查看文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)，但是首先，留下来看看下面的实际例子，这样你就可以对文档有所了解。

## [](#regular-expression-use-cases)正则表达式用例

下面的 4 个用例旨在向您展示正则表达式是多么有用，不仅对于代码逻辑需求，而且大多数 IDEs 实际上支持使用它们来搜索和替换代码中的文本。

### [](#password-pattern-matching)密码模式匹配

当你试图在你最喜欢的网站上创建一个帐户时，你有没有见过这样的消息:*“你的密码必须至少有 8 个字符，至少有一个大写字母、一个小写字母、一个数字，可能还有一个符号，这样你就可以确保你将来永远不会记住它”*

好吧，也许最后一部分是我的，但你得到了要点:他们描述了一个模式，你需要遵循，以提供一个有效的密码。当然，您可以使用简单的 JavaScript 代码来验证这一点，但是如果您可以编写一行代码来描述整个模式，为什么要这样做呢？

为此，您可以使用以下正则表达式:

```
 /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*\W).{8,}$/g 
```

这里有一个快速的片段供您测试:

```
let re = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*\W).{8,}$/g

let passwords = ["Fernando", "f3rn4", "F3rnand0!", "fernando123!"]

passwords.forEach( p => {
    let matches = p.match(re)
    if(!matches) console.log(p, "INVALID PASSWORD")
    else console.log(p, "is a valid password!")
})

/*
Fernando INVALID PASSWORD
f3rn4 INVALID PASSWORD
F3rnand0! is a valid password!
fernando123! INVALID PASSWORD
*/ 
```

本质上，我们使用了一种叫做“正面前瞻”的东西，它是引擎将在文本中搜索的表达式的一部分，不管它们在哪里。(？=...)是表达式中我们关心的那一段。

*   (?=.*[a-z])本质上意味着它将匹配任何后跟小写字母的字符。

*   (?=.*[A-Z])，就像前一个一样，但不是小写，如果后面的字符是大写，它将匹配。

*   (?=.*\d)将匹配后跟数字(一个数字)的任何内容。

*   (?=.*\W)匹配后跟符号的任何字符(换行符除外)。

*   。{8，}确保匹配的长度是*至少是*，8 个字符(任何字符感谢那里的点)。

*   ^和$确保匹配从一个单词的开头开始(感谢表达式开头的插入符号)并以该单词结束(感谢美元符号)。本质上，只允许全词匹配。不考虑部分匹配。

如果满足以上所有条件，则返回匹配，否则它不会是有效的密码。

### [](#email-format-checker)邮件格式检查器

我不得不实现这一点，可能在我做 Web 开发的时候已经实现了将近一百万次。你在注册表格中见过多少次“无效的电子邮件格式”的信息？如今,“email”类型的输入元素已经执行了这种验证。

也就是说，如果您正在进行后端验证，或者由于某种原因，无法访问该字段，正则表达式可以帮助您在一行代码中验证这种格式，而不是使用几个不同的 if 语句。

这里有一个神奇的正则表达式来完整地检查一个电子邮件地址:

```
 /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/ 
```

我知道，这是一个很大的数字，但是如果您仔细观察，您可以识别地址预期格式的所有三个部分:

首先，我们检查用户名是否有效，这只是检查是否使用了所有有效的字符，并且至少添加了其中一个字符(这就是末尾的“+”号的意思):

```
 ^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+ 
```

然后，我们检查@字符和主机名:

```
 @[a-zA-Z0-9-]+ 
```

同样，没有什么奇特的，主机名需要是字母数字，至少有一个字符。

最后，可选部分，负责检查 TLD(顶级域名)，或者基本上是域名扩展:

```
 (?:\.[a-zA-Z0-9-]+)*$/ 
```

你可以看出这部分是可选的，因为在结尾有一个。这意味着需要该组的 0 个或多个实例(该组由括号分隔)(因此。com 会匹配，但. co.uk 也会匹配)。

下面是一个简短的片段，展示了工作中的表情:

```
let emailRE = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/

let emails = ["fernando", "fernadno@", "fernando@test", "fernando@test.com", "valid_email123@host2.com", "a@1.com"]

emails.forEach( p => {
    let matches = p.match(emailRE)
    if(!matches) console.log(p, "INVALID EMAIL")
    else console.log(p, "is a valid email!")
})

/*
fernando INVALID EMAIL
fernadno@ INVALID EMAIL
fernando@test is a valid email!
fernando@test.com is a valid email!
valid_email123@host2.com is a valid email!
a@1.com is a valid email!
*/ 
```

### [](#smart-character-replacement)智能字符替换

模式验证到此为止，让我们做一些字符串修改，好吗？

这是正则表达式的另一个亮点，它允许您进行一些非常复杂的字符替换。对于这个特殊的例子，我将向你展示如何将 camel case 符号(你知道，就是你写 EverythingLikeThis 的那个)转换成普通符号。这是一个简单的例子，但应该足以向您展示如何使用[捕获组](https://www.regular-expressions.info/refcapture.html)。

现在，在看代码之前，想一想，如果没有正则表达式，你会怎么做？您可能需要一些大写字母的列表，并为每个字母运行替换例程。可能还有其他方法，但这是我能想到的最简单的方法。

下面是正则表达式替代:

```
let camelRE = /([A-Z])/g

let phrase = "thisIsACamelCaseString"

console.log(phrase.replace(camelRE, " $1")

/*
this Is A Camel Case String
*/ 
```

是的，就是这样！捕获组(括号和其中的所有内容)保存匹配部分，您可以用“$1”引用它。如果您有多个组，您可以增加该数字(2 美元、3 美元等等)。这里的要点是，表达式将只匹配字符串中任何地方的单个大写字符(由于后面的 g 标志),并且您将用它本身替换它(由于 replace 方法调用),前缀是一个空格。

现在让我给你看一个更复杂的字符串替换的例子。

### [](#old-school-function-to-arrow-function)旧校函数改为箭头函数

这个很有趣，因为您可以为它编写一些有趣的代码，或者在一个更现实的场景中，您可以使用 IDE 的搜索和替换功能来完成这个任务！

考虑到 arrow 函数相对较新，仍然有许多遗留代码没有使用它们，您可能倾向于切换，但是手动修改每个函数可能会花费很长时间，所以您可以使用正则表达式。

为了把事情说清楚，我想把这个:

```
function sayHello(first_name, last_name){
    console.log("Hello there ", first_name, last_name)
} 
```

成这样:

```
const sayHello = (first_name, last_name) => {
    console.log("Hello there ", first_name, last_name)
} 
```

因此，本质上，我们需要捕获函数的名称，它的参数列表和它的内容，然后重新构造它，这样我们就可以删除函数单词并创建新的常量。换句话说，我们需要三个捕获组，它们是:

```
 function (.+)(\(.+\))(\{.+\}) 
```

然后就是调用 replace 方法的问题了。同样，您可以使用您最喜欢的 IDE 来实现这一点，但是这里有一个快速 Node.js 脚本可以使用:

```
const fs = require("fs")

const regExp = /function (.+)(\(.+\))(\{.+\})/gms

fs.readFile("./test2.js", (err, cnt) => {
    console.log(cnt.toString().replace(regExp, "const $1 = $2 => $3"))
}) 
```

上面的代码将输出我们想要的箭头函数和您需要的任何其他函数。其他需要考虑的是我使用的标志。因为我们需要确保捕获新的行字符，所以我们需要进行多行匹配，并允许点字符也匹配这些字符。

说到这里，我想给你们展示的实际使用案例列表就此结束了。

## [](#conclusion)结论

希望到现在为止，通过上面的例子，您已经看到了正则表达式可以带来的强大功能，尽管它们看起来并不漂亮，但也不难理解。

因此，如果您还没有，请给他们一个机会，尝试将这个新工具添加到您的开发工具集中。

如果你不熟悉正则表达式，请在下面留下评论，告诉我们你是如何使用它们的！

下一次再见！