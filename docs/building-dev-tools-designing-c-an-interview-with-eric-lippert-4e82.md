# 构建开发工具和设计 Eric Lippert 访谈

> 原文：<https://dev.to/fahimulhaq/building-dev-tools-designing-c-an-interview-with-eric-lippert-4e82>

**关于:埃里克·李伯特**

Eric Lippert 在脸书设计编程语言。其他值得注意的工作包括在 Coverity 设计 C#分析器，以及在微软开发 Visual Basic、VBScript、JScript 和 C#编译器。他在 Twitter 上的账号是 [@ericlippert](https://twitter.com/ericlippert) ，并写了一篇关于编程语言设计和在 http://ericlippert.com编写代码的其他精彩冒险的博客。

Eric Lippert 是我们最新课程[Fixing Random:Techniques in c#](https://www.educative.io/courses/fixing-random-techniques-in-c-sharp)的创始人。

* * *

在 [Educative](https://www.educative.io/) ，我们可以与来自世界各地的开发人员聊天，了解他们的故事，他们是谁，是什么激励他们成为开发人员并教导他们周围的人。今天，我们采访了 Eric Lippert，了解了他的职业生涯和令人兴奋的 C#、system.random 类和概率编程世界。

# 简单介绍一下自己吧。你是如何开始编程的？你现在在做什么？

我总是对电脑着迷，甚至在我还是个小孩的时候。我九岁时开始编程，在纸上写出一些小动画程序，让火箭飞船在屏幕上飞来飞去。我不得不使用纸张，因为我没有电脑；放学后，我会在图书馆的 Commodore PET 上输入程序，看看我是否做对了。我的小学图书管理员是一个非常善良和耐心的人，几十年后我们仍然偶尔保持联系。

此后不久，我的父母给我买了一台 Commodore 64，我开始认真地编程。高中时，我在一家编译器公司做暑期工，在那里我第一次了解了专业人士是如何编程的。之后，我在滑铁卢大学攻读了计算机科学/应用数学联合学位，最后作为合作项目的一部分，在微软从事 Visual Basic 编译器的工作。那时，我很容易选择来到微软，继续从事语言方面的工作。

我在 2012 年离开了微软，去 Coverity 工作了几年，改进他们的 C#静态分析产品，现在我在脸书从事开发工具的工作。本质上，几十年来，我一直致力于开发工具；开发我想自己使用的各种工具非常有趣！

# 你在脸书设计什么编程语言？它们旨在解决什么问题？

最近，我在脸书从事各种开发工具的工作；其中两个我们已经发表了论文的项目是“GetAFix”项目，你可以在这里阅读[这里阅读](https://engineering.fb.com/developer-tools/getafix-how-facebook-tools-learn-to-fix-bugs-automatically/)和[这里阅读](https://arxiv.org/pdf/1902.06111.pdf)，以及与我的课程更相关的[hack ppl 概率编程语言](https://research.fb.com/publications/hackppl-a-universal-probabilistic-programming-language/)。

GetAFix 是一个实验性的开发工具，我们在其中分析我们认为是对特定缺陷的修复的大量代码更改，然后尝试推断出常见的修复模式是什么。当面对一个可能包含类似缺陷的新代码片段时，我们可以推断出在语料库中看到的哪个修复模式最有可能解决问题。然后，我们向开发人员提交建议的解决方案，大多数情况下，他们都认为这是一个好的解决方案。

HackPPL 在 Hack 中加入了概率编程，这是 PHP 的一种静态类型变体。我在 Hack 编译器上做了一些架构工作，并帮助构建了 PPL 扩展的第一个原型；很有趣的是看到它是如何演变的。

# 你的课程针对的是现代编程涉及统计，工具还没跟上。你能详细说明一下吗？

绝对的。我们在现代编程中面临各种各样的问题，包括统计或概率推理，但是许多现代的通用编程语言并没有提供任何一种统一的、一致的方法来帮助开发人员解决这些问题。例如，手机传感器有一些相关的误差，所以即使回答一个简单的问题，如“手机是移动还是静止？”涉及到一些概率推理，更不用说更复杂的问题，如“手机是否在会遇到施工延迟的路线上移动？”。

我们在现代编程中面临的几乎所有问题都有某种不确定性。想想旅行管理中的一些概率问题。用户需要更改其行程的概率是多少，或者任何飞机延误导致错过转机的概率是多少？用户最想要的推荐出现在前三个选择中的概率有多大？可以肯定地说，许多问题涉及对不可知的未来做出预测，如果我们的工具支持开箱即用的原则统计推理，我们可以做出更好的预测。

# 能解释一下概率规划吗？

正如面向对象编程是用对象编程，函数编程是用函数编程一样，概率编程是用概率编程。但是你指出这个同义反复的答案并没有告诉我们太多关于这些编程范例的事情是对的。

概率编程语言的基本思想是，我们在语言本身中构建了一个概念，即特定的值可以表示可能值的分布，程序使用这些值来做出选择:

*   [这张照片 80%可能是拉布拉多犬，15%可能是一堆炸鸡，5%可能是别的什么东西。](https://www.npr.org/sections/thesalt/2016/03/11/470084215/canine-or-cuisine-this-photo-meme-is-fetching)我们应该如何标记照片？

*   这个手机有 90%的可能向北移动，但是 50%的时间用户在这条路线上，他们在下一个街区停下来吃午饭；我们应该通知他们北面五个街区的施工延期吗？

*   这个用户有 20%的可能点击链接 X，但是有 30%的可能点击链接 Y；应该呈现哪个环节？(记住，两个链接关联的价值函数可能是不同的！)

*   该代码片段有 90%的可能性存在空解引用缺陷，如果缺陷存在，该修复有 70%的可能性移除该缺陷；我们应该提出解决方案吗？

基于控制流，程序然后基于旧概率的组合来推断新的概率。语言设计者的问题是:我们如何表示这些组合？我们如何表示“60%的电子邮件不是垃圾邮件，但 99%提到尼日利亚银行办公室的电子邮件是垃圾邮件”，并使用它来做出是否过滤传入电子邮件的正确决定？这样的程序看起来具体是什么样的，我们如何才能让开发人员编写这样的程序变得自然和容易？

# 程序员很好地表现了序列，却没有很好地表现随机性，有什么例子？C#中的随机技术如何满足这一需求？

在许多现代语言中，我们创造了一些工具，它们提供了一种统一的、一致的方法来解决涉及数据序列的问题；想想 C#中的 LINQ，或者 Python 中的序列理解。我们是怎么做到的？

我们首先提出一个所有序列共有的统一抽象，然后我们构建语言元素，允许开发人员以一种强大的方式组合这些抽象。有一些数学抽象是如此的“我们呼吸的空气”,以至于我们甚至不再认为它们是抽象的，比如加法或乘法。LINQ 在 C#中的天才之处在于，就像加法和乘法作为对数字的运算而内置于语言中一样，排序、过滤、分组、连接和投影运算作为对序列的运算而内置于语言中。正如你所说:

```
x = a + b * c; 
```

对这意味着什么有一种自然的直觉，所以你也可以说:

```
results = 
  from c in customers 
  where c.City == "London" 
  select c.LastName; 
```

即使您不是 C#程序员，也很容易看出我们有一个客户集合，我们在问“伦敦的客户姓什么？”。这些操作已经融入到语言中，就像加法一样。

我们可能会有一个相似的——事实上，几乎一模一样！–以类似方式嵌入编程语言及其库中的统计分布数据的方法。序列和分布之间的联系非常强；考虑分布的一种方式是，它是一个无限的值序列:六面骰子可以建模为一个无限的掷骰子序列，其中每个数字只出现一段时间。

也就是说:通常对序列执行的操作可能与通常对分布执行的操作有很大的不同，所以不要把两个相似的东西当作同一件事情来处理，这一点很重要。像“从这个分布中取样”或“从这个先验和这个观察值计算一个后验值”这样的操作，可以类似地抽象到类型系统中，然后由语言中的新特性来支持。但是，我们才刚刚开始看到这些功能出现在业务线语言中。

# 你能描述一下系统的一些缺点吗。随机以及 C#中的随机技术如何解决这个问题？

在 C#中有一个类叫做 System。Random 给出了两个结果:要么是 0.0 到 1.0 之间的分数的均匀分布，要么是上限和下限之间的整数的均匀分布。从历史上看，这个类的实现非常糟糕，因为使用它很容易编写出有问题的程序；我们希望使用库的自然、简单的方式也是正确的方式，但事实并非如此。

幸运的是，这些问题中的一些已经被修复。NET 核心，但真正的不足比糟糕的实现选择更深。真正的问题是，我们不仅仅需要一个均匀随机的样本来源；我们用概率解决的问题要复杂得多。

如果你的问题是，“人群中随机出现一个人患病的概率是 X%，而我们有一个诊断测试在 Y%的时间里是正确的；如果随机选择的一个人检测呈阳性，那么他们患这种疾病的概率是多少？”，那么答案既不是 X 也不是 Y，而是两者的组合，我们可以用数学方法算出来。

这种推理对人类来说很难做到，即使他们受过训练。但是，如果我们的编程语言中有表示先验概率、观察值和后验概率的元素，那么我们就可以编写非常简单的程序来正确回答这些问题，就像我们可以编写一个简单的程序来表示“给我伦敦客户的姓氏”。

学术界在研究语言的这些领域已经取得了很多进展；考虑将这些想法转化为通用语言是一个令人兴奋的前景。我对这个想法很感兴趣，所以我在我的博客中写了一长串文章来探索一些可能性。我进入问题空间是抱怨系统的缺陷。随机，所以我称之为“修正随机”,尽管它实际上是关于重新想象我们如何在像 C#这样的语言中处理概率数据。

# 你从事过 C#的哪些方面？

当我在微软工作的时候，我开始用 C#编程，那是这种语言的早期。正当 C# 3 的设计过程接近尾声时，我加入了 C#编译器团队，在那里我实现了很多语义分析器。然后我被邀请加入 C#设计委员会；我在微软工作了大约七年，从事 C# 4、5 和 6 的设计，并实现了编译器的“Roslyn”版本，同样主要集中在语义分析引擎上。我特别高兴在 C#的几个版本中从事过重载决策和类型推理引擎的工作；有一些有趣的问题需要解决！正如我之前提到的，我在 Coverity 工作了几年，开发了一个基于 Roslyn 的静态分析器，用于查找现实世界中 C#程序的缺陷。

# c#作为一门你如此热爱的语言，到底是什么？你可以去任何方向。为什么用 C#？

首先，C#是迄今为止我最了解的语言；我花了几千个小时仔细研究它，思考它的设计和实现。当面对一个新奇的问题时，我的思考过程通常是从“在 C#中我该如何做呢？”。

但这不是我喜欢的地方。C#是由专业、务实的程序员为专业、务实的程序员设计的。它坚定地属于面向对象语言家族，但是设计并不是教条式的面向对象；设计者着眼于函数式语言、声明式语言、研究性语言等等中哪些工作得很好，并结合这些语言中的最佳思想，同时又不忽略是什么让 C#感觉像 C#。与那个设计团队共事这么多年是一种荣幸。

# 在 C#世界里呆了这么长时间，你认为 C#的未来会怎样？

对于 C#在 C# 8 中的走向，我感到非常兴奋；在语言设计方面，在语言中包含不可空的引用类型是一个非常大胆的举措，它将提高开发人员的工作效率，减少影响用户的错误。但真正令人兴奋的是微软如何很好地接受了该语言的开源精神，以及这如何鼓励了该语言在 Windows 生态系统之外的传播，并进入更广泛的软件社区。实现这一转变并不容易，我为我的同事们接受新的工作方式而鼓掌。

我没有看到任何证据表明 C#中的概率编程在设计团队的考虑范围之内；我希望是现在！

# 你有自己的博客，编辑过书籍，还有其他事情，是什么激励你去教导你周围的人？

当我还是微软的应届毕业生时，我得到了一个很好的建议。20 世纪 90 年代，我从事 JavaScript 的设计和实现，我的经理对我说，“我希望你成为微软公认的 JavaScript 专家。找到问题的来源，回答问题；如果你不知道答案，那就研究直到你知道为止。”。

当然，现在很容易在 StackOverflow 上找到关于一个主题的任意多的问题，但在 20 世纪 90 年代，我花了很多时间在 JavaScript USENET 组和微软内部组上寻找关于语言的问题。我采纳了我的经理的建议，每次有我知道答案的问题，我都会发布一个完整正确的答案。如果有一个关于我的专业领域的问题，我没有一个正确、完整的答案，我会研究它，直到我有了为止。在很短的时间内，我就成了微软事实上的 JS 语言语义专家。这种跨组织的认可对职业发展有很大帮助。

在 21 世纪初，微软有一个公司倡议，以改善公司在开发者社区中的形象；它被认为是不露脸和冷漠的，这对于我们这些非常专注于提高客户生产率的内部人员来说似乎很奇怪。我们被强烈鼓励写博客和回答读者的问题，我也这样做了。我首先转储了我希望 JavaScript 文档中关于该语言的设计和实现的所有内容，然后继续讨论我在 Visual Studio tools for Office developers 方面的工作，然后是 C#团队。通过张贴大量可靠的内容并与开发人员社区进行良好的互动，发生了与 20 世纪 90 年代几乎相同的事情:我的博客成为了解 C#内幕信息的好去处。

从那以后，通过回答 SO 上的问题、编辑关于 C#的书籍等等来继续支持用户是很自然的事情。这很有趣，我从各种不同的角度学到了很多关于语言中痛点在哪里的知识。专家遇到的语言问题与初学者遇到的问题非常不同，但它们都很重要；通过改善许多初学者的学习体验，我们将培养下一代专家。

# 你曾提到 Educative，“这种交互式教学方法正是我希望看到的，我认为它有可能颠覆编程书籍市场”。你如何看待像 Educative 这样的平台扰乱这个市场？

长期以来，我一直将编辑技术书籍作为一种爱好，我自己也合写了几本书。我经常被要求写关于 C#的新书，我推后了它，主要是因为我没有写一本书所需的大量空闲时间。但我推迟编写新的计算机编程书籍的第二个原因是，在我看来，我们在纸上写下计算机程序，并期望人们像我九岁时那样从中学习，这似乎很奇怪。现在已经不是 80 年代了；电脑无处不在，事实上，现在很多人专门在电脑设备上阅读。

十多年来，我一直在我的博客中忍受这种缺陷；我真的非常希望人们能够在浏览器中看到代码，并编辑和执行它。我经常想，如果我要再写一本书那么长的东西，我会像一个完全互动的在线课程那样去做，而不是一本静态的、用墨水写在枯树上的书。

像 Educative 这样的平台，我可以在每节课中嵌入可运行的代码，是改善这种情况的良好开端。这是令人兴奋的，因为这是一个开始；要让它变得更具互动性，还有很多事情可以做。举个例子，我的课里面有大量的图形展示了不同的概率分布，但都是静态图像；它们也可以是实时的和交互式的，允许用户调整不同的参数，看看会发生什么。

从我很小的时候起，我们就一直在试图找出如何将计算机融入教学的方法，结果是喜忧参半；我们可能最终会拥有必要的工具，使教育者更容易以丰富和互动的方式与学生联系。

# 固定随机:C 调的技巧

很明显，用 C#进行概率编程是很困难的，尤其是在使用 system.random 类时，正如 Eric 提到的。

在他的课程中，Eric 向你展示了改进系统的不同方法。如果你是一个 C#迷，希望探索使用这种语言的新方法，同时加深你对概率编程的理解，你会发现这门课程很有价值。