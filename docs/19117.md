# React 的未来，悬念迭起

> 原文:[https://dev . to/bnevilleoneill/the-future-of-react-unfolding-with-suspension-490g](https://dev.to/bnevilleoneill/the-future-of-react-unfolding-with-suspense-490g)

[![](../Images/73052e001e6ae175516dcb2144b6f898.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--LdL340xe--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/31ua4pkk9itbc327xv9m.jpg)

自从 React 团队发布了他们的 16.x 版本，它就像风暴一样席卷了整个社区。该集合中一些最酷的新增功能是挂钩、延迟加载、悬念和缓存 API。

这不仅仅是另一篇关于如何编写钩子的文章，而是关于 React 未来的展望！如果您从未听说过 Hooks，或者 React 中的任何其他新 API，那么这篇文章将是一个让您对未来感到兴奋的良好开端。

随着文章的深入，我们将涵盖两个新概念，预计将于 2019 年在 Q2 发布:

*   如何使用悬念获取数据
*   如何使用 react-cache

我已经很兴奋了！但是，在我们深入探讨之前，让我们放慢速度，快速回顾一下。

[![LogRocket Free Trial Banner](../Images/4aa67f42a82d61c79b61acb13eae9479.png)T2】](https://logrocket.com/signup/)

## [](#react-hooks)反应钩

在 React 16.8 中，钩子正式成为稳定版本的一部分。它在高层次上解决了一些问题:

*   通过采用使用函数编写一切的概念，它使得编写代码更加模块化，更易于维护
*   不鼓励使用使代码难以理解的 [HOCs](https://reactjs.org/docs/higher-order-components.html) 和其他复杂函数
*   放弃使用复杂的[生命周期](https://hackernoon.com/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0)，如`componentDidMount`、`componentDidUpdate`等。，这需要我们编写重复的代码

如果你想了解更多细节，[查看这里](https://reactjs.org/docs/hooks-intro.html#motivation)。

所以，让我们来看看 React Hooks 的演示，看看一个典型的应用程序会是什么样子！
[https://codesandbox.io/embed/3rm5jk86wm](https://codesandbox.io/embed/3rm5jk86wm)T2】

## [](#reactlazy)React .懒惰

这个名字真的泄露了它的意图！当我们想延迟加载组件时，我们需要它:

```
const _TodoList_ = _React.lazy_(() => import("./containers/todoList")); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

借助使用 webpack 的动态导入，我们可以做到这一点；它有助于创建包，这提高了我们的页面加载速度。让我们玩一个演示吧！只需返回到 Codesandbox 演示链接，将导入更改如下:

```
const TodoList = React.lazy(() => import("./containers/todoList"));
const CompletedList = React.lazy(() => import("./containers/completedList"));
const AddNewTask = React.lazy(() => import("./containers/addNewTask")); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

请注意下图中单独的包是如何创建的。[![😄](../Images/9d8896d5f6bd19885bcc645121f6f6a8.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--8ULO1NJe--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f604.png)

[![Bundles Created With Webpack](../Images/ad10bbcacaadafbe25e89bc22d24ec03.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--ZazKiU-t--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2019/06/bundles-created.png%3Fresize%3D2484%252C380%26ssl%3D1)

## [](#suspense)悬念

悬念使用起来相当简单。让我们借助一个代码演示来更好地理解这一点:

```
// https://codesandbox.io/s/new-6m2gj
import React, { useState, useEffect, Suspense } from "react";
import ReactDOM from "react-dom";
import todoListData from "./containers/todoList/todolistData";
import Header from "./containers/header";
import Clock from "./components/Clock";
import "./styles.css";

const TodoList = React.lazy(() => import("./containers/todoList"));
const CompletedList = React.lazy(() => import("./containers/completedList"));
const AddNewTask = React.lazy(() => import("./containers/addNewTask"));

function App() {
  const { todolist } = todoListData;
  const [todoListPayload, setTodoListPayload] = useState(todolist);
  const [completedTodoList, setCompletedTodoList] = useState([]);

  const addTodoTaskHandler = value => {
    // addTodoTaskHandler
  };

  const removeTodoTaskHandler = ({ id }) => {
    // Remove from the set of todo list
  };

  const completeTodoTaskHandler = ({ id }) => {
    // Get item to remove
  };

return (
    <div className="App">
      <Header title={"My Tasks"} />
      <Clock />
      <div className="PageLayout">
        <Suspense fallback={<div>Loading...</div>}>
          <TodoList
            payload={todoListPayload}
            completeTodoTaskHandler={completeTodoTaskHandler}
          />
          <CompletedList list={completedTodoList} />
          <AddNewTask addTodoTaskHandler={addTodoTaskHandler} />
        </Suspense>
      </div>
    </div>
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

你可以在这里找到[的演示链接](https://codesandbox.io/s/new-6m2gj)，如果你想玩的话。

如果我们检查演示中的代码，我们会看到:

```
<Suspense fallback={<div>Loading...</div>}>
  <TodoList
     payload={todoListPayload}
     completeTodoTaskHandler={completeTodoTaskHandler}
   />
  <CompletedList list={completedTodoList} />
  <AddNewTask addTodoTaskHandler={addTodoTaskHandler} />
</Suspense> 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

就像用悬念包裹组件一样简单。我们使用`React.lazy()`缓慢地加载了一些组件— `TodoList`、`CompletedList`、`AddNewTask`。由于在内部它会为每个包生成包，在较慢的网络条件下，可能需要一些时间来加载它们。

“暂停”将通过显示一个`fallback`，如**装载……**或任何其他组件，如旋转器或类似组件，来自动处理此问题。

## [](#diving-deeper-into-the-future)深入未来

太好了！我们简短的回顾很激烈。现在让我们用悬念获得更多的乐趣。

### [](#suspense-and-reactcache)悬念与反应——缓存

等等，我们不是已经谈过悬念了吗？那么，如果我告诉你当一个 API 被调用时，悬念也能处理我们的加载状态，会怎么样？但为此，我们真的需要深入研究 API 并更好地理解它。

经过一番挖掘和研究，我终于找到了 [Shawn Swyx Wang 的![🌟](../Images/08178b0045322ce88d106711347dd532.png)](https://twitter.com/swyx) GitHub 资源库，我想直接引用他的 [doc](https://github.com/sw-yx/fresh-concurrent-react/blob/master/apis/react-suspense.md) :

> 反应暂停是组件在从缓存加载数据时暂停渲染的一种通用方式。
> 
> 它解决的问题:渲染时 I/O 受限。

好的，“从缓存中加载数据”给了我一个提示，但是我需要更多的信息来了解如何真正处理这个 API。

肯特·c·多兹在他的[理论家课](https://egghead.io/lessons/react-learn-fundamentals-of-react-suspense?pl=react-hooks-and-suspense-650307f2)中教授了一个重要的概念:如果我们抛出一个承诺，悬念会自动知道一个 API 请求已经被调用。

```
import React, { Suspense } from "react";

fetchArticles() {
  // Some fetch API fetching articles
}

let isRequestCalled = false;
function Content() {
  let result = [];
  if (!cache) {
    const promise = fetchArticles();
    isRequestCalled = true;
    throw promise; // Let suspense know
  }
  return <div>Article</div>;
}

const Articles = () => {
  return (
    <div>
     {/* Yay promise is thrown */}
      <Suspense fallback={<div>loading...</div>}>
        <Content />
      </Suspense>
    </div>
  );
};

export default Articles; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

当然，这不是处理代码的最佳方式；它看起来有点粗糙。所以我们试着用 react-cache 来更好地处理这段代码:

```
import React, { Suspense } from "react";

import { unstable_createResource as createResource } from "react-cache";

function fetchArticles() {
  // Some fetch API fetching articles
}

const politicalArticles = createResource(fetchArticles);

function Content() {
  const result = politicalArticles.read(someKey);
  return <div>Article</div>;
}

const Articles = () => {
  return (
    <div>
      <Suspense fallback={<div>loading...</div>}>
        <Content />
      </Suspense>
    </div>
  );
};

export default Articles; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

从 react-cache 通过回调创建一个资源，返回一个承诺。

好吧，悬疑要知道它必须显示加载状态，它需要的只是一个承诺。它将继续显示装货状态，直到承诺得到解决。

> 然而，这是实验性的。我相信你会遇到错误，所以不要担心，它明确提到 react-cache 仍在开发中。

只是提醒一下，确保在组件内部使用`read`方法；否则，它将抛出一个错误。

```
// A snippet from the React-cache library

function readContext(Context, observedBits) {
  const dispatcher = ReactCurrentDispatcher.current;
  if (dispatcher === null) {
    throw new Error(
      'react-cache: read and preload may only be called from within a ' +
        "component's render. They are not supported in event handlers or " +
        'lifecycle methods.',
    );
  }
  return dispatcher.readContext(Context, observedBits);
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

如果您有兴趣阅读 react-cache 源代码，请查看这个[链接](https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js)。

## [](#congratulations)恭喜恭喜！

我们现在赶上了 React 的不久的将来，有一件事是显而易见的:React 团队希望使 API 尽可能简单。

越来越多的库正在转向函数式编程，这也让我很兴奋。这种模式肯定会彻底改变我们编写前端的方式。我也在关注 concurrent React——如果你感兴趣，可以查看官方的[路线图文档](https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching)。React——缓存和暂停是并发 react 的一些特性。【T2![😎](../Images/d31c955371df0523dd17600875117306.png)

在 [**Twitter**](https://twitter.com/daslusan) 上关注我，获取关于新文章和最新前端开发的更新。还有，在 Twitter 上分享这篇文章，帮助其他人找到它。分享是关怀。

* * *

## [](#plug-logrocket-a-dvr-for-web-apps)Plug: [LogRocket](https://logrocket.com/signup/) ，一款适用于网络应用的 DVR

[![LogRocket Dashboard Free Trial Banner](../Images/0abf868fe5ccbed99d71cb8d9e81ed98.png)](https://logrocket.com/signup/)

[log rocket](https://logrocket.com/signup/)是一个前端日志工具，让你可以回放问题，就像它们发生在你自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。

除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面应用程序重新创建像素级完美视频。

[免费试用](https://logrocket.com/signup/)。

* * *

带着悬念展开的帖子最先出现在[博客](https://blog.logrocket.com)上。