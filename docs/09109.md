# 编译器系列第 3 部分:Rust

> 原文：<https://dev.to/miiizen/compiler-series-part-3-rustc-5e9>

这篇文章将是另一篇关于生产编译器的文章，这次是关于 Rust 语言的。

*免责声明！*我前阵子写了这篇文章，还没有检查修改了多少！编译器和语言还在不断成熟，所以变化是频繁的。

Rust 项目是一个新系统语言的编译器。编译器和标准库是用 Rust 自己编写的，该项目由 Mozilla 赞助。它的优点是“快得惊人”，防止 segfaults 和保证线程安全。

Rust 是基于多重范式。它从函数式编程中获取变量可变性/借用规则，确保线程安全并防止数据竞争。例如，将变量作为参数传递给函数后，该变量就不能再使用了，因为它已从作用域中删除。这些所有权规则增加了语言的安全性，因为大多数潜在的问题都会被编译器发现。如果程序能够编译，您可以相当有信心不会有很多意外的运行时错误。

编译过程不同于 gcc，尽管基本思想是相同的。

## 解析<sup id="fnref1">T3】1T5】</sup>

虽然解析可以通过编写有限状态机来完成，但是 rust 解析器是手工编写的。首先，lexer 将输入源作为 UTF-8 文本，并从中生成标记。这些令牌然后被放入令牌树 <sup id="fnref2">[2](#fn2)</sup> 。这个树是输入源和 AST 之间的中间阶段。这个阶段并不总是必要的，这取决于语言的复杂程度。然后使用递归下降来生成真正的 AST。AST 不包括输入中不必要的位，如括号。它们可以在这一点上被暗示。

## 膨胀

此时，AST 被忽略。在适当的位置，注入外部代码，如标准库和其他指定的模块。除此之外，还扩展了宏。这与 GCC 方法相反，在 GCC 方法中，宏是通过直接操作源代码来处理的。测试(也是用#语法定义的)在这个阶段被构建到一个工具中，并被注入到 AST 中。AST 被赋予节点 id 供以后使用，并且可以选择在此时输出。

## 分析

语义分析发生在这个阶段。这包括遍历 AST 并执行不同的转换。在这个阶段，AST 变成了 HIR，*高级中级代表*。这与 AST 基本相同，所以我们不需要太担心细节。许多任务都在这里完成，包括但不限于:

*   名称解析——检查标识符是变量、函数还是模块。
*   找到`main`方法，因为这是程序的入口点
*   类型检查——确定表达式的结果类型
*   检查与静态、常量和私有类型相关的规则是否得到遵守
*   匹配检查- Rust 的模式匹配规则在这里执行
*   死代码检查——如果检测到无法访问的代码，将发出警告

这些步骤本身并不是优化，更多的是语言特性的实现。

后来，HIR 被翻译成 MIR，*中级中级代表* <sup id="fnref3">[3](#fn3)</sup> 。这打破了相当高级的抽象表示和最终的低级表示之间的一大步。例如，所有控制流、循环和匹配都使用`goto` like 语句来表示。在这个阶段进行借用检查，确保遵守规则，并在将 MIR 转换为 LLVM IR 之前进行一些优化。

## LLVM

LLVM 是一套用来帮助编写编译器的工具。现在，我们只需要知道它接受源代码的低级中间表示作为输入，并为指定的平台生成字节码。

第一项工作是将 Rust 的板条箱翻译成 LLVM 的模块。“板条箱”和“模块”是相似的概念，只是需要翻译的表述技术问题。
在这一步之后，LLVM 运行自己的优化通道。这些确保输出程序尽可能高效。Rust 有许多自己的优化实现，LLVM 可以运行，但众所周知很慢。尽管效率很高，但 LLVM 的编译时间通常很慢。
一旦 IR 得到优化，就会生成代码。LLVM 以指定的输出格式将目标文件或程序集写入磁盘。

## 链接

如果发出了目标文件(例如，如果我们正在构建一个本地库或者我们的项目包含多个文件)，最后一步是链接这些文件。这是通过调用平台的 c 编译器(如 cc)并使用它将目标文件链接成可执行文件来实现的。

我想在我的编译器中使用 LLVM，因为它是一个使用良好的系统，可以使代码生成更加简单。

* * *

1.  [“rust 编译器的更详细之旅”——汤姆·李](https://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/) [↩](#fnref1)

2.  [rust/ast . RS at master rust-lang/rust github](https://github.com/rust-lang/rust/blob/master/src/libsyntax/ast.rs#L545-L580)↩

3.  [《mir 简介》rust 编程语言博客](https://blog.rust-lang.org/2016/04/19/MIR.html) [↩](#fnref3)