# 依赖地狱

> 原文：<https://dev.to/xanderyzwich/dependency-hell-1o4d>

## 传统最佳实践

人们普遍认为，在多个地方需要的任何代码都应该被抽象到某个地方。逻辑重复的类获取方法，逻辑重复的包获取类，逻辑重复的项目获取依赖项目。有道理。您不希望在许多地方更新代码，只需做一次，让它渗透到代码库中，当您手动将 jar 文件从一个项目的输出移动到另一个项目中使用时，您可以非常有信心事情会保持稳定。

## 向云！

一旦你将一个遗留的 java web 服务转移到现代，就会发生一些事情。SOAP 变成了 REST(我希望如此)，XML 变成了注释和 Java 配置类，您从传统的 servlet 容器(Tomcat、WebLogic 等)转移到 Springboot jars(通常内置了 Tomcat)。在 Y2K 和云原生应用程序部署之间应该发生的事情是一个带有工件存储库的现代构建工具。我们正从 Ant 转移到 Gradle，并利用 Nexus 工件库作为我们的依赖项。

这一切都很棒，我非常享受在这个职位上学到的东西。但是，我们的应用程序有一个由我们拥有的 6 个“公共”依赖 jar 组成的蜘蛛网。我们目前正在升级的应用程序使用了其中的 4 个。两个数据库(逻辑的)各有一个，然后还有一个超级依赖，所有其他的都继承自这个超级依赖。让事情变得更加困难的是，我们正在开发的应用程序直接依赖于超级 jar 以及三个依赖于超级 jar 的 jar。

**输入心痛**

Gradle 是一个很棒的工具。在我们让它工作之后，我意识到本地环境设置意味着在正确的 git 分支上，并设置一些环境变量来运行应用程序，这样我们就不会在处理 CI/CD 所做的事情时意外地提交密码。然而，在前进的道路上，有许多痛点。很明显，日志依赖隐藏在我们使用的每一件事物中，很明显，SLF4J 正在被拉低。

我们被告知，我们应用程序的最初架构师和开发人员绝对是个天才。我们没有。这个东西实现了它自己的 hibernate、属性处理器、应用程序上下文和许多其他东西，这些都是通过现代构建工具、框架和依赖注入免费获得的；许多这些特性都是在我们的依赖关系 jar 中实现的。特别是应用程序上下文和属性处理程序一直在超级 jar 中实现。他们需要访问应用程序所在文件系统上的特定属性文件。我可以看到，这将使几十个应用程序的管理更加统一和易于理解。当您部署到 Cloud Foundry 环境中时，文件系统并不完全由您支配。我们已经克服了这个问题，采用了一个配置服务器，通过一个 web 服务器从 git 提供属性文件，使它们可以立即被任何请求它的服务器使用。超级罐子不喜欢那样。找不到文件遇到空指针，一切中断。重构这四个依赖项已经超出了我们与帮助我们的 cloud foundry 团队为期七周的合作范围。

## 方案

我们最终设法快速解决了一些问题，并且我们的业务团队给了我们信心，我们将在未来对我们的应用程序进行彻底的重新设计，我们将有机会纠正那些给我们带来如此多问题的东西。

Java 配置类取代了我们以前使用的每个 XML 文件，我们能够使用来自配置服务器的属性来强制提供自制的应用程序上下文，并克服了一些问题。

后来，我们发现我们的 Junit 设计有一个问题，这意味着初始化试图读取相同的属性文件，我们能够通过快速修复超级 jar 来克服这个问题，直接使用`"${foo}"`符号并注释掉文件读取。

gradle 构建文件需要一个**吨**的排除，以防止复制依赖关系(可能基于也可能不基于不同的组)。我们已经决定，这些共同的罐子不应该如此相互依赖，因为我们目前需要接触六个项目，以使一个工作。

如果你有任何故事，建议，或解决方案，你遇到了这样的事情，那么我请你评论。

[undraw.co 的封面图片](https://undraw.co/)