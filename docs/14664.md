# 实际开发实践

> 原文:[https://dev.to/rfornal/practical-development-practices-301j](https://dev.to/rfornal/practical-development-practices-301j)

几天前，我不得不去寻找什么是可靠的原则。我在大学里学过这些吗？然后，我找到了利斯科夫替代原理，开始疯狂地试图回忆那些年前的那些计算机科学课。

一旦恐慌和压力消失，我决定集中思想，写下我所看到的基本“实用”原则及其应用。

随后将会有一篇关于实用前端原则的更“以代码为中心”的文章。

## [](#nothing-is-set-in-stone)没有什么是一成不变的

当编写代码时，开发人员必须考虑:他们工作的组织，他们工作的团队，以及他们试图解决的一般和特殊问题。没有适用于所有情况或场景的原则或实践。

*   代码是否正确？
*   我们如何编写可测试的代码？
*   我们如何写出干净或好的代码？

## [](#kiss-keep-it-simple-stupid)K.I.S.S .(简单点，笨蛋)

[![](../Images/c677bd80b22791a53e84224db6d78414.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--yyH5wSNb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/utz4fnutaq3e715jwowg.png)

这个原则可以贯穿我们的一生。然而，除了最琐碎的编程项目之外，它在所有项目中都是非常必要的。

它在项目范围被定义的早期就开始了。当范围足够简化的时候，再上一层楼(简化更多)；范围蔓延是不可避免的，所以从尽可能小的范围开始。

但是即使开发已经开始，也要保持简单。复杂的代码需要更长的时间来设计和编写，更容易出现错误。此外，以后修改复杂的代码会更加困难。

请记住，完美的实现，不是在没有更多可以添加的时候，而是在没有什么可以拿走的时候。

## [](#dry-dont-repeat-yourself)D.R.Y .(不重复自己)

这是软件开发中的一个原则，旨在处理代码的重复(针对代码中的重复模式)，用抽象来代替它，或者使用数据规范化来避免冗余。

D.R.Y .原则指出“每一项知识在一个系统中必须有一个单一的、明确的、权威的表示。”当成功地应用了 D.R.Y .原理时，系统中任何单个元素的修改都不需要改变其他逻辑上不相关的元素。此外，逻辑上相关的元素都以可预测的方式统一变化，因此保持同步。

### Y.A.G.N.I .(你不需要它)

这意味着，“不要解决你没有的问题。”

Y.A.G.N.I .的第一个论点是，虽然假设需要某个功能，但我们很可能是错的。毕竟，敏捷方法的背景是接受需求变化。

### [](#write-clean-code-not-clever-code)写干净的代码，而不是聪明的代码

大多数开发人员 ***喜欢耍小聪明*** 。事实上，他们进入这个领域可能是因为他们喜欢聪明。开发人员喜欢编写短小精悍的代码，这些代码比任何人想象的都要快，同时也让所有的读者感到困惑。

问题是发展的世界正在迅速变化。几年前开始发生的根本性转变已经真正固化。这种转变是软件的复杂性已经从应用程序的较小部分转移到应用程序的整体设计，因此几乎所有代码的首要任务都应该是读和写的容易程度，因为它们所涉及的系统已经变得复杂得多。

但是作为开发人员，这些规则同样适用，我们不再会因为编写一个解析速度提高 5%的例程而得到好评，尤其是当它使代码更难阅读、更长时间编写、更长时间调试或更难测试时。这种类型的优化(在很大程度上)只是一种无意义的练习，通常只为开发人员的自我而写。

## [](#solid-principles)坚实的原则

### [](#single-responsibility-principle)单一责任原则

软件实体(类、模块、函数等。)应该对软件功能的单个部分负责，并且这种责任应该完全由类来封装。

### [](#openclosed-principle)开闭原理

软件实体应该对扩展开放，但对修改关闭”；[1]也就是说，这样的实体可以允许在不修改其源代码的情况下扩展其行为。

### [](#liskov-substitution-principle)利斯科夫替代原理

该原则定义了一个超类的对象应该可以被它的子类的对象替换，而不会破坏应用程序。这要求你的子类的对象以和你的超类的对象相同的方式运行。

子类的重写方法需要接受与超类方法相同的输入参数值。这意味着代码可以实现限制较少的验证规则，但不能在子类中实施更严格的规则。否则，任何在超类的对象上调用此方法的代码，如果用子类的对象调用它，都可能导致异常。

类似的规则也适用于方法的返回值。子类方法的返回值需要遵守与超类方法的返回值相同的规则。

*   方法签名必须匹配(必须采用相同的参数)。
*   任何方法的前提条件都不能大于其父方法的前提条件。
*   任何继承的方法都不应该有更多改变该方法返回的条件，比如抛出异常。
*   发布条件必须至少等于其父条件。
*   继承的方法应该返回与其父方法相同的类型
*   异常类型必须匹配
*   如果一个方法被设计为在出错时返回特定的异常，那么继承方法中的相同条件必须返回相同的异常。

### [](#interface-segregation-principle)界面偏析原理

不应该强迫任何客户端依赖它不使用的方法。非常大的接口应该被分割成更小更具体的接口，这样客户就只需要知道他们感兴趣的方法。这个原则旨在保持系统的解耦，从而更容易重构、更改和重新部署。

### [](#dependency-inversion-principle)依存倒置原则

当遵循这一原则时，从高级策略设置模块到低级依赖模块建立的传统依赖关系被颠倒，从而使得高级模块独立于低级模块实现细节。该原则指出:

*   高层模块不应该依赖低层模块。两者都应该依赖于抽象(例如接口)。
*   抽象不应该依赖于细节。细节(具体的实现)应该依赖于抽象。

## [](#separation-of-concerns)分离顾虑

将计算机程序分成不同部分的一种设计原则，每一部分处理一个单独的问题。关注点是影响计算机程序代码的一组信息。很好地体现这一原则的代码被称为模块化程序。模块化以及关注点的分离是通过将信息封装在一段具有明确定义的接口的代码中实现的。

关注点的分离为程序设计、部署或使用的某些方面带来了更高的自由度。其中的共同点是简化和维护代码的自由度更高。当关注点被很好地分离时，模块重用以及独立开发和升级的自由度就更高了。因为模块将它们关注点的细节隐藏在接口后面，增加的自由度导致以后改进或修改单个关注点的代码部分，而不必知道其他部分的细节，也不必对那些部分进行相应的更改。模块还可以公开接口的不同版本，这增加了以渐进方式升级复杂系统的自由度，而不会暂时丧失功能。

关注点分离是一种抽象形式。与大多数抽象一样，必须添加接口，并且通常要执行更多的 net 代码。因此，尽管良好分离的关注点有很多好处，但通常会有相关的执行惩罚。

## [](#coupling)耦合

软件模块之间的相互依赖程度；对两个例程或模块连接紧密程度的一种度量；模块之间关系的强度。

耦合通常与内聚相反。低耦合通常与高内聚相关，反之亦然。低耦合通常是结构良好的计算机系统和良好设计的标志，当与高内聚结合时，支持高可读性和可维护性的一般目标。

紧密耦合系统往往表现出以下发展特征，这些特征通常被视为缺点:

*   一个模块的变化通常会引起其他模块变化的连锁反应。
*   由于模块间依赖性的增加，模块的组装可能需要更多的努力和/或时间。
*   特定的模块可能更难重用和/或测试，因为必须包含依赖模块。

## [](#cohesion)衔接

这指的是一个模块内部的元素属于一起的程度。在某种意义上，它是一个类的方法和数据与该类所服务的某种统一目的或概念之间的关系强度的度量。在另一种意义上，它是类的方法和数据本身之间关系强度的度量。

内聚性是一种有序的测量类型，通常被描述为“高内聚”或“低内聚”。具有高内聚性的模块更受欢迎，因为高内聚性与软件的一些期望特征相关，包括健壮性、可靠性、可重用性和可理解性。相比之下，低内聚性与不良特性相关，例如难以维护、测试、重用，甚至难以理解。

内聚通常与耦合形成对比，这是一个不同的概念。高内聚通常与松散耦合相关，反之亦然。

如果满足以下条件，内聚力会增加:

*   嵌入在类中的功能，通过它的方法访问，有许多共同之处。
*   方法通过避免粗粒度或不相关的数据集来执行少量的相关活动。

高内聚(或“强内聚”)的优点是:

*   降低模块复杂性(它们更简单，操作更少)。
*   增加了系统的可维护性，因为域中的逻辑变化影响较少的模块，并且一个模块中的变化需要其他模块中较少的变化。
*   增加模块的可重用性，因为应用程序开发人员将更容易在模块提供的内聚操作集中找到他们需要的组件。

虽然原则上一个模块只由一个单一的原子元素组成就可以拥有完美的内聚性——例如，拥有一个单一的功能——但实际上复杂的任务不能由一个单一的简单元素来表达。因此，单元素模块的元素要么太复杂，无法完成任务，要么太窄，因此与其他模块紧密耦合。因此，内聚性与单元复杂性和耦合性是平衡的。

## [](#avoid-premature-optimization)避免过早优化

开发商很贵，而且似乎供不应求。他们面临的最大挑战之一是确保他们充分利用时间。在考虑为性能调优和优化分配多少时间时，需要不断进行权衡。

应用程序的性能和可伸缩性非常重要。开发人员首先需要确保他们正在构建正确的特性集。

## [](#write-self-documenting-code)编写自我记录代码

自文档化源代码遵循命名约定和结构化编程约定，这些约定允许在没有预先特定知识的情况下使用系统。

自我记录系统的常见目标包括...

*   让源代码更容易阅读和理解。
*   最小化维护或扩展遗留系统所需的工作。
*   减少系统用户和开发人员查阅二级文档来源(如代码注释或软件手册)的需要。

## [](#conclusions)结论

虽然坚实的原则为开发实践指明了方向，但我不认为它应该是我们用来确保编写好的、干净的(以及灵活的和可维护的)代码的全部。作为开发人员，我们应该知道和需要注意的还有很多。

*   没有什么是一成不变的
*   保持简单，笨蛋(K.I.S.S .)
*   不要重复你自己
*   你不会需要它的
*   写干净的代码，而不是聪明的代码
*   坚实的原则
*   关注点分离

*   连接

*   内聚力

*   避免过早优化

*   编写自我记录的代码

还有其他的事情应该被添加到这个列表中吗...但这些是我经常使用的原则和模式，即使我必须深入挖掘才能记住描述背后的模式。