# 对 Rust/Wasm 的探索

> 原文:[https://dev.to/dystroy/an-exploration-or-rust-wasm-50gp](https://dev.to/dystroy/an-exploration-or-rust-wasm-50gp)

几天前，我决定需要了解 Rust/Wasm 开发的现状和前景。

为了对基础的稳固性和强度有一个清晰的概念，我不想讨论各种框架的优点和问题，我想看看真正的交易，没有多余框架和库的 Rust/Wasm。

我不想混合使用 JavaScript 来完成困难的事情，我想看看你是否能从 rust 开始做任何事情，以及你的体验在多大程度上和经典的 Rust 一样积极。

所以我决定用纯 Rust/Wasm 写井字游戏。

在我继续旅程之前，[这是结果](https://dystroy.org/wasm-tictactoe/)。

没什么特别的，但它让我测试我想测试的东西。它工作了。如果你打开浏览器开发工具的网络标签，你会注意到文件相当小，没有轮询或无用的重绘。

[WebAssembly](https://webassembly.org/) 是一种二进制指令格式，您可以给任何最近的浏览器，它将在沙箱中执行，并访问浏览器。因此，构建 rust+wasm 应用程序主要是将 rust 文件编译成一个. wasm 文件，您可以用它代替通常的 JavaScript 文件提供给浏览器。你的应用程序仍然会包含一个小小的 bootstraper 来加载你的 wasm 文件并把它给浏览器，我希望这个假象会很快消失。

等待探索者的第一个障碍是大多数教程充满了不需要的配置和工具，例如，当你只想学习 Rust/Wasm 时，使用 npm、webpack 和一个框架。这相当于先安装 Angular、jQuery、Gulp 来学习 JavaScript。

这里有一个简单的例子: [wasm-bindgen 没有 bundler](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html) 。这只是一个“Hello World ”,但它让我们走上了正轨。

基础是使用 *wasm-pack* cargo 工具构建 wasm 文件。您将只使用三个库:`wasm-bindgen`链接 JavaScript 和 wasm 世界，`js_sys`提供对标准内置对象的访问，如 JSON 解析器、二进制数组或数学函数(在 wasm 中，您不能访问标准的 Rust 库，即使是那些可以用沙箱保护的库，因为它们必须嵌入 Wasm 文件中)，以及`web_sys`提供对浏览器世界(包括 DOM)的访问。

所以，感谢这个例子，我只是手工写了几个文件(不，你不需要生成器)，那就是`Cargo.toml`文件和`src/lib.rs`。

这就够了。你只需要执行

```
wasm-pack build --target web 
```

然后*瞧，你有一个包含 wasm 文件和标准 JS bootstraper 的 pkg 目录。*

当然，就像 JS 文件不能成为应用程序一样，Wasm 文件也不能。所以我添加了一个 HTML 文件和一个 CSS 文件(你应该看看 HTML 文件。

从那里，您只需通过 HTTP 打开您的文件(在配置服务器来提供带有`application/wasm` mime 类型的`.wasm`文件之后)。不需要发布到 npm 存储库，也不需要使用另一个打包程序，您可以使用自己选择的工具链，在您的应用程序真正需要时保留这些任务，您知道为什么。

此时，我刚刚复制了示例中的代码，该示例添加了一个以“Hello World”作为内部 HTML 的元素。

下一步是添加井字游戏的元素，矩阵。
由于对 DOM 非常了解，我毫不费力地在 web_sys 中找到了正确的方法和结构(附件 1: [元素](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Element.html))。我可以直接用 rust 写元素。它足够干净，但是你很快注意到这个接口给了你一个较少类型的系统，因为一些方法返回你一些值，这些值可能是，也可能不是你想要的类型(例如，如果你创建一个带有`document.create_element`的节点，你得到的`Node`可能是，也可能不是一个`HtmlElement`，这取决于标签)。虽然这很容易被隔离在一个小的助手库中，所以这没什么大不了的。

浏览一下 [web_sys](https://rustwasm.github.io/wasm-bindgen/api/web_sys/) ，您可能会注意到添加事件监听器的方法也在这里。
web-sys 包含了一个让 rust 闭包和 JavaScript 闭包交互的工具。这并不像看起来那么简单。

现在它看起来很好，我们只需要设计我们将如何干净地保持我们的应用程序状态，并有一个正常的基于事件的 web 应用程序不断添加和删除元素和事件侦听器，处理事件，等等。

只是一个 web 应用的正常生活，带着 Rust 的理智，完美的梦想。

但事情没那么简单。

*   您必须保留一个对 rust 闭包的引用，否则 JavaScript 事件处理程序将在调用时失败(在运行时...没有编译时检查)。也有可能泄露它们，但我们正在寻找一个实际应用的可行解决方案，所以这是绝对不可能的。
*   只有一个 UI 线程，在这个线程上调用您的事件处理程序。
*   Rust 应用程序不应该有可变的静态状态。
*   您不能将处理程序存储在 Arc 后面，因为指向 JS 的指针在线程之间是不可转移的
*   你没有 mpsc 频道(事实上你没有太多的 *std* 工具)

因此...没有真正干净的解决方案。

我构建了一些可能是安全的、非常清晰的东西，但是它包含了对`unsafe`块的丑陋调用来访问全局状态。我已经将活动的事件处理程序置于这个全局状态(可以模块化)。

闭包的创建和装箱也很难看(附件 2: [BoardView](https://github.com/Canop/wasm-tictactoe/blob/master/src/board_view.rs) )。

这个问题的一部分很容易被一个小框架隔离，但是核心并不漂亮。大框架意味着更大的 wasm 文件。
我希望针对这个问题的一些微框架能够出现，并且足够好，而不要屈服于构建一个完整的模板/绑定/虚拟 dom/etc 包的想法(当然，有些人需要这个，但是我们也需要一个小而强大的核心)。

在那里，我只需要添加必要的逻辑(对于这样的游戏来说，这并不漫长或复杂)和“你赢/输”面板，然后添加一个“新游戏”按钮，主要是检查我是否可以在不泄漏内存的情况下添加和删除按钮及其处理程序。

游戏结束了。

有了这次经历，下面是我对 rust+wasm 的使用与 JavaScript 的比较:

## [](#what-do-we-gain)我们获得了什么

*   我们用 Rust 编写，它有更好的语法。联合类型、特征、模式、合理的泛型、避免垃圾收集器开销的所有权(你真的不希望你的 wasm 文件包含垃圾收集器)，没有空指针
*   我们有更好的类型安全
*   与使用 JS、TS 或另一种 wasm 语言相比，在编译时要测试更多的东西
*   Rust 模块化比 JS 世界中的任何标准都要干净得多，无论是在内部应用程序级别还是在使用外部包的时候

## [](#what-do-we-not-gain)我们有什么*没有*的收获

*   由于与浏览器的接口，类型检查并不完全完美。在这一点上，它可能比 TypeScript 好不了多少
*   有更多的运行时错误是 rust 程序所期望的(因为它不是 rust 程序，它是一个浏览器+rust 程序)
*   没有多线程。像 mpsc 通道这样的并发工具是不可用的。即使是互斥也只是部分可用。是的，我肯定会有工具通过 webworkers“支持”多线程，但是代理之间基于序列化的消息传递只保留给一个较小的用例集。当 SharedArrayBuffers 回归时，Rust 将最有可能使用安全多线程，但还没有明确的方向或日期。

## [](#what-do-we-not-lose)我们*没有*失去什么

*   客户端 JS 生态系统中没有太多东西会被错过。工具将很容易被制造出来取代它们。
*   在我看来，完全或部分基于 Rust 构建应用程序并没有真正使工具链复杂化。而且我不确定现在编译 Rust 比 lint/transpile JS 慢。
*   文件不大。Rust 不需要运行时，不需要 gargbage 收集器，所以没有什么需要添加到 wasm 文件中。

## [](#what-do-we-lose)我们失去了什么

*   管理应用程序和处理程序的状态会产生难看的代码。
*   在你的应用程序的架构中有更少的自由。

因为我喜欢 Rust，我可能会在 Rust/Wasm 中编写一些我的下一个 webapp 前端，但这将需要一个小框架(如果我没有找到足够好的东西，这是我自己的框架),这不是我在这一点上向没有 Rust 知识的开发人员推荐的东西。

你可能已经注意到了，我在 Wasm 方面没有太多经验(这是重点)。我真的对你的分析很感兴趣，也许还有修正。