# 过早抽象的成本

> 原文:[https://dev . to/this dot media/the-cost-of-premature-abstraction-4 bco](https://dev.to/thisdotmedia/the-cost-of-premature-abstraction-4bco)

对过早的抽象感到困惑或沮丧？想知道怎么避免？在本文中，我们将介绍什么是过早抽象，如何识别它，以及如何在它给代码带来问题之前避免它。

对于那些不熟悉过早抽象的人来说，这个术语指的是在实际需要之前，在完全理解问题空间和所有可能的变化之前，向代码中添加抽象。

很容易给出“过早抽象”的定义很难真正知道什么时候抽象是真正不成熟的，或者什么时候它只是聪明的计划。

[![whiteboard](../Images/fecec92f1b5875ddf3be442128c6933e.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--qXet_4uV--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/2000/0%2AunkzWhHVFgTtEtUz)

## [](#when-is-premature-abstraction-most-common)什么时候过早抽象最常见？

这个循环通常以无害和公正的方式开始:您正在解决一个大问题(例如，一个新特性)，并且发现它的许多较小的子问题有共同点——重复代码。你添加一个抽象。

当你继续解决更大的问题并达到新的抽象时，你修改它以适应微小的变化。重复一遍。更多的时间过去了。重复一遍。

最终，你开始发现抽象需要支持的所有变化开始变得笨拙。抽象本身现在很复杂，很难理解，也很脆弱。它试图为太多不同的场景做太多的事情。

这可能发生得相对较快，也可能需要几个月甚至几年的时间才开始引起悲伤。无论哪种方式，抽象都会产生一种讽刺的效果，使事情变得更难维护。

一些最常见的过早优化情况发生在“助手/实用程序”函数和视图/组件上。如果您发现您的抽象必须检查许多可能的输入情况，这是一个好迹象，表明该抽象是不成熟的，或者至少它已经超出了其最初的目的，应该被解散。

数据结构也会受到这种影响，但是你也不希望它们最终成为知道太多的单片[上帝对象](https://wikipedia.org/wiki/God_object)。

另一种情况有点狡猾:引入复杂的库或模式。在 JavaScript 世界里，像 Redux、RxJS、NgRx 等库。非常有用，但也有代价。特别是对于新手来说，很容易以弊大于利的方式使用这些库。实际上，我们都是他们的忠实粉丝，但是我们发现，许多人试图过早引入他们，或者在没有适当知识/培训的情况下引入他们，导致了不幸的结果。

承认一个抽象概念为时过早与其说是科学，不如说是艺术，不可否认，这是非常主观的。

## [](#the-true-cost-of-the-wrong-abstractions)错误抽象的真实代价

这有点自相矛盾，但是抽象可以同时增加和降低代码的复杂性——即使你在正确的时间选择了正确的抽象。

当在正确的时间添加正确的抽象时，可以更容易地修复通常重用的代码中的错误，并且使人们更容易快速理解特定代码路径的过程，而不需要理解本质细节。例如，当我扫描一些代码并遇到 fetchUser()时，我并不总是需要知道用户实际上是如何被获取的。

与此同时，即使有了正确的抽象，这种间接性也意味着必须改变一些底层抽象行为的开发人员必须挖掘得更深、搜索得更远，并在抽象之上解开复合抽象。诚然，这在某种程度上其实是正常的。

然而，当抽象不成熟或者执行得不好时，这些问题会更糟糕。

如果你的应用没有可靠的测试，抽象就更加危险。对这种抽象的任何改变都会产生未知的后果，所以明智的做法是避免在未经测试的代码中大量使用它们。你不必完全避开他们，避开他们就行了。

## [](#instead-of-abstractions)代替抽象概念

如有疑问，请复制代码。一个糟糕的抽象的成本比处理重复代码的成本高得多。甚至还有看似矛盾的建议，比如“不要重复自己”(又名 D.R.Y .)，在这里你被*鼓励*添加一个抽象，比如一个函数，而不是写重复的代码。

理想状态介于两者之间。重复自己完全没问题！事实上，我们采取的立场是，你应该默认重复你自己。一旦非常清楚你写的代码实际上需要多次使用，并且你需要支持的任何变化都不重要，就把它抽象掉。

为代码审查分配时间，并且只在以后进行重构，以梳理出几乎相同的代码路径或数据结构可以重用的清晰案例。

如果你[抽象得太早或者太激进](http://wiki.c2.com/?PrematureAbstraction)，很容易产生过度限制性的抽象(你以后必须解决它们)或者过度一般性的抽象(你很难维护它们)。

当然，有些东西从定义上来说是抽象的，甚至从一开始就是不可避免的；例如，您(通常)不希望您的 JavaScript 应用程序直接查询您的数据库。但是即使在这种情况下，您也可以将最初的抽象保持在最低限度。

## [](#conclusion)结论

最重要的是，记住我们为什么一开始就创建抽象:为了更容易地重用代码，在一个地方修复错误，以及隐藏实现细节。

抽象是必要的，它们就在我们周围。他们不邪恶！

我们的目标是在适当的时间引入足够的抽象概念，达到看似不可能的平衡。T3】

在这个 Dot Labs，我们帮助软件架构师和开发人员思考过早抽象的成本等问题，并提供专业、无缝的解决方案。需要帮助吗？直接给我们发电子邮件，地址是[hi@thisdot.co](mailto:hi@thisdot.co)。

这篇文章是由 Jay Phelps 写的，他是 Google 开发者专家，也是这个网络实验室的导师。

需要 JavaScript 咨询、指导或培训帮助吗？在 [This Dot Labs](//thisdot.co) 查看我们的服务列表。