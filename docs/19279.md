# Coursera 的数据结构和算法-算法工具箱第 2 周

> 原文:[https://dev . to/avatarkaleb/coursera-s-data-structures-and-algorithm-toolbox-week-2-74d](https://dev.to/avatarkaleb/coursera-s-data-structures-and-algorithms-algorithmic-toolbox-week-2-74d)

*这是 Coursera 算法课程系列文章的第二篇——如果你有兴趣从头开始，请参见[第一部分](https://dev.to/avatarkaleb/coursera-s-data-structures-and-algorithms-algorithmic-toolbox-week-1-2g9j)！*

## [](#why-algorithms-matter)为什么算法很重要

我之前在[中提到了算法运行时间在我们的日常生活中至关重要的原因，这是在 Big oh](https://www.kalebmckelvey.com/a-rule-of-thumb-for-calculating-an-algorithms-worst-case-in-big-oh-notation) 中计算算法最坏情况的经验法则

这是 bares 重复的一句话:

> 如果计算机和软件不花时间分析和优化运行我们日常生活的算法，我们可能永远不会从谷歌地图上获得我们要求的方向，Mint 可能不会更新我们的账户分类，或者 Twitter 不会显示下一条大的 POTUS 推文。
> 
> 算法存在于我们驾驶的汽车、观看的电视和进入的建筑中。它们被用于医疗设备和食品生产。UPS 会在整个递送周期中向您更新包裹进度，而网飞会在查看高峰时段接管美国的互联网带宽(36%)。
> 
> 这些被称为算法的小东西无处不在，不断让我们的生活变得更简单、更快捷、更方便。"

这显示了在我们生活中到处使用的算法需要快速运行是多么重要！

## [](#example-of-speed-differences-in-computer-fibonacci-sequence)计算机斐波那契数列中速度差异的例子

让我们假设你在家里的台式电脑上有一个 1 核心，1 GHz 的处理速度。你有一个编程作业，有 30 个不同的计算斐波那契数列结果的问题。斐波那契(30)或者斐波那契(50)的结果是什么？

根据你运行的算法，你可能要等一段时间才能真正完成任务。第二周的讲座表明，如果你使用一个简单的递归算法，如果问题是斐波那契(100)，你实际上可以坐大约 56，000 年。好消息是，有更好的算法来计算这个，所以你不会在你的余生做作业，甚至更多:)。

下一个问题是，我们如何衡量算法？

## [](#asymptotic-ampamp-big-o-notations)渐近& &大 O 表示法

在介绍大 O 之前，我们先来谈谈为什么衡量一个算法的真实性能会很困难。

### [](#asymptotic-notation)渐近符号

真正的性能需要几个问题的答案，这些问题在确定算法运行速度时会导致许多混乱的细节、变化和未知变量。我们需要知道:

*   我们运行这个的计算机的速度是多少？
*   计算机的系统架构是什么以及具体的操作需要多长时间来运行很重要
*   使用的是哪种类型的编译器？
*   编译器如何优化和运行语句？
*   我们使用的是什么类型的内存层次结构，我们有多少内存？
*   我们是使用缓存还是硬盘查找？
*   继续，继续，继续，继续，:D

换句话说，这可能很难。很多时候你不知道这些细节。这导致计算机科学社区的人想出了一个更好的方法。*渐近符号*。

这种新的符号被创造出来，所以我们有了一种谈论算法的语言，而不必在运行时间上绝对精确，并使用算法速度的许多变化是常数倍数的知识。这实际上可以归结为，运行时间如何与输入的大小成比例。

我们真正关心的是，随着时间的推移，不同输入的算法需要多长时间？

### [](#big-o-notation)大 O 符号

大 O 是一种特殊类型的渐近符号，它阐明了一些事情:

*   增长率——我们可以看到运行时是如何随着输入大小而扩展的
*   在不同的算法之间使用相同的符号来传达增长率
*   我们不需要特定的常数倍数
*   我们可以忽略系统的细节

当需要详细的分析时，它并不完美，但确实有利于评估常见算法，如排序，以快速查看运行时速度。

如果您对最常用的符号和一些数据结构速度感兴趣，请查看黑客地球上的这些图表！

## [](#writing-efficient-algorithms)编写高效算法

创建高效算法的过程可以归结为三个步骤。

1.  朴素算法->慢-这一步帮助你完全理解和基线问题。
2.  使用标准工具分析算法(大 O)
3.  优化->通过重新安排操作顺序、减少工作或使用更好的数据结构来改进现有算法。

必要时重复！

对于求解算法的活动，教授给出了以下免责声明。“有时三个步骤是不够的，有时你只需要一些神奇独特的洞察力或一个引理来帮助它进入下一个层次”

## [](#wrapping-up-week-2)总结第 2 周

第二周仍然是这门课的入门材料，所以第三周，我希望深入研究贪婪算法，以及解决这些算法的最佳过程。博客也应该开始变得更有价值，因为与理论相比，将会有更多的代码和例子！！

感谢阅读，下次再见！