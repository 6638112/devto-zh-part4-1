# 使用 JSON 模式、Angular 和 TypeScript 验证数据

> 原文:[https://dev . to/tane piper/validating-data-with-JSON-schema-angular-and-typescript-11dh](https://dev.to/tanepiper/validating-data-with-json-schema-angular-and-typescript-11dh)

我在许多新的 TypeScript 开发人员身上看到的一个常见问题是，如何使用他们构建的类型来处理数据的运行时验证。

问题是 web 平台还不支持类型。Typescript 本身是一种构建在 JavaScript 之上的高级语言，使用编译器为 web、node 或其他 JS 平台创建兼容的代码——这意味着类型只在设计时可用。

大多数开发人员在他们的代码中都有一个方法或表单，他们希望在将数据发送到另一个 API 之前验证传入的数据是否正确。这适用于 Typescript 中的硬编码数据，但不适用于来自表单或 API 源的动态数据

好消息是，问题本身已经解决了，有几种类型脚本的解决方案，如
[io-ts](https://github.com/gcanti/io-ts) 或 [joi](https://github.com/hapijs/joi) ，但我发现这些解决方案鼓励
跨不同域复制类型，以维护您的类型和验证对象。

## [](#introducing-json-schema)介绍 JSON 模式

在一个项目中维护类型和验证的一个更简单的方法是使用单一的真实来源。
主要选项是 [JSON 模式](https://json-schema.org)。

JSON 模式文件允许您使用 JSON 文件定义 a 类型，使用由所选的
草稿定义的规范(在编写本文档时，它的[号是 7](http://json-schema.org/specification.html) )。

该文件可用于使用 CLI 工具生成设计时编码的类型，并可用于在运行时使用另一个库进行数据验证，该库可使用架构来生成验证方法。

### [](#schema-example)模式示例

在这个演示中，我创建了一个简单的模式对象来定义系统中的客户。客户属性包括:

*   `ID`
*   `firstName`
*   `lastName`
*   `dateOfBirth`
*   `email`

在这个例子中，我们设置了`"additionalProperties": false`来保持例子的简单，但是这是一个非常灵活的选择！

如果设置为 true 或不包含，输出的类型将包含一个在类型属性末尾带有`[key: string]: any`的可索引类型。

您还可以向它传递属性，比如`"additionalProperties": { "type": "string" }`，这将只允许添加字符串附加属性。

通过设置为 false——只有定义的属性在类型上可用，我将在这个例子中这样做:

```
{  "$id":  "https://tane.dev/customer.json",  "$schema":  "http://json-schema.org/draft-07/schema#",  "title":  "Customer Record",  "type":  "object",  "properties":  {  "id":  {  "type":  "string",  "description":  "The Customers ID in our system"  },  "firstName":  {  "type":  "string",  "description":  "The customer's first name."  },  "lastName":  {  "type":  "string",  "description":  "The customer's last name."  },  "email":  {  "type":  "string",  "format":  "email",  "description":  "The customers email address"  },  "dateOfBirth":  {  "type":  "string",  "format":  "date",  "description":  "The customer's date of birth."  }  },  "additionalProperties":  false,  "required":  [  "id",  "firstName",  "lastName",  "dateOfBirth",  "email"  ]  } 
```

我们将运行的第一个工具是富有想象力的标题为 [`json-schema-to-typescript`](https://www.npmjs.com/package/json-schema-to-typescript) ！
该项目将获取有效的模式文件，并生成包含类型的文件。根据上面的示例，输出是:

> `json2ts -i customer.json -o customer.d.ts --style.singleQuote`

```
/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface CustomerRecord {
  /**
   * The Customers ID in our system
   */
  id: string;
  /**
   * The customer's first name.
   */
  firstName: string;
  /**
   * The customer's last name.
   */
  lastName: string;
  /**
   * The customers email address
   */
  email: string;
  /**
   * The customer's date of birth.
   */
  dateOfBirth: string;
} 
```

需要注意的一点是，`email`和`dateOfBirth`在我们的类型中是字符串，`format`仅用于验证。可以为这些字段创建类型，并使用更复杂的
[模式](https://json-schema.org/understanding-json-schema/structuring.html)引用它们。

这种类型现在可以导入到其他类型中，当您使用复杂引用时,`json-schema-to-typescript`会这样做。例如，如果我们定义一个完整的客户订单类型，它可能是这样的:

```
import { CustomerRecord } from './customer';
import { OrderItem, Checkout, Address } from './shop-front'

export interface CustomerOrder {
  customer: CustomerRecord;
  deliveryAddress: Address;
  billingAddress: Address;
  items: OrderItem[]
  checkout: Checkout
} 
```

此外，所有属性都已添加到所需的数组中。创建新客户时，如果数据不包含 ID，可以使用`Partial`类型接受不完整的对象——如果希望 API 返回完整的对象，可以返回一个`CustomerRecord`。您也可以在需要确保所有字段都通过的地方使用`Required`。

```
import { CustomerRecord } from './customer';

class CustomerClass {
  // Return a API request with a customers object
  async addCustomer(customer: Partial<CustomerRecord>): Promise<CustomerRecord> {
    return this.api.save(customer);
  }

  // Return a API request with a customers object
  async updateCustomer(customer: Required<CustomerRecord>): Promise<CustomerRecord> {
    return this.api.update(customer);
  }
} 
```

## [](#validating-with-the-schema)用模式验证

现在您有了类型，这使得应用程序的开发变得更加容易——但是我们仍然需要验证输入的数据是正确的。

一种方法是在服务器端使用相同的模式，使用您的语言 JSON 模式验证器，但是在这个例子中，我将使用[ajv](https://github.com/epoberezkin/ajv)——一个 javascript 库，它允许加载模式并根据模式验证数据。关于在 JavaScript 环境中使用它的文档已经很完整了，所以我不会在这里重复太多，相反，我将构建一个可以作为模式验证服务提供的 Angular 模块。

首先，我们将创建 Angular 模块，在其中注入 AJV 类，并允许用户提供配置，服务如下所示。这允许模块与配置一起导入，并通过您的应用程序注入一个服务。

```
import { NgModule, InjectionToken } from '@angular/core';
import { HttpClientModule } from '@angular/common/http'
import { JSONSchemaService, AJV_INSTANCE } from './json-schema.service';
import ajv, { Ajv, Options } from 'ajv';

export const AJV_CLASS = new InjectionToken<Ajv>('The AJV Class Instance');
export const AJV_CONFIG = new InjectionToken<Ajv>('The AJV Class config');

export function createAjvInstance(AjvClass: any, config: Options) {
  return new AjvClass(config);
}

@NgModule({
  import: [HttpClientModule],
  provides: [
    JSONSchemaService,
    { provide: AJV_CLASS, useValue: ajv },
    { provide: AJV_CONFIG, useValue: {} },
    {
      provide: AJV_INSTANCE,
      useFactory: createAjvInstance,
      deps: [AJV_CLASS, AJV_CONFIG]
   }
  ]
})
export class JSONSchemaModule {} 
```

现在我们创建一个服务——在这个服务中，它将访问`Ajv`类，该类允许服务通过角度 HTTP 调用提供模式。解析后的模式被赋予一个名称，并可以通过依赖注入在应用程序中使用——该服务也是根服务的一个很好的用例，它创建了在同一应用程序中共享的服务的单例。

```
import { Injectable, Inject, InjectionToken } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Ajv } from 'ajv';

export const AJV_INSTANCE = new InjectionToken<Ajv>('The AJV Class Instance');

/**
 * The response of a validation result
 */
export interface ValidateResult {
  /**
   * If the result is valid or not
   */
  isValid: boolean;

  /**
   * Error text from the validator
   */
  errorsText: string;
}

@Injectable({
    provideIn: 'root'
})
export class JSONSchemaService {
  constructor(private readonly http: HttpClient, @Inject(AJV_INSTANCE) private readonly ajv: Ajv) {}

  /**
   * Fetches the Schema and adds it to the validator schema set
   * @param name The name of the schema, this will be used as the key to store it
   * @param urlPath The URL path of the schema to load
   */
  public loadSchema(name: string, urlPath: string): void {
    this.http.get(urlPath).subscribe(result => this.ajv.addSchema(result, name));
  }

  /**
   * Validate data against a schema
   * @param name The name of the schema to validate
   * @param data The data to validate
   */
  public validateData<T>(name: string, data: T): ValidateResult {
    const isValid = this.ajv.validate(name, data) as boolean;
    return { isValid, errorsText: this.ajv.errorsText() };
  }
} 
```

现在，我们可以使用我们的服务将 JSON 模式加载到内部的`Ajv`映射中，并使用键 load schema 来验证数据对象。服务可以与表单、服务上的任何方法一起使用，或者在传递给另一个 API 之前检查一个 API 的结果。

一个如何在表单组件中使用它的简单例子(这个例子很简短，很可能您会从另一个服务加载您的模式)或者如何验证传递给方法的参数:

```
@Component({
  selector: 'my-form-component',
  template: `
    <errors-component *ngIf="let errors; errors$ | async"></errors-component>
    <form [formGroup]="customerForm" (ngSubmit)="submit()">
      <!-- Customer form in here --->
    </form>
  ` 
})
export class FormComponent {

  error$ = new BehaviorSubject<string>('');

  customerForm = this.fb.group({
    id: [''],
    firstName: [''],
    lastName: [''],
    email: [''],
    dateOfBirth: ['']
  });

  constructor(private readonly fb: FormBuilder, private readonly schema: JSONSchemaService, private readonly app: AppService) {
    this.schema.loadSchema('customer', 'https://tane.dev/customer.json')
  }

  /**
   * In the submit method, we validate the input of a form - this can be on top of, or instead
   * of Angular form validation
   */
  submit() {
    const result = this.schema.validateData('customer', this.customerForm.value);
    if (result.isValid) {
       this.app.updateCustomer(this.customerForm.value);
    } else {
      this.error$.next(result.errorsText);
    }
  }

  /**
   * This custom method can take a type of T (which in this case is an `any`) and validate
   * that the data is valid
   */
  customMethod<T = any>(data: T) {
    const result = this.schema.validateData('customer', data);
    if (result.isValid) {
       // Do custom logic
    } else {
      this.error$.next(result.errorsText);
    }
  }
} 
```

## [](#conclusion)结论

我希望本文有助于您理解如何以及在哪里使用 Typescript 来验证应用程序中的数据，以及如何使用 JSON Schema 来验证动态数据。

请随时留下关于任何问题或改进的反馈，但希望这些示例能让您有更清晰的理解。

有关 JSON 模式的完整文档，请查看[理解 JSON 模式](http://json-schema.org/understanding-json-schema/)
页面，获取使用`allOf`、`anyOf`、`oneOf`和使用[定义](http://json-schema.org/understanding-json-schema/structuring.html#reuse)的示例