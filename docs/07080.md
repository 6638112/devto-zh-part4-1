# 用状态编程:架构角色

> 原文:[https://dev . to/vora HSA/programming-with-state-architectural-roles-ni](https://dev.to/vorahsa/programming-with-state-architectural-roles-ni)

对我来说，应用程序架构有一个主要问题需要回答:这个功能属于哪里？我正在开发的应用程序将会有一些特性，每个特性都由几个相互作用的功能组成。我希望对每项功能的发展方向有一个清晰的认识，以确保组件易于理解。本系列的第一部分将应用程序描述为一组相互连接的实体。现在我们将看看创建哪些实体以及何时创建。

存在许多 MV*架构，MVC、MVP、MVVM……这些架构的共同点是 M(模型)和 V(视图)有非常清晰和有限的职责，然后其他的一切都进入了*部分。显示信息的格式，通过网络访问后台，在应用程序中导航，凡是你能想到的，*都会处理。这对我来说还不够。

## [](#architecture-with-no-pronounceable-acronym)没有可发音缩写的架构

这些年来，我想出了一个适合我的架构。将事物分解成组件的方式是有意义的，我总是知道如何分解一个特性，以及每个所需功能的位置。我没有试图强迫它形成任何特定的缩写，所以它实际上只是我的架构，在它们有意义的地方创建组件。

我还喜欢将组件之间的连接分成两种不同的类型:一种*依赖关系*意味着一个组件引用另一个组件。而*数据流*意味着一个组件将数据传递给另一个组件。当数据被传入一个被调用功能的组件时，有时数据流遵循一个依赖关系。而在其他时候，当一个组件观察另一个组件的状态时，数据流的方向相反。

该图展示了我已经确定的有用的架构概念，我称之为*角色*。它们之间的数据流用指向数据流方向的箭头表示。我发现，大多数情况下，单向数据流工作得很好，使事情更容易理解，因为它总是知道从哪里可以触发变化。图中的依赖关系是从上到下的:高层的东西可以依赖于低层的东西，但反之则不然。

[![Architecture Diagram](../Images/e676a8a107299ef0ec8d899a1147a6d1.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--LJHxL9qa--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ss1tabx2avdfbih1tex9.png)

## [](#overview-of-roles)角色概述

当然有必要对角色进行良好的定义，以达到了解每项功能的归属的目的。视图和资源是与外界交互的角色。视图是在屏幕上绘制用户界面并识别用户交互的东西。单个屏幕通常包含多个视图，通常以包含关系分层排列。资源是与用户界面之外的外部世界进行交互的任何东西，从与后端通信到文件 I/O，甚至到定时器。

表示和控制都与用户界面有关。在图中，它们被标记为局部视图，而其他角色是全局的。这意味着通常每个视图都有自己的组件来执行这些角色，并且它们通常不会在不同的视图之间共享。分割这些角色的原因是为了使数据流更清晰(并且是单向的):呈现只关心数据如何在屏幕上显示，所以数据流从存储通过呈现到视图是单向的。另一方面，控件只接收来自视图的用户交互触发器，并触发商店或代理中的操作。

模型和商店之间的区别来自于如何根据本系列中的[前一篇文章来表示状态。模型是值，存储是状态由模型对象组成的实体。应用程序中的所有基本状态都是商店的状态。存储可以从从上面流入它的数据中获取这种状态，也可以从后端或数据库等资源中获取这种状态。从存储中流出的数据是组成其状态的模型对象。](https://dev.to/vorahsa/programming-with-state-values-and-entities-1hcp)

代理人的角色可能是最不寻常的，也是最罕见的。代理背后的思想是其他角色纯粹是反应性的；它们只对流入它们的数据做出响应，而代理被允许是主动的，以发起一个动作(在某种程度上，视图也可以被看作是主动的，因为用户动作肯定不是作为对数据流的直接响应而发起的，但是这里没有对用户活动建模)。例如，与后端的定期数据同步将是一个代理活动，将代理对该操作的定期触发与商店执行的实际通信分开，可以使整个系统更容易理解。

## [](#roles-instead-of-components)角色代替组件

图中的关键点是这些不是架构组件，它们是角色。不同之处在于，一个组件可能承担多个角色。当一个模型对象通过简单地按原样显示它的一些属性而显示在用户界面中时，我不会费心去创建一个全新的模型表示组件，而是简单地让视图直接使用它从商店中获得的模型对象。但是当所需的表示变得更加复杂时，正如它经常发生的那样，已建立的角色分离很容易让人想到为表示角色创建新组件的解决方案。

我非常重视尽可能多地对应用程序进行单元测试，这在一定程度上指导了架构。为了方便起见，图中标记为不可单元测试的两个角色总是独立的组件。对于资源，总是使用双测试。当测试中的资源交互很简单时，double 有时是一个存根，有时是一个伪存根，以允许对其行为进行更精确的控制。单元测试中根本不考虑视图。所有决定显示什么的逻辑都在一个表示中，所有的动作代码都在一个控件中，所以在一个视图中没有单元可测试的逻辑，只有在屏幕上的实际显示和用户交互到控件触发器的映射。

## [](#other-architectures)其他架构

这里描述的架构在很大程度上归功于我构建移动应用程序的经验，尤其是使用流行的架构并试图填补它们的“不足”。例如，该体系结构的视图本地部分直接来自 MVVM，视图模型在那里扮演表示和控制的角色。MVVM 的经验告诉我，这两个角色在一个视图模型中通常是非常不同的，对我来说，将它们作为概念分开会使整个架构更加清晰。

传统上，模型、商店和资源角色中包含的全部功能都包含在 MV*架构的模型部分中。前一篇关于价值和实体的文章确立了我为什么喜欢模型-商店分离，它也部分受到了 T2 模型-视图-控制器-商店架构的启发。存储和资源的分离纯粹是为了帮助单元测试。通过将实际应用程序中需要与外部世界交互的部分分离到一个薄的可存根层中，与所有资源使用都包含在存储中相比，单元测试可以覆盖更多的应用程序。

导航是移动应用程序开发中最困难的架构问题之一。开始时总是非常简单，视图可以使用平台本地导航模式来处理。但是应用程序的导航模式经常变得更加复杂，而且通常一次只做一点点，从来没有考虑过导航是否需要重新考虑。VIPER 架构是我所知道的唯一一个明确包含导航的架构，但即使在那里，它似乎也是将过于简单的平台提供的导航分离到它自己的组件中的唯一方法。我所遇到的复杂导航需要一种更加全球化的方法，通常需要一个单独的组件来负责整个应用程序的导航需求。

## [](#scenarios)场景

我从架构的目的开始，即确定每个功能的归属。因此，架构的验证是通过观察这个目的在开发环境中的实现程度来执行的。下面的两个例子展示了应用程序屏幕中的功能是如何划分的，以及基于角色的思想是如何允许实现的架构在适用时保持简单，而在需要时发展成更复杂的东西。

一个非常基本的屏幕的组件架构可能看起来像下面显示的用户信息屏幕示例。这是一个组件图，组件的右上角显示了每个组件所扮演的角色。用户存储保存用户模型对象。屏幕直接显示这个模型对象中的信息，没有任何附加的表示逻辑，因此用户对象也可以充当表示角色。

[![Basic Application Components](../Images/a6c0464acb273e0ec05f542daed13c6f.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--N7u4C2za--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/0awhsjfsdpzlxzxvvji5.png)

该屏幕允许编辑用户信息。在这种情况下，不需要特殊的交互逻辑，因此用户存储可以充当视图的控制角色。最后，用户存储负责用户信息的本地和远程持久化，它为此使用两种资源，一种用于本地数据库，另一种用于与后端通信。

聊天应用程序提供了一个更复杂的屏幕，包含更多的组件和更独立的角色。聊天商店在某种程度上是应用程序的中心点，因为它存储了用户参与的所有聊天。模型对象是聊天中的消息，但是在这种情况下，需要单独的消息表示组件；例如，模型对象可能存储消息的精确时间戳，但是屏幕应该显示更人性化的表示。

[![Chat Application Components](../Images/6ddf977901ceb2ff02f937a0bafbff5a.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--xDpZbTVK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/sr9ikizfywsj4np4ewyd.png)

根据消息发送的实现方式，控制角色中可能有一个消息发送者组件，它既请求聊天存储发送来自用户的新消息，又立即调用表示来更新屏幕以获得更好的用户体验。一种替代方案是由聊天商店提供的聊天表示也为任何未决消息提供足够的信息。一般来说，当用户操作要求数据流入几个不同的组件时，单独的控制组件是有用的，但是当控制功能复杂到足以保证测试但不被认为是商店的责任时，也可以使用它。

聊天应用程序还提供了一个代理角色的示例。聊天更新器是一个独立的组件，可以由定时器触发，也可以由外部通知触发，其中任何一个都是资源。当被触发时，聊天更新器将告诉聊天商店使用与聊天后端通信的资源来更新特定聊天或所有聊天。

## [](#summary)总结

综上所述:我把一个应用架构分成我认为必要的许多概念。我不觉得有必要强迫他们变成一个可爱的缩写。我只在组件实际上有一些必要的功能时才使用它们，而不是仅仅作为数据的传递层，这就是为什么我考虑角色而不是组件。我发现从数据流的角度考虑非常有用，所以组件之间的数据流是架构的重要部分。最后，在需要的时候，我不怕违背自己的原则。并不是所有的东西都能装进整洁的小盒子里，有时候承认这一点比试图把一个方钉塞进一个圆孔要好。最后，软件架构应该提供指导，而不是充当束缚。