# RFC:可缓存(哈希)的 ES 包

> 原文:[https://dev . to/troglotit/RFC-cache-hash-able-es-packages-2 AFM](https://dev.to/troglotit/rfc-cache-hash-able-es-packages-2afm)

这实际上是请求对我在浏览器中的可缓存和可哈希 JavaScript 包的提议进行评论。我不是浏览器引擎工程师，也没有拿过写提案的钱:所以我很有可能错过了一些关键的东西，这让我无法写提案。

## [](#motivation)动机

我们重复使用和重新下载了很多库，比如 React inter 网站，它们是用相同的 webpack 和相同的 UglifyJS(它们产生相同的工件)构建的。许多应用程序开发人员希望像 React 这样的 API 内置在浏览器中。另一方面，浏览器引擎和 TC39 工程师并不确切知道要实现哪些 API。

## [](#proposal)提议

包图，这是 app 开发者提供的唯一附加的东西，看起来是这样的:

```
<script type="packagemap">
{
    "packages": [
        {
            "name": "react", 
            "hash": "sha256:41a7ed1ba26217cf70059964c74665d0a9c364a4078f69a3ca6d1e2623b0679f"
            "location": "https://mywebsite/js/react_min.js"
        },
        ...
    ]
}
</script> 
```

下载包映射后，浏览器使用“哈希”内容检查包是否在缓存中:

*   如果**是**，那么你可以使用那个套餐；
*   如果**不是**，那么浏览器下载包，并检查计算的散列是否是正确的散列:
    *   如果**散列是正确的**，你可以安全地将包放入缓存；
    *   如果**不是**，你的应用程序继续正常工作，但是缓存不会被给定的包填充。

#### [](#and-because-its-a-generic-hash-you-can-use-packages-downloaded-from-another-websites)因为它是一个通用的 hash，你可以使用从其他网站下载的包。

因此，作为一名应用程序开发人员，你已经知道你的包将在另一个网站上使用，所以你只把公共的 npm 库放在那里。内部包可以使用更传统的方法进行缓存，比如服务工作者或其他人。

浏览器工程师可能会有这样的见解:“70%的网站使用这个 API，所以我们可以预下载或安全地将其作为内置实现”。

## [](#security)安全

代码重用的主要考虑总是安全性，据我所知，以前的尝试有一个主要的攻击角度:[定时攻击](https://en.wikipedia.org/wiki/Timing_attack)。例如，一个攻击者有一个网站试图通过包地图下载整个 npm，如果你不使用真正特定的包，如`"@my-company/really-obscure-package"`，那么攻击者通常不知道你访问了哪些网站。毕竟，这个缓存应该由在网站之间**通用的包填充。所以我看不到可行的时间攻击。**

## [](#related-work)相关工作

### [](#subresource-integrity)子资源完整性

[子资源完整性](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) (SRI)主要用于从第三方 cdn 下载资产。当 SRI 不匹配时，资产从评估中被丢弃，这与包完整性散列的意图有点不同。

### [](#import-maps)导入地图

导入地图是 Chrome 开发者支持的一个成熟的提议，并且已经在 Chrome 中实现，但是他们的关注点不是缓存或者 T2 包元数据。

## [](#in-conclusion)总之

这几个月一直在想这个问题，也在看相关的作品。虽然，我最近有点懈怠，但我不想让这个想法胎死腹中。这就是我决定与你分享的原因。想到这个想法可以给每个人带来的好处，我真的很兴奋。我将感谢你们所有人的反馈，以了解我是否应该将它变成真正的提案，以及如何将其与现有提案相结合。