# 逃离抽象地狱

> 原文:[https://dev.to/makingloops/escaping-abstraction-hell-56f2](https://dev.to/makingloops/escaping-abstraction-hell-56f2)

[![](../Images/bb1922875cb0b6810bfd851bc90fe862.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--WKYnVNKr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://makingloops.com/public/abstraction-hell.png)

当涉及到围绕代码的设计决策时，您可能和我很相似。

你*喜欢*干净的代码。

读和写都是令人满意的，你的队友欣赏它，并且它使你的应用程序更容易与下线一起工作，所以**你在它上面投入了很多努力**。

但是在这种纯粹的意图之下，完美主义的心理恶魔往往会抬头。

在潜意识的羞愧和对失败的恐惧的驱使下，寻找完成手头任务的最佳方式成为了一种困扰。

不知道自己不知道的事情是很艰难的。

当然，快速的网络搜索找到做某事的最佳方式是一件很棒的事情，这也是我们的软件改进的方式，但是发生在我身上的事情，可能你也一样，是它变成了一个*蠕虫洞*。

扫描一个关于如何使用 Mediatr 的浏览器标签，然后在 CQRS 上衍生出另外三个标签，[保持控制器精简](https://makingloops.com/why-should-controllers-be-thin/)，以及[存储库模式](https://makingloops.com/why-should-you-use-the-repository-pattern/)。

您意识到您没有遵循单一责任原则，并且在您的*查询*中有一个*命令*，所以您首先需要重构它。

当你进行重构，同时又对 Google 的 tit 乐此不疲的时候，你遇到了领域驱动设计，并决定在你能够*舒服地*实现最初分配给你的小任务之前，最好与你的团队一起主持一个事件风暴会议。

这是一个地狱螺旋。

它并没有结束，你并没有完成你的任务，相反，你只是添加了一堆抽象，这些抽象在理论上减少了耦合，但是对你的团队和公司来说可能是不合时宜的和低价值的。

这通常是因为建议文章是带着非常具体的问题背景写的，而这通常不是你的问题背景，所以你是基于其他应用程序的需求来构建你的应用程序的。

这也很像瀑布与敏捷软件开发。

完美主义的困扰让你本末倒置，试图*预测永恒*而不是*完成你的任务*。

最好的架构促进了敏捷性(易于改变)，但是如果你没有改变它的需求，你就基于直觉过早地进行了优化。

## [](#what-to-do-instead)做什么相反

第一，不要自责。这种*架构混乱*几乎是我见过的每个开发人员都做过的事情。

随着时间和经验的积累，你将能够更快更好地预测某个特性应该具有什么样的设计，但在此之前，你可以使用一种更简单的方法。

从让你的功能*工作*开始。

抛开软件世界抛给你的所有*应该*的事情，尽可能用最简单的方式让它工作。

也许从一个方法和一组注释开始，将特性分解成一个高级算法。

```
 private void purchaseItem()
 {
     //set up payment gateway api client
     //process payment
     //generate receipt
 } 
```

在你让它运转起来之后，承诺*也许* 30 分钟到 1 小时的基本*整理*。

这一次把重点放在使它容易理解(小方法，清晰的名字)，并且把目标放在你的那些方法和它们的类的单一责任主体上。

就是这样。

继续前进。

这里是重要的一点——你可以*相信*当你的功能开始在野外使用时，**迭代改进设计的机会将自然地展现出来**。

你的最佳设计*通过实际的痛苦热点出现*,而不是在前期的心理预测上费力。

所以你最终会得到一个更符合需求的设计，你会更快地完成你的功能，更加轻松愉快。

## [](#going-further)更进一步…

如果这引起了你的共鸣，我鼓励你看一看我的关于界限的文章，以加深你对可能影响你作为一名开发人员成长的其他性格特征的理解。