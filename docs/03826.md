# 我会试着用简单的英语解释词法范围。祝我好运

> 原文:[https://dev . to/fleepgeek/I-would-try-to-explain-lexical-scope-in-plain-English-wish-me-luck-4j 06](https://dev.to/fleepgeek/i-would-try-to-explain-lexical-scope-in-plain-english-wish-me-luck-4j06)

几天前写一篇关于闭包和生活的文章时。我试图用简单明了的方式解释词法范围。我注意到文章越来越大，所以我决定单独写关于词法范围的内容。在这篇文章中，我将尝试解释词法范围的基础知识，它的含义，并举例帮助你理解它在 JavaScript 中是如何工作的。没有流行语...我保证。

首先，我们来分解一下单词**“词法范围”**。

## [](#scope)范围

我们先说容易的:**范围**。
说白了，范围可以指:

*   边界
*   一个地区
*   一个环境

或者任何你能想到的同义词。

你是否记得看过一个教程，其中讲师告诉你某个想法/主题超出了视频的范围？或者当另一个部门的团队正在做一个项目，你告诉他们添加一个你认为很酷的功能，他们告诉你:“*那超出了这个项目*的范围”。我想你已经明白了要点。作用域仅仅是一个**区域**，在这里某个东西被允许在**给定的时间段**内运行。

在计算机科学中，这可能意味着一些数据存在并可以被访问的**区域**。这些数据可能类似于一个 T2 变量 T3。

在像 JavaScript 这样的语言中，我们可以通过使用花括号创建一个块来定义作用域:`{...}`。我们称之为**块范围**。这意味着在这个块内声明的变量只能在这个**区域**内访问。这个**区域**覆盖了它里面的所有东西，包括在该区域内创建的其他子/内部块。
换句话说，这个区域是`local`，它的变量不能从外界直接访问。所以这可以被称为**局部作用域**。
函数内部声明的变量在函数的**局部作用域**内。

```
function doSomething() {
  let name = "john";
  console.log(name)
}

doSomething(); // Prints 'john'

// would produce a Reference error
// because name is local to doSomething() function's scope
console.log(name); 
```

现在，你可能听说过**全局作用域**。嗯，那是一个不封闭的环境。Javascript 环境中的每个代码都可以访问它。这是开放的 JavaScript 环境。所以下面的代码应该可以工作。

```
let name = "john"; // In the global scope

function doSomething() {
  name = "James"
  console.log(name); // The function can access the global scope variable 'name'
}

doSomething(); // Prints "James"
console.log(name); // Can access 'name' too 
```

有一点需要注意:

> 范围可以访问其父范围，但父范围不能直接访问内部范围中声明的变量。

该函数可以访问`name`，因为该函数是在全局范围内声明的，而`name`存在于全局范围内。如果 name 是在`doSomething()`函数中声明的，那么全局范围内的代码不能直接改变`name`的值，因为`name`对于函数来说是局部的。

我相信你很清楚 **Scope** 是什么意思。它只是简单地表示一个**区域**或**环境**，在那里变量存在并且可以被访问或修改。

现在，我们来谈谈“**词法**

## [](#lexical)词法

要理解 lexical，我们先来看看它是从哪个词衍生出来的: **Lexicon** 。
Lexicon 来源于拉丁语单词:**“lexis”**，直白地说就是**“word”**
的意思:

> Lexicon 就是字典的意思。在顺序词中，它表示一个人的语言的词汇。它就像一本书，里面储存了单词的意思/定义。

每当你想找到一个单词的意思时，你就去查字典。
你不看这个词用在哪里，就猜测它的意思和它的内容或价值。你总是去**词典**，在那里这个词的目的是**创造**和明确定义。

有了这样的解释:

> 词汇的简单意思是与词汇相关的东西。换句话说，它指的是与一个人的语言的单词或词汇相关的东西。与词的创造或定义有关的东西。

先说词法范围。

## [](#lexical-scope)词法范围

我们已经明白了这两个词在简单英语中的意思。有了这些知识，让我们用简单的英语定义一下**词汇范围**:

> **词法范围**简单的说就是一个**单词**所在的**区域**是由定义或**创建**的**位置决定的。**

其他定义包括:

> **词汇范围**意味着一个词的意义/价值只能由创造它的**地区/环境**来决定。
> 
> **词汇范围**意味着你不会直接将一个单词的意思外包给来自使用该单词的**地区**以外的人。这是因为词法把重点放在它被创建/定义的起源上。

好吧，我举个例子。让我们用“跳舞”这个词。
“舞蹈”一词是在英国创造/定义的。英国人民知道它的意义。这个词存在于它被创造的范围内:“英国”。威尔士在英国，所以威尔士可以使用这个词(记得我们已经解释了原因)。所以威尔士人可以更新这个词的意思，以适应他们当地的方言。这是因为它们在英国的范围之内。

德国人不能直接过来改变这个词的意思。这是因为这个词不是德国创造的。所以，如果德国人想使用英语单词:**“dance”**而这个单词还没有被英国创造出来，那么无论他们如何努力，这个单词都是不可用的。这将使得没有人知道这个词在德国的真实含义，因为这个词不存在于**英国词典**中。(如果这看起来像是胡言乱语，不要担心，稍后我会用代码解释)

既然我们是理科学生而不是语言学家，让我们用**【变量】**代替**【单词】**。

我们的新定义是:

> **词法范围**仅仅意味着**变量**所在的**区域**是由定义或**创建**的**位置决定的。**
> 
> **词法范围**意味着一个变量的意义/值只能由它被创建的地区/环境来决定。
> 
> **词法范围**意味着你不直接将变量的含义外包给使用该变量的外部区域(块)的代码。这是因为 lexical 将重点放在变量创建/定义的起点上。

所以词法作用域告诉我们的是，变量只能在创建它的作用域中使用，而不能在调用它的地方使用。

让我们看看这在代码中是如何工作的:

```
function rideBritishBoat() {
  let boatName = "Queen's Dab"; // local variable
  return `Driving ${boatName}`
}

function rideGermanBoat() {
  const status = rideBritishBoat();
  return status;
}

rideGermanBoat(); 
```

上面的例子模拟了一个场景，德国人从英国买了一艘船....(你可以把它换成任何你想要的国家...不用打为什么我没提别的国家。这些只是国家名称，而不是 JavaScript 库😛 ).
`rideGermanBoat()`使用`rideBritishBoat()`。
由于 JavaScript 使用词法作用域，当执行`rideBritishBoat()`函数时，它会转到创建**的地方**并获取变量的引用:`boatName`。所以有了词法作用域，每当执行`rideBritishBoat()`时，JavaScript 就会进入函数的作用域，寻找函数中使用的变量。

注意:`rideBritishBoat()`函数的作用域是局部作用域和全局作用域。`rideGermanBoat()`不在`rideBritishBoat()`函数的词法范围内，因为`rideBritishBoat()`不是在函数内部创建的。

现在，让我们稍微改变一下例子:

```
function rideBritishBoat() {
  return `Driving ${boatName}`; // Reference Error: boatName not defined
}

function rideGermanBoat() {
  let boatName = "Merkel's Dab";
  const status = rideBritishBoat();
  return status;
}

rideGermanBoat(); 
```

上面的代码失败了。`rideBritishBoat()`功能不精确。试图访问 return 语句中的`boatName`时失败。

**为什么？**

这是因为 JavaScript 使用词法范围。
这是如何工作的，当它遇到`rideBritishBoat()`函数中的`boatName`变量时，**在**作用域链**中寻找`boatName`变量被**创建的**。也就是说，函数的所有可能的作用域是:**函数的局部作用域**，然后检查它的封闭作用域，在这种情况下是**全局作用域**。**

这就是 JavaScript 检查变量的方式。它首先检查使用当前变量的局部块，以了解它是否在那里声明。如果没有，那么它会继续到封闭的作用域，如果它没有找到一个声明，它会继续下去，直到到达链的顶端，也就是全局作用域

还有另一种类型的作用域，叫做**、**。前面的代码可以在支持动态范围的语言中工作(例如 Lisp)。这是因为在动态范围的环境中，变量在运行时被检查。这意味着当你执行`rideGermanBoat()`并且执行到达`rideBritishBoat()`时，运行时环境检查代码当前运行的`boatName`的值。在这种情况下，它找到了它，所以没有问题，代码按预期工作并打印出`Driving Merkel's Dab`。

词法作用域也被称为**静态作用域**，因为它的作用域是在编译时确定的。这意味着它的环境/范围是固定的，不能随便改变。换句话说，变量只能从声明/创建它的代码块中调用。

**动态范围**被称为**动态**是因为它的环境(外部范围)可以变化。换句话说，变量可以从创建它们的块外部调用。

所以我们可以有另一个使用`rideBritishBoat()`的函数叫做`rideMauritianBoat()` :

```
function rideMauritianBoat() {
  let boatName = "Flying Dodo's Dab";
  const status = rideBritishBoat();
  return status;
}

rideMauritianBoat(); 
```

在动态范围语言中，你可以看到`rideBritishBoat()`中的`boatName`变量的值依赖于它被执行的范围。正如我们可以看到的，这个范围可以改变，因此它是动态的。
所以在`rideBritishBoat()`内部，它调用了`rideMauritianBoat()`的`boatName`变量，这个变量在它的阻塞范围之外。

这就是动态作用域，而词法作用域则相反。

但是请记住，JavaScript 不是动态限定范围的。这只是为了向您展示不同之处。

因此词法作用域在编译时检查变量(变量需要在它所使用的作用域/块中创建并可访问)，而动态作用域在运行时检查变量(变量可能不会在编译时在作用域中创建，但会在函数运行时出现)。

高级开发人员会说:老兄！！JavaScript 不是编译语言！！
拜托，我们改天再谈吧。试着理解我传递的信息。
好吧，我现在很生气。这是给你的练习。

## [](#quick-exercise)快速锻炼

这个函数的输出是什么？

```
 function rideBritishBoat() {
  let boatName = "Queen's Dab";
  function rideWelshBoat() {
    boatName = "Welsh Royal Boat";
    console.log(boatName)
  }
  rideWelshBoat();
}

rideBritishBoat() 
```

## [](#summary)总结

本文的目的是使用基本语法和简短的例子以简单的方式解释**词法范围**。如果你注意到有些单词是粗体的。这些是理解这个概念的关键词。另外，我有很多相同概念的替代定义。这样做是为了让你选择哪个更容易理解。各有所爱😉

从上面我们学到的，我们可以说:

*   作用域是某物(变量)存在的环境/区域
*   作用域可以访问其父级。
*   父作用域不能直接访问内部作用域中声明的变量。
*   词法与变量的声明/创建位置有关。
*   词法作用域强制从创建/声明变量的作用域/块中查找变量，而不是从运行变量的环境中查找。
*   动态范围与词法范围相反。
*   动态作用域从变量运行的地方检查变量。

感谢阅读。我会在下一篇文章中见到你。