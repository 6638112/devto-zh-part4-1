# 走向功能 2 -我们自己的地图、纯度和一些功能结构*

> 原文：<https://dev.to/brunooliveira/going-functional-2-our-own-map-purity-and-some-functional-constructs-o9>

**简介**

在 *[之前的](https://dev.to/brunooliveira/going-functional-higher-order-functions-39f4)* 部分的最后，提到了作为后续，我们将实现我们自己版本的“强大的功能构造”。更准确的说法是称它们为*积木*。原因是双重的:

1.  在文献中，无论是特定的还是非特定的 FP，都倾向于展示和解释这些结构。

2.  使用这些结构的组合，您可以组合它们来创建更强大的逻辑链。

另一个值得一提的方面(`*`)是，这些构造构成了我**个人日常使用的内容，即使是全职使用 Java(从 Java 8 开始，对功能构造子集的支持是可用的——我们将讨论的也是这个子集的一部分)，因此，更多“面向商业”的开发人员也可以从中受益。**

 ****我们将使用的语言**

我将把所有的例子都限制在 Python 和 Haskell 上，最后，我将提到 Java Stream API 如何允许我们使用这些结构。

示例将保持简单和自包含，这将允许任何有技术倾向的人跟随，即使编程语言对他们来说是新的。同时，不要让简单性欺骗了你:仅仅因为示例简短，并不意味着代码不具有高度的可组合性和可重用性——事实上，你会惊讶于如此小的代码片段竟然如此强大。

**积木**

我将解释的结构是:

1.  **map** -转换操作，接收一个函数和一个 iterable，并将该函数应用于 iterable 的每个元素，同时保持原始元素不变。

2.  **匿名函数** -纯的，无名的函数，这里的定义**是**函数(因为是匿名的，我们不能通过名字调用函数，这是一个简单的表达式。然而，我们可以将该表达式赋给一个变量，并将该变量“用作函数”)。

**一次一个地理解和构建“积木”**

我将使用 HaskellWiki 中的定义，并以它们为基础展示一些示例，然后用我最惯用的代码用 Haskell 和 Python 实现实际的构造。

1.  *地图*

地图的定义:

*将另一个函数应用于参数列表并获得结果列表的函数*

Haskell 有一个解释器，基于它的编译器 ghc，叫做 ghci。我将假设阅读这篇文章的人是在 unix 系统下，如果不是，就启动一个在线 Haskell 环境(或者任何其他语言，真的。检查 [http://repl.it](http://repl.it) 是否牛逼)应该是小事。

这样一来，让我们看看 Haskell 中的 map 操作是如何工作的:我们将把一个数字映射到它的平方。

```
GHCi, version 8.6.3: http://www.haskell.org/ghc/  :? for help
Prelude> square x = x*x
Prelude> l = [1,2,3,4]
Prelude> map square l
[1,4,9,16]
Prelude> l
[1,2,3,4]
Prelude> 
```

如上所述，正如我们在第 4 行看到的，map 接收一个函数(还记得这是如何匹配 Python 的吗？)和一个 iterable(在本例中是一个列表),并将该函数应用于 iterable 的每个元素。此外，可以看到原始列表保持不变——没有副作用。

为了实现这个操作，我们需要考虑它**用非正式的术语**做什么:

*   一个函数将被应用到一个列表的每个单独的元素，并且在函数应用之后*将这个元素转换为它的值*

*   如果列表是空的，因为没有元素，所以不能应用任何函数，所以我们返回一个空列表

要实现它，我们需要一个函数对象/引用/变量和一个 iterable。我们想要实现的操作将如下所示:

```
(f, [a,b,c...,z]) --- map ---> ([f(a),f(b),f(c)...,f(z)] 
```

让我们看看如何在 Python 中通过利用 iterable 对象:
的结构来迭代地然后递归地实现这一点

```
>>> def map(f,iter):
...     transformed = []
...     for elem in iter:
...            
transformed.append(f(elem))
...     return transformed 
```

迭代版本遍历列表中的每个元素，将函数应用于每个元素，并将转换后的元素添加到新列表中，简单明了。

```
>>> def map(f,iter):
...     if iter[1:]==[]:
...             return [f(iter[0])]
...     else:
...             return [f(iter[0])]+map(f,iter[1:]) 
```

递归版本的工作方式是提取列表的第一个元素，对其应用转换函数，并将其附加到列表尾部(其余部分)的递归的尚未计算的结果上。当“其余”为空时，我们通过用函数 application 返回单个元素列表来结束递归。

**抽象的力量**

这个想法非常强大，因为它非常抽象:

当一个构造、类或函数非常抽象时，意味着它非常强大。

与习惯用语、商业规则、语言怪癖或现实世界没有任何联系，只是对可重复事物的函数应用的纯数学抽象。

这意味着，现在，您可以将您的业务逻辑映射到其中，并根据需要使用它，**您需要它的方式**:

一些客户的价格翻了一倍？用双重函数映射您的价目表。

需要一个对象的属性？从一个汽车对象开始的汽车牌照列表？创建一个接收汽车并返回其牌照的函数，等等。

**在 Haskell 中实现地图**

map 的 Haskell 实现将基于上面的递归版本，它将显示 Haskell 在表达能力上实际上非常接近这个构造背后的真正数学思想:

```
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs 
```

第一行是类型签名。解释这是什么超出了本文的范围，但它告诉 haskell 编译器，我们的 map 函数接收一个函数(`a->b`)和一个列表(`[a]`)并返回另一个列表(`[b]`)。
值得注意的是，这些参数和它们的名称，根据类型签名，对类型系统中有效的类型和操作进行编码。这一点非常重要:

*功能操作需要类型兼容才能有效*

事实上，这非常重要，Haskell 通过将它嵌入到类型系统中，迫使程序员遵守这条规则。

很明显，你不能将一个函数将字符串反向映射成一个整数列表，但是当你的域变得更大，并且你按顺序应用这些转换操作时，它很容易丢失。哈斯克尔支持我们:)

**匿名函数**

匿名函数，有时被称为 lambdas 或 lambda 函数，是函数式编程世界中一个非常重要的构造，因为它们将自己与其他抽象很好地结合起来，并允许程序员非常清楚地表达他们的意图。它的*功能与定义的值*相同。让我们看看如何定义一个λ来平方一个数:

```
square = lambda x: x*x 
```

这里，square 是保存 lambda 表达式值的变量名。这类似于我们在第一部分中所做的，将函数引用传递给其他函数。

它们与地图结合得非常好，就像这样:

```
map(square, [1,2,3,4])
>>> [1,4,9,16] 
```

这里的主要优点是这段代码易于阅读和理解，因为它清楚地表达了我们的意图:我们想要对一系列数字求平方。这个很有表现力，短小精悍。

**结论**

我希望你喜欢学习 map 和 lambda 函数！下一个帖子，*过滤*和*减少***