# Agola 简介:CI/CD 重新定义

> 原文:[https://dev . to/sgo tti/introducing-agola-ci-CD-redefined-1bl 3](https://dev.to/sgotti/introducing-agola-ci-cd-redefined-1bl3)

[![](../Images/da0a6c0c9a9cfce296b510baaa8e3b79.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--Kd2FdYDF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://agola.io/screenshots/screenshot_run_01.png)

外面有许多 CI/CD 工具，其中一些只作为 SaaS 提供(许多对开源项目是免费的，但其中一些是闭源的)，其他的是开源的，你可以在任何你想要的地方安装它们。那么:为什么是另一个 CI/CD 工具？

在 Sorint.lab，我们多年来使用了许多不同的 CI/CD 工具，我们的开源项目通常使用免费的 SaaS 工具，在内部和从我们的客户那里，我们使用安装在内部的开源工具。因此，这些年来，我们获得了许多 CI/CD 工具的大量知识，并了解了它们的许多优点和缺点。最后，我们总是努力实现一些我们认为对这类工具非常重要的特性。这就是为什么我们创造了自己的工具:Agola。

在设计和编写 Agola 时，我们试图满足的需求是什么？

*   易于安装和管理。
*   可伸缩和高可用性:从单实例(单流程)部署到分布式部署。
*   在任何地方部署:Kubernetes、IaaS、裸机，并在任何地方执行“任务”(目前的容器执行器如 docker 或 orchestrators 和 Kubernetes，但可以轻松扩展到未来的技术或虚拟机，而不是容器)。
*   支持任何语言、部署系统等...(使用正确的图像即可)
*   同时集成多个 git 提供者:您可以在同一个 agola 安装中添加来自 github、gitlab、gitea(以及更多)的 repos。
*   使用它来管理整个开发生命周期:从构建到部署。
*   任务工作流(我们称之为**运行**)能够实现扇入、扇出、矩阵等...，一切都集装箱化，以实现最大的再现性。
*   基于 Git 的工作流:运行定义在 git 存储库中提交(所以一切都是可跟踪和可复制的)。运行执行由 git 动作(push，pull-request)启动。
*   将它设计成最多运行一次的能力:在部署到生产的过程中，我们不希望部署的多个并发执行...
*   可重新启动和可重复运行(使用相同的源提交、变量等从零开始或从失败的任务重新启动运行...)
*   [用户直接运行](https://agola.io/doc/concepts/user_direct_runs.html):让每个用户都能够使用相同的运行定义来测试他们的软件，就像他们在本地运行测试一样(不需要超级强大的工作站)。
*   可测试的“运行”(如果您不能测试您对运行定义的更改，那么 CI/CD 环境是什么？):使用相同的运行定义，但是使用强大的[秘密和变量系统](https://agola.io/doc/concepts/secrets_variables.html)来访问不同的资源(环境、docker 注册表等)...).
*   不要试图将 YAML 扩展成一种模板语言，而是使用一种真正的模板语言(截至目前 [jsonnet](https://jsonnet.org/) )来轻松生成运行配置，而没有副作用。
*   高级权限系统(正在开发中)。
*   依赖关系缓存可加快任务速度

## [](#runs)运行

**运行**是一个工作流程。Agola 是一个持续的实干家，深度集成在基于 git 的工作流中。Agola(或者更确切地说是它的主要服务之一: **Run Service** )以一种容器化和有组织的方式执行“命令”。这些命令可以是任何东西，用任何语言编写，可以做任何你想做的事情。它非常适合 CI/CD 系统。

运行由依赖于其他任务的任务组成，并且只在某些条件下执行，任务是由多个连续步骤组成的容器化执行。

## [](#git-based-workflow)基于 Git 的工作流

我们将它深度集成到基于 git 的工作流中，因为为了实现最佳结果和自动化，我们必须跟踪一切。git 工作流允许您通过 Git 跟踪和控制一切。运行定义在 git 存储库中，因此它与代码紧密相连，可以像其他任何东西一样进行检查。如果你喜欢代码审查(我们喜欢)，使用拉/合并请求来做，agola 将在 PR 上执行运行，并在你将你的变更合并到“主”分支之前提供运行状态。如果您使用特性分支，Agola 将在每次推送时执行运行，并为该提交提供运行状态。
如果您想在推送主新提交或标签时部署到生产环境，agola 可以做到这一点。

### [](#agola-architecture)阿格拉建筑

Agola 是一个年轻但雄心勃勃的项目。在接下来的几周里，我们将创建更多的帖子来详细介绍它的内部结构和架构特性。

作为一个小尝试，Agola 是由多个服务组成的，它可以通过在它的基础服务 API 上编写新的服务来扩展(没有老式插件！).为了完全分布式和高可用性，一些 if 的服务使用两个主要组件:

*   协调多个实例(以多种方式)
*   对象存储(截至目前，共享 posix fs，如 nfs、cephfs 或 s3 等兼容存储)

现在可能有人会问:“数据库在哪里？”。如果你指的是存储所有配置、运行数据等的关系(sql 语言)数据库在哪里...答案是:没有。

开发新事物的一个好处是你可以尝试做一些不同的事情。除了尝试改善 CI/CD 体验，我们还想尝试(并尝试创新)一些新的架构选择。

因为我们想要一个完全分布式和高可用性的系统，所以我们希望只依赖可以完全分布式和高可用性的组件:etcd 和对象存储满足这些要求。因此，我们没有添加第三个组件来增加项目需求，也就是说，到目前为止，很难扩展和实现高可用性(好吧，有一些产品可以实现这一点，如[cocroach db](https://www.cockroachlabs.com/))并按照我们的喜好自由构建我们的数据，而是尝试使用 etcd 和对象存储来实现原子、一致、隔离和事务存储。

这样，一切都在应用程序级别进行管理，而无需将部分逻辑放入关系数据库(约束、外键等)...)或依赖于仅在某些产品上可用的功能。但这是一个很大的争论(也是一个可能改变或证明它是错误的实验)，我们希望在未来的帖子中详细阐述(提示:我们没有抛弃关系数据库，如果你看 agola 代码，你会发现一个使用 sqlite 的名为 readdb 的包:是的，我们使用每个实例的**/本地**、**可重建的**、**关系数据库作为查询的只读数据库)。**

## [](#try-it)试试看

只需尝试一下 agola 演示版(T1 ),看看我们是如何用它来构建/测试 agola(T3)的(T2)

Agola 网站上有 Agola 的各种示例文档

### [](#get-in-touch)取得联系

Agola 是由 Sorint.lab 创建的开源项目，但是我们需要一个社区来围绕它。就任何事情(贡献、帮助、建议等)进行联系...)加入 [Agola 论坛](https://talk.agola.io)和我们 [github 组织](https://github.com/agola-io)。别忘了在阿格拉主储存库([https://github.com/agola-io/agola](https://github.com/agola-io/agola))上留下一颗星星，这不会花你一分钱！