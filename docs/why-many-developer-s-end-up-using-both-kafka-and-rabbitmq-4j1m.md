# 为什么许多开发者最终同时使用 Kafka 和 RabbitMQ

> 原文：<https://dev.to/bradleymcallister97/why-many-developer-s-end-up-using-both-kafka-and-rabbitmq-4j1m>

许多公司使用最新和最棒的技术来保持他们的应用程序高效和快速，并使他们自己富有成效。今天，我将研究开发人员在他们的消息传递技术中寻找的主要特性。Kafka 和 RabbitMQ 这两种最流行的消息传递技术将针对每个特性进行比较。

我要检查的功能有:

*   重播
*   路由选项
*   消费者规模
*   优先消息传递

当我创建一个小的[数据管道](https://github.com/bradleymcallister97/Twitter-Data-Pipeline)时，这些特性变得很重要，因此被选中。

正确理解这篇博客需要 RabbitMQ 和 Kafka 的基础知识。

RabbitMQ 有[文档](https://www.rabbitmq.com/tutorials/amqp-concepts.html)和许多[有趣的例子](https://www.rabbitmq.com/getstarted.html)，这将帮助你理解如何使用它。

卡夫卡有很棒的[文档](https://kafka.apache.org/intro)会教你基础知识。

## 重播

重播是一个非常酷的功能，因为它允许消费者“回到过去”。重放仅仅意味着消息传递技术的消费者可以重新读取使用过的消息。这是有帮助的，因为它允许没有被正确处理的消息被重新读取并被成功处理。它还可以用于启用“后期加入”功能，消费者可以接收过去发布的消息，以加载内存数据库或对历史数据进行新型分析，并启用[事件源](https://martinfowler.com/eaaDev/EventSourcing.html)架构。

Kafka 将其所有消息存储在分布式日志中，消息在被消费后不会被删除。发布给 Kafka 的所有消息都会保留在日志中，直到过了一段时间，这段时间称为保留期。这使得消费者可以从一个给定的卡夫卡主题中重读源流。Kafka 消费者必须为每个主题分区跟踪自己的偏移量。这允许消费者容易地阅读来自过去的消息；只需将偏移量设置为所需的值，然后开始接收消息。

RabbitMQ 会在消息被使用后将其从队列中删除。这意味着不能重放一系列消息。为了在使用 RabbitMQ 时重放消息，需要创建一个重放基础设施。然而，RabbitMQ 应用程序不需要像 Kafka 应用程序那样跟踪它们在日志中的位置，因为 RabbitMQ 代理为它们做了这件事。

## 路由选项

路由在消息传递中很重要，因为当消息传递代理可以处理复杂的路由选项时，它可以简化开发过程。在开发服务时，路由选项可以给开发人员更多的自由和灵活性。

RabbitMQ 使用处理不同路由选项的交换。RabbitMQ 交换将接收一条消息，并将其路由到零个或多个队列。队列与交换绑定在一起。

可能的 exchange 路由选项包括:

*   扇出
*   直接的
*   主题
*   页眉

扇出交换机将消息广播到绑定到该交换机的每个队列。

直接交换使用路由关键字，它是一个短字符串。这种交换将邮件路由到与路由关键字完全匹配的所有队列。

topics 方法类似于 direct，因为它使用路由关键字，但允许通配符匹配和精确匹配。这意味着队列可以直接订阅像“alarm”这样的主题，或者使用像“#”和“*”这样的通配符。

例如，如果消息发布到主题“alarm.power.off ”,那么为了通过主题交换接收该消息，队列需要订阅主题“alarm.power.off”。如果队列想要订阅所有与电源有关的警报，那么它将订阅“alarm.power. *”。“*”字符是任何单个级别的通配符，因此它将接收主题为“报警.通电”和“报警.断电”的消息。如果队列想要订阅所有警报，那么它将订阅主题“警报”。#".“#”字符是许多级别的通配符，因此队列将接收发送到主题“alarm.power.on”、“alarm.error”和“alarm.connection.state.changed”的消息。

头球交换是最有力的，但也是最慢的。这种类型的交换可能会导致伸缩问题。这些交换不使用路由关键字，而是解析消息的报头。绑定到交换的每个队列在头中可以有多个值，这些值可以与消息中的任何值或所有值匹配。例如，每封邮件的标题中可能包含以下值:

*   身份证明（identification）
*   名字
*   状态

根据这些值，可能有以下可能的绑定:

*   id=7，名称=foo，状态=0，x-match=any
*   id=12，名称=栏，状态=1，x 匹配=全部

x 匹配值包含任意或全部。

Kafka 的路由选项非常有限，因为它只提供主题路由方法，没有通配符订阅。

## 消费规模

使用传统队列扩展消费者将导致竞争消费者。竞争消费者是指多个消费者都从[单一点对点通道](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PointToPointChannel.html)接收消息。当消息被添加到通道中时，任何消费者都有可能收到该消息，但是只有一个消费者会收到它。这可能会导致相关消息被无序处理。

卡夫卡有一个特点叫消费群体。消费者组是一组消费者服务，它们将处理发布到某个主题的消息。卡夫卡考虑消费者群体的方式是，给消费者群体中的每个服务一个整数个主题分区。例如，如果一个主题有 3 个分区，有 2 个服务，那么一个服务将得到 1 个分区，另一个服务将得到 2 个分区。因为所有相关的消息都被写入同一个分区，所以使用者组允许按顺序处理所有相关的消息。例如，相关消息可以是给定客户记录的不同更新。

RabbitMQ 的消费者可以通过让多个消费者从同一个队列中读取来扩展，但是这会导致消费者之间的竞争。竞争消费者可能是不可取的，因为它潜在地允许相关消息被无序地处理，但是当顺序不重要时，它们不是问题。

RabbitMQ 允许一致的散列交换，它只是将一个队列分成多个队列。消息通过路由关键字、消息头或消息属性的散列在队列之间分发。

由于 RabbitMQ 不像 Kafka 那样帮助协调消费者，所以一致性散列存在问题。

## 消息优先级

根据应用，发送优先级消息可能很重要。具有不同的优先级允许在拥塞期间在较低优先级消息之前处理较高优先级消息。

Kafka 目前还没有一种方法允许按优先级发送消息或按优先级顺序传递消息，因为 Kafka 实现了一种有序日志——因此所有消息都按接收顺序存储和传递，而不管消费者端是否拥挤。

RabbitMQ 支持优先级队列。这意味着单个队列可以被设置为具有自己的优先级范围。每条消息的优先级可以在发布时设置。如果没有为消息提供优先级，将自动设置默认值。根据消息的优先级，它被放置在适当的优先级队列中。

## 结论

提到的所有特性都是像我这样的开发人员希望他们的消息传递技术具有的重要特性。然而，并不是所有的功能都可以在任何一个产品中使用。卡夫卡和 RabbitMQ 似乎是互补的，因为一个提供了另一个所不能提供的特征。这可能是许多开发人员最终同时使用这两种技术的原因。