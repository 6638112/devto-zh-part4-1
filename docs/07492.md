# 走向泛函:高阶函数

> 原文：<https://dev.to/brunooliveira/going-functional-higher-order-functions-39f4>

**简介**

函数式编程已经席卷了软件开发领域。这个概念并不新鲜，它早于我们所知的高级编程语言的出现，源于λ演算。

在本系列中，我将解释一些函数式编程概念，并将它们应用到一些问题中，以展示如何轻松地表达对许多使用编程的领域至关重要的概念，另外，一旦熟悉了概念，使用它的代码会变得多么简单。

**问题**

我将用这个问题来举例说明 FP (functional programming，简称函数式编程)上下文中*高阶函数*的重要概念。

> 这个问题是简街问的。
> 
> cons(a，b)构造一个对，car(pair)和 cdr(pair)返回该对的第一个和最后一个元素。例如，car(cons(3，4))返回 3，cdr(cons(3，4))返回 4。
> 
> 给定 cons 的这种实现:
> 
> ```
> def cons(a, b):
>      def pair(f):
>         return f(a, b)
>     return pair 
> ```
> 
> 实施 car 和 cdr。

所以我们需要实现两个函数，`car`和`cdr`，它们分别返回一个对的第一个和第二个元素。

首先是一些概念。(旁注: *[这个](https://en.wikipedia.org/wiki/CAR_and_CDR)* 解释了这些函数名字背后的含义。怪 50 年代后期的:D)

**函数、闭包...高阶函数**

**简单功能**

一个函数最常见的形式，可以被看作是一个小的、有凝聚力的单元，它完成某项任务，并且能够或不能够产生一个结果用于其他地方。

```
def f(a,b):
  return a+b 
```

我们上面的函数`f`接受两个参数，并返回两个参数之和的结果。

这是一个简单的函数，因为它返回一个结果值。

**关闭**

闭包可以被看作是将一个函数和它的周围环境(作用域)结合在一起的数据结构。查看 HaskellWiki，我们得到这样的定义:

> 闭包，与组合子相反，是一个在其定义中使用自由变量的函数。它“关闭”周围环境的某个部分。

在 Lambda 演算中，有些函数有“自由变量”，这意味着它们使用没有作为直接参数传递给它们的变量。在这种情况下，带有自由变量的函数就是我们所说的“闭包”。

在我们的示例问题中，内部函数`pair`是一个闭包，因为它使用了在外部作用域(在`cons`级别)上定义的变量`a`和`b`。

**高阶函数**

闭包可以被看作是高阶函数的一个特殊例子，它接收一些参数作为输入，它的返回结果本身就是一个函数，可以像其他变量一样使用和传递。

下面是 Python 解释器中发生的事情:

```
>>> def cons(a, b):
...     def pair(f):
...             return f(a,b)
...     return pair
... 
>>> myfunc = cons(1,2)
>>> myfunc
<function pair at 0x7f05403e6758> 
```

所以，我们可以看到`myfunc`是一个函数类型的变量。

这是有意义的，因为我们看到内部函数`pair`是从调用`cons`返回的。

然而，我们还可以看到另外两件事:

1.  `pair`本身接收一个函数，`f`作为它的参数，因为它是一个闭包，所以它使用不同作用域上的参数，并通过用这些参数调用 f，将它们“封闭”在自己的作用域内。

2.  为了解决手头的问题，我们需要将函数传递给函数。

**使用高阶函数的简单例子**

所以现在让我们假设我们想要一个函数`maxOfTwo`，它接收一个`pair`作为它的参数，并返回两个参数中最大的元素。

既然我们知道我们需要将一个函数传递给另一个函数，让我们首先定义我们需要什么:一个函数来执行返回传递给它的两个参数中最大的参数的操作:

```
>>> def maxOfTwo(a,b):
...     if a >= b:
...             return a
...     else:
...             return b
... 
>>> maxOfTwo(4,5)
5
>>> maxOfTwo(5,5)
5
>>> maxOfTwo(55,5)
55
>>> x = maxOfTwo(1,2)
>>> x
2 
```

所以我们现在可以使用我们的函数，将变量赋给它的返回值，一切都正常了。

现在，要将这个函数作为参数传递给`cons`，我们可以将我们的函数对象作为我们之前定义的变量`myfunc` :
的参数传递

```
>>> myfunc = cons(1,2)
>>> myfunc(maxOfTwo)
2 
```

请注意我们是如何做一些有趣的事情的:

*我们使用函数作为值*

在 FP 中，一个函数可以接收其他函数，并把它们当作传递的正常值。

这是一个非常强大的想法，因为它允许创建非常抽象和通用的运行时构造，允许很大的灵活性。

最后，为了解决我们的问题，`car`应该接收一个函数，该函数接收两个参数并返回第一个参数，`cdr`返回第二个参数:

使用闭包，我们可以得到这个解:

```
>>> def car(p):
...     def getFirst(x,y):
...             return x
...     return p(getFirst)
... 
>>> car(cons(3,4))
3
>>> 
```

```
>>> def cdr(p):
...     def getSecond(x,y):
...             return y
...     return p(getSecond)
... 
>>> cdr(cons(3,4))
4
>>> 
```

**结论**

我希望你理解了一些新的东西，也希望你对闭包、高阶函数以及如何应用它们有更多的了解。

在下一期中，我将讨论 lambda 函数，我们将看到如何用我们已经知道的东西实现强大的函数构造！