# 为什么我们的团队取消了向微服务的迁移

> 原文:[https://dev . to/twynsicle/why-our-team-canceled-our-move-to-micro services-1ln 8](https://dev.to/twynsicle/why-our-team-cancelled-our-move-to-microservices-1ln8)

最近，我们的开发团队在我们的特性交付时间表上有了一个小小的突破。技术领导层认为，这段时间最好是将我们的整体架构拆分为微服务。经过一个月的调查和准备，我们取消了搬迁，而是决定坚持使用我们的 monolith。对我们来说，微服务不仅不会帮助我们；他们会伤害我们的发展进程。微服务已经作为理想的架构卖给我们大约一年了。所以我们惊讶地发现它们并不适合我们。我认为展示一个关于我们经历的案例研究，以及为什么我们的团队决定反对他们，会很有趣。

# [](#identifying-finding-problems-and-early-compromises)识别发现问题和早期妥协

### 我们严重依赖第三方

我们的应用程序是现有外部产品之上的自定义 UI，集成了一些自定义业务规则，并呈现了一个触摸友好的用户界面。我们的客户端是一个 UWP 应用程序，我们有一系列后端服务，在我们的域和第三方的域之间转换。

基于第三方构建影响了我们如何将我们的领域划分为微服务。例如，我们的应用程序偶尔需要在域之间转换特性。让第三方域的一部分在我们的用户界面中表现得像是另一个域的一部分。当我们在我们的前端和第三方之间有一个单一的服务时，这种交换并没有那么糟糕。然而，当我们试图将我们的域分割成独立的微服务时，域切换给我们带来了很多困惑。我们的微服务是否遵循与第三方相同的划分，我们是否在两种服务中重复前端需求？或者，我们是否根据我们的域划分了微服务，并让一个微服务需要从第三方的两个独立区域获取数据。这两种情况都违反了微服务准则，并且会导致额外的耦合。

我们经常与外部方协同工作，需要双方都做出改变。实际上，第三方是一个额外的团队。如此紧密的合作意味着我们必须与他们同步发布。微服务的一个好处是，每个团队可以独立负责发布他们的服务，无需与其他团队协调。不只是跨团队，而是跨公司协调发布，这阻止了我们获得这些优势。

微服务的中心思想之一是从负责不同层的不同团队中重组出来。在微服务架构中，每个团队负责解决其业务问题的整个堆栈。对我们来说，由于我们的一个层次是一个完全独立的公司，这种重组是不可能的。

### 我们无法充分隔离每个微服务

在我们的整体中，我们找不到任何明显的候选对象来开发微服务。因此，我们开始在我们的领域模型之间画任意的线，由此，我们有了要创建的微服务的列表。然而，一旦我们开始调查，我们发现在即将分离的微服务领域之间有许多共享的业务逻辑和隐含的耦合。有人进一步尝试将这些微服务细分为越来越小的部分，但这给我们留下了更多的耦合、无处不在的消息总线，以及从一个服务立即发展到十个或更多微服务的潜在大爆炸。

一切都如此紧密相连，难以分离的原因是，我们试图分离的整体只服务于一家企业。我们的客户端应用程序的首要设计目标之一是将第三方基础应用程序中不同的概念结合在一起。为了方便用户，我们正在创建跨域的工作流并对功能进行分组。本质上，UI 已经花了四年时间将所有的东西都推到了一起。

在这个过程中，我们误解了应该如何隔离微服务，并且低估了在服务之间选择正确边界的重要性。我们可以打破我们的整体结构的唯一方法意味着实现一个标准的“特性”将涉及同时更新多个微服务。每个特性都需要不同的微服务组合，这防止了任何微服务被一个团队所拥有。

### [](#sharing-microservices)共享微服务

我们有大约 12 名开发人员，分布在两个功能团队和一个支持团队。工作波动很大，以至于没有团队被锁定在应用程序的任何领域。两个团队同时接触相同的代码区域并不罕见。我们无法将任何潜在微服务的所有权分配给单个团队。

在考虑你的建筑形状时，牢记康威定律是很有用的。它指出你的软件架构以一种模仿你的组织和团队结构的方式成长。如果你有一群独立的团队在处理独立的业务问题，那么大量独立的微服务是有意义的。然而，很少有团队致力于更适合单一共享位置的共享特性。

### 平台还没有准备好

各种各样的问题意味着至少在 6 个月内，我们将在 IIS 中的 monolith 旁边托管我们的新微服务。我们将无法使用许多与微服务相关的标准工具，如容器、Kubernetes、服务总线、API 网关等。如果没有这些工具，微服务之间的通信会变得更加困难。因此，我们决定每个微服务将复制任何共享逻辑以及来自存储层的常见读取和转换。因为我们不能适当地隔离我们的任何服务，这将意味着我们会留下大量的重复。例如，我们确定了一个特别复杂和重要的业务逻辑，它必须跨 4 个计划的微服务进行复制粘贴和维护。

### 我们对未来没有清晰的认识

开发团队对接下来的 6 个月有一个粗略的想法，没有任何关于之后的信息。此外，企业经常改变主意。需求改变 mid 特性并不罕见。这种不确定性使得创建微服务更加困难，因为我们无法预测会出现什么样的新链接，即使是在短期内。计划中的微服务之间的连接和耦合会增加吗？我们需要花几个月的时间将它们重新组合在一起吗？今年早些时候，我们已经尝试创建一个验证概念的微服务，但随着业务需求的变化，它被取消了。

### [](#time-frames-were-tight)时间很紧

我们有一个很小的窗口，足够将我们的整体分割成我们得到的微服务列表。我们所没有的是任何额外的时间来让我们反思我们所创造的东西，或者在必要时改变路线。时间表中没有 b 计划的时间。我们将被我们创造的东西所束缚。由于我们在规划阶段发现了许多问题和挑战，更不用说实现阶段了，这引起了开发团队的极大关注。

### [](#lacking-experience)缺乏经验

除了风险和时间压力之外，负责设计或实现微服务架构的人员都没有任何特定的经验。由于没有大量现成的标准工具，这种情况变得更加严重，这意味着我们将自己实现平台。与一些有微服务经验但没有参与其中的人的谈话，提出了更多的危险信号。建议基础设施，我们不会，指出我们在领域模型之间划线的后果。

到目前为止，我们的计划包含了许多偏离标准微服务模式的妥协，时间紧迫。没有专家的指导，很有可能会犯很多错误，也很难吸取教训。开发团队开始紧张起来。

# 我们想要达到的目标是什么？

### [](#is-this-addressing-our-pain-points)这是否解决了我们的痛点？

一旦一切开始变得艰难，清晰的前进道路开始迷失，我们停下来，意识到我们不知道为什么要做这些。我们没有痛点列表，也不清楚这将如何帮助解决我们确实存在的任何痛点。更糟糕的是，微服务可能会给我们带来一系列新问题。我们开始强调这些问题，我们应该得到什么好处，我们试图解决什么问题？我们安排了越来越多的会议试图弄清楚这一切，每次喝咖啡休息和开发者之间的每次对话都在讨论和质疑微服务，我们仍然无法得到一个直接的答案为什么。
事实证明，我们确实有其他更紧迫的痛点，这些痛点在转向微服务的过程中被忽略了。不幸的是，我们可能没有时间来充分解决这些问题，这意味着我们既没有微服务也没有其他任何东西。

### [](#what-were-the-potential-benefits)潜在的好处是什么？

当我们意识到我们不知道为什么要走向微服务时，我们停下来，开始自己研究微服务通常提供的好处。

#### [](#autonomy)自主

微服务使您的团队能够控制交付某项功能所需的全部资源。这种分离的好处是减少了您需要与其他团队协调的数量。你不会影响他们的工作，他们也不会影响你的工作。

#### [](#allows-your-team-to-specialize)允许你的团队专精

在 monolith 中，任何团队都可以在任何事情上结束工作。任何功能或区域的所有权都不是既定的。由于每个团队都拥有自己的服务集，他们可以在特定的业务领域积累专业知识。他们开始理解他们领域中的业务规则和需求。他们知道他们的软件堆栈是如何构建和实现的，并且在进行更改时有更大的信心。

#### [](#easier-to-scale)更容易缩放

借助微服务，您可以根据性能需求扩展每项服务。使用 monolith，虽然您还可以跨更多服务器进行水平扩展，但是您不能将 monolith 的每个组件彼此独立地进行扩展。此外，这种粒度使得根据需要扩展和缩减服务变得更加容易。也许您预计会有一些额外的负载，或者在解决性能问题时需要一些喘息的空间。

#### [](#easier-to-rollback)更容易回滚

如果每个特性只需要对单个微服务进行更改，那么该特性可以回滚，而不会影响其他团队的工作。此外，微服务有助于减少单个故障可能导致的系统瘫痪。

#### [](#easier-to-release-and-easier-to-release-more-frequently)更容易释放，更容易更频繁地释放

如果您有一个庞大的系统，那么每个版本都将变得耗时且有风险。回归测试需要覆盖很多内容，限制了您的发布节奏。您可能需要多人的签署，以及每个版本中涉及的所有团队之间的协调。来自一个你从未听说过的团队的一个 bug 或回归可能会阻碍你需要的时间敏感的特性。微服务限制了变更的范围，减少了团队之间需要的协调量。团队可以根据他们自己的时间表发布，而不是被一个整体的节奏所束缚。

#### [](#use-the-most-appropriate-technologies)使用最合适的技术

微服务让你的团队能够为他们的团队和他们试图解决的问题选择最合适的技术。也许他们可以使用现代技术，而 monoliths 可能很难升级，并且停留在过时的平台上。

#### [](#easier-path-to-upgrading)升级更容易

即使在最好的情况下，升级大型应用程序所使用的框架也不是一件有趣或没有风险的事情。当你需要跨多个团队协调大范围的、相互关联的变更时，这要困难得多。较小的独立服务使您可以选择只升级需要更新的服务，或者允许您一次升级一个服务和一个团队。

#### [](#protect-from-change)保护免受变化

应用程序的不同部分以不同的速度变化。您的大部分应用程序可能几个月甚至几年都没有更改过。将很少改变的代码从频繁变动的区域中分离出来，可以降低意外回归的风险。

#### [](#smaller)变小

较小的服务更容易推理和理解。此外，只由一个团队改变意味着它的设计保持一致。它较小的尺寸使它更容易执行广泛的重构。相比之下，一个整体可能有一个不一致的、进化的架构，因为不同团队的意见导致它随时间而变化。

#### [](#conclusion-of-benefits)结论的好处

采用微服务有很多潜在的好处。然而，我们能够获得其中任何一个吗？

最终，我们不能改变的架构部分和我们必须做出的妥协破坏了好处。微服务是一个在所有团队之间共享的浮动池，功能分散在多个共享的微服务中，这意味着我们失去了隔离的好处:减少了协调、专业化和由此产生的好处。微服务之间的变异，没有成为优势，反而成了劣势。每个特性都需要学习一个新的微服务是如何工作的，以及其他团队对它做了什么改变。我们对第三方的依赖阻止了我们改进我们的依赖节奏，并减少了我们从独立扩展我们的服务中获得的好处。

# [](#weighing-up-the-advantages-and-disadvantages)权衡利弊

### [](#killing-a-fly-with-an-elephant-gun)用大象枪打死一只苍蝇

采用微服务不是免费的。您需要解决的其他问题还有很多。我们需要重新审视我们之前在《monolith》中提到的许多问题。例如，我们需要解决或重新审视:日志记录、监控、异常处理、容错、回退、微服务到微服务的通信、消息格式、容器化、服务发现、备份、遥测、警报、跟踪、构建管道、发布管道、工具、共享基础架构代码、文档、缩放、时区支持、分阶段推出、API 版本、网络延迟、健康检查、负载平衡、CDC 测试、容错、调试以及在我们的本地开发环境中开发多个微服务。

更糟糕的是，如果没有微服务平台，我们将不得不为自己做很多上面的工作。我们已经有了向微服务迁移的痛点和困难；我们确定我们不会从迁移到微服务的优势中受益，并且我们有一长串的额外工作要设置和维护以支持微服务。

### [](#microservices-in-name-only)名存实亡的微服务

下图展示了我们当前的整体结构、我们计划的架构以及微服务的外观对比。从结构上看，我们的新建筑仍然与我们的整体建筑非常相似，所有的东西仍然紧密地联系在一起。我们甚至应该使用微服务标签来描述我们正在做的事情吗？
[![](../Images/d25fbba51a548deee836b987cab003d8.png)T3】](https://res.cloudinary.com/practicaldev/image/fetch/s--Q7uhysb3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/32wtqur02t6x8h8makyj.png)

### 我们的巨石有那么糟糕吗？

我们使用 monolith 就像一个负载的术语。好像说“monolith”暗示着什么可怕的东西，“microservices”暗示着什么美好的东西。一旦我们超越了刻板印象和品牌，开发团队对我们的“整体”就没有什么问题了这可能是我们整个系统中最没有痛苦的部分之一。它的开发和扩展非常简单，因为它主要是通向第三方的通道。我们不需要在这上面花太多时间。我们有一个出色的 CI/CD 设置，这使得部署和回滚变得很容易。我们的分支和测试策略确保了进入生产的问题很少。

### [](#realizing-i-had-used-microservices-before)意识到自己以前用过微服务

此时，我意识到我在以前的角色中确实有过微服务的经验。我们从未将它称为微服务，它可能没有遵循微服务的所有“规则”，但它无疑解决了同样的问题，并给了我们同样的好处。我们是一个由大约 200 名开发人员组成的公司的 5 人小团队。也许我们 5%的后端工作是在公司共享的 monolith 上，一个巨大的 C#应用程序。其余时间，我们在两个节点服务中工作。

我们不喜欢在巨石柱上工作。工作、编译和运行测试都很慢，架构变化到不可知的程度，随机的东西不断出现在构建步骤中。很多次，我们有一个客户的高优先级工作被延迟了几个星期，因为一个我从未听说过的团队在功能上退步了。定期的技术更新需要几个月的时间，因为它们需要整个公司的协调。当我们等待来自完全不同的团队的批准时，拉取请求可能会被搁置数周。

同时，我们的两个服务都很小；我们完全控制了他们的开发、架构和部署。有一次，当我们遇到性能问题时，我们将生产中的实例数量增加了一倍，直到我们解决了根本问题。我们很少需要与其他团队合作。让我们的服务使用 TypeScript 允许我们的主要前端开发人员团队在前端和后端使用相同的语言。最重要的是，它允许我们在客户端和后端验证和报告服务中包含复杂的规则计算引擎。我们的团队专注于一个非常狭窄的业务领域，我们都成为了这方面的专家。

### [](#more-than-just-a-technology-problem)不仅仅是技术问题

我们对微服务了解得越多，就越觉得它与技术的关系越少，而与构建团队和团队工作的关系越多。我们是否犯了一个错误，将微服务视为纯粹的技术问题？

重组团队以专注于独立的业务关注点可行吗？即将到来的特性工作可以在 monoliths 域之间清晰地划分吗？所有团队都有足够的工作吗，或者一个团队没有工作？团队会被堆积如山的高优先级工作搞得焦头烂额吗？使我们难以分割我们的整体的同样的问题也会阻止我们的管理层分割新的工作吗？他们对这种转变的兴趣。有许多关于大局的问题没有答案。

### [](#getting-from-a-to-b)从甲地到乙地

我们的微服务计划是一次大爆炸。每个人都停止功能工作几个月，并开始分裂我们的整体。尽管许多先决条件还没有准备好。我们是在强行前进，而不是等待需求的出现或自然候选人的出现。

这不仅不是一个从 a 到 b 的好方法，而且也是一种倒退。首先创建所有的微服务，然后为它们建立基础设施，完全忽略构建团队和即将到来的工作的方面。相反，如果我们围绕专门的业务问题重组我们的团队，然后准备好基础设施，我们就为微服务的自然出现奠定了基础。如果出现任何新的业务问题，它们可以直接放入新的服务中。

通过强制微服务，这意味着我们还必须提前选择每个微服务的大小。关于将每个微服务做得多大(或多小)，有许多相互矛盾的建议。一些文章建议每个微服务对于一个团队来说应该足够大。其他人建议每个微服务应该足够小，以至于你可以在头脑中记住它的结构，甚至小到你可以在两周内重写它。其他人建议他们应该是每个企业的大小。领导层决定根据我们的领域模型分割我们的微服务，然后在出现任何问题时继续将它们分割得更小。这导致了上面提到的需要共享微服务的团队和特性的许多问题。事后看来，如果我们让微服务在其他一切就绪后自然出现，我们可能会以实际规模的微服务告终。

### [](#cancelling)取消

随着微服务日 1 越来越近，我们的团队不断发现越来越多的问题。产生更多的妥协并进一步减少收益。从开始实施我们的微服务的第一个冲刺开始已经过去了四天，我们仍然无法确定任何收益，问题和缺点的列表足够长，可以形成这篇相当长的博文的种子。我们召开了一次会议，尽管领导层想要什么，但微服务的答案写在了每个开发人员的脸上。我们转向微服务的计划被取消了。

### [](#so-what-did-we-do-instead)那么我们反而做了什么？

转向微服务的热情意味着替代方案没有被调查。只有在我们放弃微服务后，我们才能研究其他选项。最终，我们开始将我们的解决方案分解成现有整体中的独立项目，而不是将我们的整体分割成独立的服务。这种划分给了我们一点额外的结构，并更好地指出了耦合和重复存在的地方，而没有微服务的额外负担和挑战。

此外，这种结构将使我们的领域模型更加清晰，允许我们更容易地评估任何未来微服务的候选。如果某样东西确实是一个合适的候选者，那么这个项目就可以从我们的整体中“掉”出来，变成一个微服务，而不必被解开。

### [](#conclusion)结论

领导层设定微服务的方向，而不考虑我们应用的挑战和状态。评估之后，我们发现微服务不适合我们，需要做出重大妥协。这种妥协剥夺了我们的任何好处，意味着转向微服务是一种净损失。微服务是在没有评估团队结构和新工作等非技术问题的情况下决定的。经过几个月的调查和工作，我们放弃了这个项目，用剩下的时间对我们的“monolith”进行了一些小的重构。