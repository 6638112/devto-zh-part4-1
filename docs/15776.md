# 解剖试剂.第 2 部分:渲染与不变性

> [https://dev . to/vindicussouza/disguise-react-part-2-render acao-e-immutation-3hh 0](https://dev.to/viniciusersouza/dissecando-react-parte-2-renderizacao-e-imutabilidade-3hh0)

# 什么是元素？

简而言之，它们将是我们在反应器中的分子。是我们的元素组成了我们的组成部分，因此不应该与此相混淆。

```
 const meuElemento = <p>Conteudo do Elemento</p> 
```

上面是一个元素的示例。如《反应器文档》所示，元素只是物品，与浏览器中的 **DOM** 元素相比，其创建成本非常低。让**试剂 DOM** 负责控制和更新 **DOM** 中的元素。

# 不变性和渲染

我们需要了解一些重要的术语，这些术语负责渲染我们的元素。

一、根。注意以下代码片段:

```
 <div id="root"></div> 
    const titulo = <h1>Conteudo do Titulo</h1>
    ReactDOM.render(titulo, document.getElementById('root')); 
```

**根**定义节点(或*节点*，我们的反应将在其中管理插入的元素。在上例中，我们将元素**【标题】**插入我们的`div`根中。

我们的应用程序通常只有一个根节点。在使用 React 进行集成的应用程序中，这种情况可能会有所不同。

但是，reactdom 怎么能知道屏幕上发生了什么变化以及需要更新哪些内容呢？遵循**不变性**的原则。React 元素是不可变的，即一旦创建，就不能更改其属性。它们代表了它在某个时间点的界面。很深，不是吗？

因此，其次，我们有另一个重要的名称:**reacdom . render()**。在此之前，我们创建和渲染新元素的唯一方法。每次更改我们标记`ReactDOM.render()`的内容时，我们都要再次调用`ReactDOM.render()`并重新创建此元素。

这就是魔法发生的地方-我...。

# 在获胜的队伍中不要动-我...。或者差不多吧。

反应堆就是这么做的。将元素及其子代与以前的元素进行比较，仅在 DOM 中更新所需的更改，从而避免仅为简单更改而完全加载页面。

尽管我们的元素很复杂，但只有与早期版本相比发生变化的部分才会在屏幕上重新渲染。

考虑到这种行为，我们的元素在反应堆中的处理方式就容易得多了。

# 结论

虽然我们以前的阅读更加激烈，但今天的阅读已经简单了一点，但并不逊色。了解不变性原理以及我们的反应如何更新浏览器天赋中的信息，是真正掌握我们组件和应用程序行为的关键。

我希望，该案文将有助于确定 React 的概念，并成为我们即将提出的下一个案文的桥梁，我将在这里更好地谈及组件、类和功能。

你的反馈对我总是很重要！我会在评论中或亲自等你的联系方式。

下次见！