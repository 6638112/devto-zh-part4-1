# 面试问题:堆 vs 栈(C#)

> 原文：<https://dev.to/tyrrrz/interview-question-heap-vs-stack-c-5aae>

# 前言

最近我让自己失业了，几个星期以来，我经常做技术面试，作为寻找新工作的一部分。尽管每个项目都是独一无二的，面试官往往会不时地问同样的问题。我决定记录下我遇到的最常见的面试问题，并写下我对这些问题的回答。

当你处于工作间隙时，为面试做准备可能会很乏味。因此，我欢迎你继续关注这个系列，在这个系列中，我将尝试在每篇文章中涵盖不同的采访主题。我会试着定期写这些，希望能对某人有所帮助。

*注意:如果你发现了错误，请在评论中告诉我，我会改正的。谢谢！*

# 堆 vs 栈

* * *

**问:C#中对象分配在哪里？**

在 C#中，有两个地方可以存储对象——堆和堆栈。

分配在堆栈上的对象只能在堆栈框架内使用(方法的执行)，而分配在堆上的对象可以从任何地方访问。

* * *

**问:哪些对象分配在栈上，哪些对象分配在堆上？**

注意:你不应该说“引用类型是在堆上分配的，而值类型是在栈上分配的”，这是一个经常犯的错误，对一个有经验的面试官来说是一个危险信号。

引用类型(类、接口、委托)总是在堆上分配。

当你把一个引用对象作为参数传递或者把它赋给一个变量时，你实际上是在传递它的引用。引用(不是被引用的对象)既可以在堆栈上分配，也可以在堆上分配。

通过传递对一个对象的引用，您可以知道该对象在堆中的位置，以便您的代码可以访问它。

每次对象作为引用传递时，引用本身都会被复制。这意味着您可以更改引用以指向不同的对象，而不会影响前一个对象本身或指向它的其他引用。引用是轻量级的，并且总是大小不变(32 位或 64 位，这取决于 OS 位)，因此复制它(从而传递引用类型)被认为是廉价的。

值类型(从`System.ValueType`派生，例如`int`、`bool`、`char`、`enum`和任意`struct`)可以在堆上或栈上分配，这取决于它们被声明的位置。

*   如果值类型被声明为方法中的变量，那么它被存储在*堆栈*中。
*   如果值类型被声明为方法参数，那么它被存储在*堆栈*中。
*   如果值类型被声明为一个类的成员，那么它和它的父类一起被存储在*堆*中。
*   如果值类型被声明为一个结构的成员，那么它就存储在该结构存储的任何地方。

从 C#7.2 开始，一个`struct`可以被声明为`ref struct`，在这种情况下，它将*总是*被分配到堆栈上，防止它在引用类型内部被声明。

值类型的实例通过复制传递(除非与引用语义一起使用，见下文)。这意味着每次将值类型赋给变量或作为参数传递时，都会复制该值。

因为复制值类型的开销取决于对象的大小，所以不建议将占用大量内存的对象声明为值类型。

因为 C#中的每个类型都是从`System.Object`派生的，所以值类型可以被赋给变量或者传递给需要`object`的方法。在这种情况下，在一个被称为*装箱*的操作中，值被复制并存储在包装为引用类型的堆中。

* * *

问:我们可以使用带有引用语义的值类型吗？

`ref`、`out`、`ref return`、`ref local` (C#7.0)、`in` (C#7.2)等关键字允许参照访问值类型。这意味着，只要该值类型的生存期比消费代码的生存期长，消费代码将接收对该值的引用，而不是复制该值，无论是在堆栈上还是在堆上。

* * *

问:堆内存是如何释放的？

当弹出包含堆栈的框架时，存储在堆栈上的对象消失了，而存储在堆上的对象所使用的内存需要由*垃圾收集器*释放。

当存储在堆上的对象不再有任何指向它的引用时，它被认为有资格进行垃圾收集。

在某一时刻，垃圾收集器开始工作，中断所有正在运行的线程，调用它试图清除的对象的终结器(在一个特殊的终结器线程上)，然后将内存标记为可以使用。

* * *

**问:在堆上分配和取消分配内存可能会导致什么问题？**

随着堆上的内存被分配和取消分配，它会变成碎片。见下图:

```
HEAP:
---][-------][----------][-----]........
      obj 1      obj 2    obj 3   free 
```

Enter fullscreen mode Exit fullscreen mode

当`obj 2`被释放时，它的内存变得空闲:

```
HEAP:
---][-------]............[-----]........
      obj 1      free     obj 3   free 
```

Enter fullscreen mode Exit fullscreen mode

现在，如果运行时需要在堆上分配另一个对象，它可能会使用由`obj 2`释放的内存，但前提是新对象确实“适合”。如果内存不够，运行时可以通过扩展其工作集向操作系统请求更多的连续内存，如下所示:

```
HEAP:
---][-------]............[-----][--------------------]...
      obj 1      free     obj 3         obj 4 
```

Enter fullscreen mode Exit fullscreen mode

碎片化的结果是，内存使用效率变得更低。为了解决这个问题，垃圾收集器可能会重新安排内存，以便没有间隙。这是通过简单地复制周围的字节来完成的，这一操作称为“碎片整理”。

```
HEAP:
---][-------][-----][--------------------]...............
      obj 1   obj 3         obj 4               free 
```

Enter fullscreen mode Exit fullscreen mode

* * *

**问:什么是大型对象堆，它有什么用途？**

根据消耗的内存大小，内存碎片整理可能会很昂贵，这就是为什么堆被进一步分为*小对象堆* (SOH)和*大对象堆* (LOH)。

如果一个对象小于 85kb，那么它被存储在 SOH 上，否则它被存储在 LOH 上。这个 85000 字节的截止点是根据经验设计的，在该点之后，碎片整理不再提供性能优势。

由于 CPU 处理`double`的方式，`double`的数组是一个例外，如果数组中有超过 1000 个元素，这样的对象就存储在 LOH 中。

LOH 中的内存(通常)不进行碎片整理，以较低的内存使用效率为代价提供了更好的性能。