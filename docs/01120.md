# stack to the Future——我如何将自动化构建从 Maven 迁移到 Gradle。

> 原文:[https://dev . to/to haker/stack-to-the-future-how-I-migrated-an-automated-build-from-maven-to-gradle-2b6m](https://dev.to/tohaker/stack-to-the-future-how-i-migrated-an-automated-build-from-maven-to-gradle-2b6m)

# [](#introduction)简介

当我被介绍到 [GazePlay](https://github.com/schwabdidier/GazePlay) 项目时，我抓住机会试图解决其中的一些问题，并努力为一个开源项目做贡献，这个项目确实做了一些好事。

**一个问题；我无法建造它**

这个项目有一个 Maven 构建系统，一切都依赖于它。从构建和测试，一直到发布，所有的东西都是用巨大的 XML 文件编写的，这(依我拙见)使得阅读和理解变得困难。对于在全局类路径上拥有 JavaFX 库的项目开发人员有很大的依赖性。不仅如此，该项目是在 Java 8 上构建的，使用的是 JavaFX 的过时版本(即包含在 Oracle Java 8 的旧补丁中的版本)。

这不是一个可持续的开发环境，所以我认为我的第一个贡献是利用 Gradle 的能力来简化构建，以及 OpenJDK 11 和 OpenJFX 11 的新特性和支持。其目的是允许任何开发人员克隆该项目，并在很少或没有设置的情况下运行它。这篇文章是我如何做到这一点的指南，但绝不是迁移的权威指南。

# [](#build-test-and-dependencies)构建、测试和依赖

这项任务的第一步是让格雷尔去做大部分艰苦的工作。通过在带有 Maven 项目的目录中运行命令`gradle init`，您可以让 Gradle 为根项目和内部项目中的等效`pom.xml`文件创建包装脚本、属性文件和一个`build.gradle`文件。

这是我的新根文件`build.gradle`:

```
/*
 * This file was generated by the Gradle 'init' task.
 */

allprojects {
    group = 'com.github.schwabdidier'
    version = '1.6.2-SNAPSHOT'
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'

    repositories {
        mavenLocal()
        maven {
            url = 'http://jcenter.bintray.com'
        }

        maven {
            url = 'https://jitpack.io'
        }

        maven {
            url = 'http://repo.maven.apache.org/maven2'
        }

        maven {
            url = 'https://raw.github.com/agomezmoron/screen-recorder/mvn-repo'
        }
    }

    dependencies {
        compileOnly 'com.google.code.findbugs:findbugs:3.0.1'
    }

    sourceCompatibility = '1.8'

    publishing {
        publications {
            maven(MavenPublication) {
                from(components.java)
            }
        }
    }

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }
} 
```

这里有一个子项目`build.gradle`文件:

```
/*
 * This file was generated by the Gradle 'init' task.
 */

dependencies {
    compile 'com.github.agomezmoron:screen-recorder:0.0.3'
    compile project(':gazeplay-commons')
    compile project(':gazeplay-data')
    ...
} 
```

然而，这并没有迁移 Maven 插件。特别是，为了让构建工作起来，我必须在根目录`build.gradle`中添加 javafx 和 lombok 注释处理插件。许可证报告也是必需的，所以我也包括了这个。

```
plugins {
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.0.8'
    id 'io.freefair.lombok' version '4.0.1'
    id 'com.github.hierynomus.license-report' version '0.15.0'
} 
```

构建工作的最后一步是递归地将插件添加到每个子项目中，并根据需要配置它们。

很方便，Gradle 初始化已经给我提供了`subproject`块，我只需要把这个配置添加到它里面；

```
subprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'org.openjfx.javafxplugin'
    apply plugin: 'io.freefair.lombok'
    apply plugin: 'com.github.hierynomus.license-report'

    javafx {
        version = "11.0.2"
        modules = [ 'javafx.controls', 'javafx.swing', 'javafx.media', 'javafx.web' ]
    }
   ...
} 
```

**注意:**在这个阶段，我已经将我的`JAVA_HOME`设置为指向我的 AdoptOpenJDK 11 的本地安装。因为这需要 OpenJFX 的模块化版本，所以我必须检查所有的项目导入，并确定要包含哪些模块。这在 Maven POM 中没有被模仿，因为它只需要导入 JavaFX 控件。

几个库升级，交换了废弃的 API 和一些文档之后，构建成功了，我可以打开我的 PR 了！ ***万岁！**T3】*

我可以通过运行`gradlew run`从命令行运行应用程序来测试 Gradle 的配置。游戏按预期运行，我可以进入下一阶段。

[![](img/efc2de048e03219bce9bbcf7b2bd533c.png)T2】](https://i.giphy.com/media/KEYEpIngcmXlHetDqz/giphy.gif)

# [](#release-the-hounds-jars)释放~~猎犬~~罐子

这项任务的主要目标之一是能够以可启动的`.jar`文件的形式将发布捆绑到应用程序的用户。幸运的是，当我从 [`distribution`插件](https://docs.gradle.org/current/userguide/distribution_plugin.html)运行`distZip`任务时，Gradle 识别出了我所有的依赖项，并将它们的 jar 添加到了`lib`文件夹中。启动 jar *不能做的是*找到任何依赖项！

为了解决这个问题，我必须调整 jar 清单配置来添加要启动的主类和所有运行时依赖项的类路径。

```
jar {
    manifest {
        attributes (
            "Main-Class": 'net.gazeplay.GazePlayLauncher',
            "Class-Path": configurations.runtime.collect { it.getName() }.join(' ')
        )
    }
} 
```

通过把所有的`runtime` `configurations`和`it`都连起来，我可以用一个空格把`getName`和`join`连在一起。

现在，启动创建的`gazeplay-project-1.6.2-SNAPSHOT.jar`将实际上把其他 jar 加载到类路径中，并允许游戏运行！

## [](#custom-packaging-task)自定义打包任务

因为打包应用程序发布需要几个步骤，所以我决定在一个新的`.gradle`文件中创建我自己的定制任务。

```
import org.apache.tools.ant.filters.ReplaceTokens

task packageApp(dependsOn: ['assembleDist', 'downloadLicenses', 'scriptsForRelease']) {
    tasks.findByName('assembleDist').mustRunAfter('downloadLicenses')
    tasks.findByName('assembleDist').mustRunAfter('scriptsForRelease')
}

task scriptsForRelease(type: Copy) {
    from "${rootDir}/gazeplay-dist/src/main/bin"
    into "${rootDir}/build/scripts"
    filter(
        ReplaceTokens, tokens: [VERSION: project.version, NAME: project.name]
    )

    outputs.upToDateWhen { false } // Forces the task to rerun every time, without requiring a clean.
} 
```

`packageApp`任务下载依赖项的所有许可证，执行`scriptsForRelease`任务用环境变量替换项目版本和名称，然后将它们打包到一个 Zip 和 Tar 档案中。

## [](#gradle-release-plugin)Gradle 发布插件

默认情况下，Gradle 不包含项目到目前为止一直在使用的`maven-release-plugin`的直接等价物。release 插件旨在确保所有文件都被提交并推送到 master，然后用项目中的版本号标记提交。最后，它增加这个版本并再次提交所有内容，为进一步的开发做好准备。

对于这个项目，我选择了插件最流行的 Gradle 迭代；[研究之门发布](https://github.com/researchgate/gradle-release)插件。设置插件所需要的就是指定在发布运行之前执行`packageApp`任务；`beforeReleaseBuild.dependsOn packageApp`。

# [](#creating-a-custom-jre)创建自定义 JRE

JDK 9 的主要特点是引入了模块化的 JDK 和 JRE。这当然在 Open JDK 11 中很普遍，并且是创建一个随应用程序一起发布的自定义 JRE 的关键。为此，我选择使用 [Badass 运行时插件](https://badass-runtime-plugin.beryx.org/releases/latest/)，它将`jlink`命令与 Gradle 任务包装在一起。通过定义应用程序运行所需的确切模块，可以生成一个 JRE 作为构建任务，并包含`jre`任务。

下面是创建的 JRE 中包含的模块片段:

```
ext.jreModules=['java.base',\
  'java.compiler',\
  'java.datatransfer',\
  'java.desktop',\
  'java.instrument',\
  'java.logging',\
  'java.management',\
  'java.management.rmi',\
  'java.naming',\
... 
```

剩下要做的就是配置运行时插件，如下所示:

```
runtime {
    options = ['--compress', '2', '--no-header-files', '--no-man-pages']
    modules = jreModules
    jreDir = file("gazeplay-dist/src/jre")
} 
```

指定了`jlink`命令选项以保持文件夹尽可能小，并且为了与现有项目保持一致，目录被设置为与 JRE 1.8 所在的位置相匹配。

# [](#conclusion)结论

这可能不是最吸引人的项目，但我学到了很多关于 Gradle、自定义任务和第三方插件的知识。此外，我不是定制 JREs 或 Java 9+模块化方面的专家，但是这个项目给了我开始研究和学习更多相关知识所需的动力。最后，我希望这篇文章能帮助一些人解决他们遇到的小问题，或者对于正在经历同样过程的人来说是一篇有趣的文章。

关于我在这里讨论的每件事的更多细节，请随意查看带有所有代码的 PR 。