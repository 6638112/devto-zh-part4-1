# 准备编码面试的终极策略

> 原文:[https://dev . to/ar slan _ ah/the-ultimate-strategy-to-preparing-for-the-coding-interview-3 ace](https://dev.to/arslan_ah/the-ultimate-strategy-to-preparing-for-the-coding-interview-3ace)

### [](#how-to-prepare-more-quickly-for-coding-interviews)如何更快地准备编码面试

编码面试一天比一天难。几年前，复习关键的数据结构，练习 50-75 个编码面试问题，对面试来说已经足够了。今天，每个人都可以接触到大量的编码问题，它们也变得更加困难。整个面试过程变得更加竞争激烈。在这篇文章中，我想分享一个准备编码面试的策略。我的软件工程生涯持续了大约 15 年，其间我换了五次工作。我已经给出了大约 30 个采访循环，包含了 120 多个采访。我也有一些坐在桌子另一边的经验。我参加过 200 多次编码面试和 100 多次系统设计面试。

我认为自己是一个相当聪明的工程师，但我在白板上解决编码问题时遇到了挑战，尤其是在有人评估我的面试环境中。为了解决这个问题，我会花合理的时间来准备和练习。我没有意识到的一件事是，在做准备的时候，我是在遵循一种系统的方法。我会回答 12-15 个问题，每天练习两个小时。这意味着我可以在一个月内解决 350 多个问题。使用这个程序，我能够破解我对 FAANGs(脸书、苹果、亚马逊、网飞、谷歌)的采访。

我是如何用一份全职工作每天练习 12 个以上的编码问题的？我不是在解决编码问题，而是在练习将问题映射到我已经解决的问题上。我过去常常阅读一个问题，然后花几分钟把它映射到我以前见过的一个类似的问题上。如果我可以映射它，我将只关注这个问题相对于父问题的不同约束。如果这是一个新问题，那么我会试着去解决它，并且阅读其他人用来设计算法的聪明方法。随着时间的推移，我开发了一套问题模式，帮助我快速地将一个问题映射到一个已知的问题。以下是这些模式的一些示例:

1.  如果给定的输入是有序的(数组、列表或矩阵)，那么我们将使用一种变型的**二分搜索法**或**双指针**策略。
2.  如果我们正在处理`n`元素中的顶部/最大/最小/最近的`k`元素，我们将使用一个**堆**。
3.  如果我们需要尝试输入的所有组合(或排列)，我们可以使用递归**回溯**或迭代**广度优先搜索**。

遵循这种基于模式的方法帮我节省了很多准备时间。一旦你熟悉了一个模式，你就能够用它解决许多问题。此外，这个策略让我有信心解决未知的问题，因为我一直在练习将未知的问题映射到已知的问题。

在剩下的文章中，我将分享我收集到的所有模式，并给出一些示例问题。关于这些问题以及相关问题解决方案的详细讨论，请看[探索编码面试](https://designgurus.org/course/grokking-the-coding-interview)。

* * *

[![Pattern 1](../Images/98e0602f563dd6d5c1355599b37f3fbc.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--G2q8Kjw7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/zaawqdbj8t4km3sxlzau.png)

## [](#sample-problem-for-binary-search)为二分搜索法出样题

### [](#bitonic-array-maximum)[双音数组最大值](https://www.designgurus.org/path-player?courseid=grokking-the-coding-interview&unit=grokking-the-coding-interview_1628744182053_83Unit)

**问题陈述**
在给定的二进制数组中求最大值。如果一个数组先单调递增，然后单调递减，则该数组被认为是双单调的。单调增加或减少意味着对于数组中的任何索引`i`，`arr[i] != arr[i+1]`。

`Example: Input: [1, 3, 8, 12, 4, 2], Output: 12`

**解**
双调数组是一个有序数组；唯一不同的是，它的第一部分按升序排序，第二部分按降序排序。我们可以用二分搜索法的变体来解决这个问题。请记住，在二分搜索法，我们有`start`、`end`和`middle`索引，在每一步中，我们通过移动起点或终点来缩小搜索空间。由于没有两个连续的数字是相同的(因为数组是单调递增或递减的)，每当我们计算二分搜索法的`middle`指数时，我们可以比较指数`middle`和`middle+1`指出的数字，以确定我们是处于上升部分还是下降部分。所以:

1.  如果`arr[middle] > arr[middle + 1]`，我们在二进制数组的第二部分(降序)。因此，我们需要的数字可以由 middle 指出，也可以在`middle`之前。这意味着我们将做`end = middle`。
2.  如果`arr[middle] <= arr[middle + 1]`，我们在双光子数组的第一个(升序)部分。因此，所需数量将在`middle`之后。这意味着我们做`start = middle + 1`。

我们可以在`start == end`的时候休息。由于以上两点，`start`和`end`都会指向双光子数组的最大数量。

**代码**
下面是解决这个问题的 Java 代码: