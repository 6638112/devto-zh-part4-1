# AWS SQS -重复数据删除消息

> 原文：<https://dev.to/napicella/deduplicating-messages-exactly-once-processing-4o2>

在本文中，我将介绍几种消除邮件重复的方法。虽然文章引用了 [SQS](https://aws.amazon.com/sqs/) 作为参考，但是该模式可以应用于任何提供至少一次递送的服务。

在处理 SQS 和无服务器架构时，重复的消息是一个常见的挑战，但好的一面是我们可以重用已经建立的模式。
我将要谈论的是:

*   SQS 基础知识(快速介绍)
*   重复数据消除解决方案中的常见陷阱
*   去除图案

如果您只对模式感兴趣，可以直接跳到文章末尾。

### SQS 基础知识

SQS 是一种队列服务，支持服务之间的异步通信。它允许:

*   **解耦服务**。服务使用队列作为通道进行通信。即服务 A 向 SQS 队列发送消息，服务 B 轮询队列以寻找新消息；两个服务都不需要知道对方。
*   **弹性**。队列可以作为未完成请求的缓冲区。服务 A 将消息发送到 SQS 队列，服务 B 暂时关闭(或缓慢)。没有任何消息会丢失，因为队列实际上是一个缓冲区。
*   **缩放**。可以监控队列大小，以触发警报或自动伸缩事件。服务 A 遇到流量高峰，导致许多消息(比平时多)被发送到队列。服务 B 可以定义一个警报，根据队列中未处理的消息数量自动调整。

#### 消息重复

从 AWS 文档:

标准队列保证至少一次传递，跨多个服务器存储消息以保持高可用性。

在极少数情况下，当我们的信息被消费或删除时，这些服务器之一可能不可用。随后，当再次可用时，服务器可以向服务重新发送消息。

doc 告诉我们一条消息可以被多次使用(尽管这种情况很少见)，但是它没有提到消息在被推入队列时也可能被复制。
即服务将消息推入队列，多次发送相同的消息。避免这种可能性是相当棘手的，我认为这比复制的其他来源更有可能。

不幸的是，SQS 只提供工具，通过所谓的 SQS 消息重复数据删除 id，用新的 [SQS FIFO](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) 来避免这个问题。

### 重复数据删除解决方案中的常见缺陷

##### ...关于绝对时间的使用

重复数据删除消息的一个常见解决方案是在 DynamoDB 表中跟踪它们，确定哪些正在进行，哪些已经完成。

当消费者收到一条消息时，需要检查该消息是否存在于表中。

如果它不存在，就处理它。如果确实存在，它需要确定消息是重复的，还是由于之前的消费者未能处理它而导致的重试。

一种方法是跟踪在 DynamoDB 中创建/更新项目的时刻:
如果当前系统时间和项目的更新时间戳之间的差异超过了操作超时，则消息是重试。不幸的是，这个解决方案有一个严重的缺陷:使用绝对时钟时间。
如果不同的机器对时间不一致，它们将会多次处理这条信息。
让我们考虑一下这个例子，Lambdas 是 SQS 的消费者:

*   λ超时为 5 分钟
*   Lambda 1 获取消息，并将其与当前时间戳一起添加到 dynamo 中。
*   大约在同一时间，λ2 接收到相同的消息。它通过在 DynamoDB 中查找项目来检测。
*   消息的状态是 **IN_PROGRESS** ，所以 Lambda 2 检查它的系统时间和项目更新时间之间的差值是否大于 lambda timeout。
*   因为 Lambda 2 受到 5 分钟时钟螺丝的影响，所以它会错误地认为该消息是重试。
*   Lambda 2 将再次处理消息(与 Lambda 1 同时)

通过调整阈值，可以部分缓解该问题，在该阈值之后，假定重新摄取重复消息是安全的。这个阈值必须考虑到我们可以预期的最大时钟螺丝是什么(至少有很高的概率)。

##### ...关于分类帐一致性

依赖外部分类帐来跟踪消息的解决方案需要采用他们将要使用的分类帐的一致性模型。

例如，当使用 DynamoDB 作为总账时，需要使用:

*   一致的读写
*   处理多个消费者之间竞争条件的条件表达式

这被证明是相当棘手的事(和测试！).

##### ...关于重新发明轮子

大多数解决方案都以编写有效构建以下两者的代码而告终:

*   建立在分类帐之上的分布式锁
*   由分类帐支持的简单状态机

这些都是很常见的问题，难道没有现成的解决方法吗？

### 去重复模式

##### 等幂

让消息的消费者幂等。只有当消费者不是等幂的时候，消息复制才是一个问题。
如果消费者执行的活动本质上是非等幂的，则将非等幂的步骤与等幂的步骤分开。

##### 步进功能

对于活动的非等幂部分，使用[步骤函数](https://dev.tolink%20here)来创建一个完全可管理和可伸缩的状态机。
步骤函数的执行是幂等的，如果 StartExecution 调用的名称和输入与正在运行的执行相同，调用将成功并返回与原始请求相同的响应。
如果执行被关闭或输入不同，将返回 400 ExecutionAlreadyExists 错误。

##### 迪纳摩 DB 锁

如果阶跃函数不适合您(成本？)使用 [DynamoDB 锁库](https://github.com/awslabs/dynamodb-lock-client)来锁定处理消息。

这个库是久经考验的，在 DyanmoDB 之上提供了一个锁抽象。
该库从不在 DynamoDB 中存储绝对时间，只在 DynamoDB 中存储相对的“租用期限”时间。
这意味着，即使两台不同的机器对时间不一致，它们仍会避免碰撞对方的锁。

### 结论

TL；努力让你的消费者幂等，如果不可避免，隔离非幂等的部分。
考虑使用阶跃函数来删除重复数据。如果不能，就用 DynamoDB 锁库。

##### 读数

*   如果你对这个话题感兴趣，有一篇有趣的文章是关于通过重复数据删除 id 进行消息重复数据删除的理论，就像 SQS FIFO 所采用的一样。这项技术被称为防护:[https://Martin . kleppmann . com/2016/02/08/how-to-do-distributed-locking . html](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)
*   DynamoDB 锁:[https://github.com/awslabs/dynamodb-lock-client](https://github.com/awslabs/dynamodb-lock-client)
*   步进功能:[https://aws.amazon.com/step-functions/](https://aws.amazon.com/step-functions/)

你可以在 [twitter](https://twitter.com/napicellatwit) 和 [github](https://github.com/napicella) 找到我。

玩得开心！