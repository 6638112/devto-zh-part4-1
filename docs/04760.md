# TDD 和 bug 修复——两者缺一不可

> 原文:[https://dev . to/brunooliveira/TDD-and-bug-fixing-the-duo-you-can-t-be-no-13p 9](https://dev.to/brunooliveira/tdd-and-bug-fixing-the-duo-you-can-t-be-without-13p9)

**简介**

使用干净的代码库并在编写代码时达到质量标准的好处是众所周知的:功能更快地交付，代码流更容易跟踪，客户和同行都更高兴和更有生产力。

我将从可维护性的角度来处理这个问题，并将它与 TDD(测试驱动设计)和 bug 修复如何与可维护性相关联以及如何相互关联联系起来。

软件可维护性——它是什么，为什么重要？

专业开发人员工作的大多数软件都已经编写好，需要*维护*和*扩展*，所以作为一名专业开发人员，你需要优化你的工作流程来读取代码，扩展和改进大型代码库。

可维护性是任何一个软件的内在特征，可以通过使用量化的度量从外部观察到，当作为一个整体来看时，它包含了软件系统的可维护性。它描述了软件团队如何容易理解支持代码的底层业务，以及他们如何容易添加新功能、纠正错误、应对不断变化的需求，甚至让新开发人员加入项目。

开发人员了解的一些外部特征包括，例如:

*   耦合:一个系统中两个或多个组件的紧密程度。如果在更改一个组件时，更改会波及到其他相关组件，这表明它们是紧密耦合的。系统的组件耦合得越紧密，就越难维护。

*   参数的数量:和前面的度量一样，参数的数量也会影响系统的可维护性。当系统的*单元接口*(参数数量)过长时，这是一个很好的迹象，表明你的系统有太多的知识。

*   功能大小:如果单个的代码单元太大，这可能意味着它们的范围太广或者它们做的太多，这会损害代码库的可维护性。保持您的单位小，并获得好处！

**TDD 以及与可维护代码的关系**

测试驱动开发是一种非常有用的技术，在这种技术中，你开发测试优先:*你在编写产品代码*之前编写测试。
这允许你只写最少的代码来确保最初失败的测试通过。就像这样，您确保您只编写解决特定问题所需的代码，并确保所有代码在您进行的过程中保持测试，这非常有价值，因为它允许您更快地前进，并且更有信心。

然而，这也很难做到，因为它迫使我们提前考虑每个类在整个系统中的责任，并确保您的方法尽可能小且孤立(意味着它们只做一件事)。

如果你做对了，你将有一个非常坚实的基础来为你的代码打下基础，在添加新功能和修复出现的错误方面**，同时通过在你做出改变后运行你的单元测试套件来确保整个系统保持稳定**。这在处理生产级代码库时是无价的，因为您希望确保系统在您的工作之后保持稳定。

**如何使用 TDD 修复 bugs】**

现在让我们探索如何应用 TDD 来解决一个 bug。

例如，让我们假设我们有一个简单的计算器应用程序，并且当我们第一次设计它时，根据要求，当我们实现加、减、乘、除的所有基本操作时，我们只处理`int`数据类型。

我们的 bug 告诉我们，一个客户系统报告说`3/4`返回了`0`。显然，我们使用的数据类型是不正确的，我们需要一个浮点数据类型。但是我们还不知道这个。我们知道的是`3/4=0.75`。这是我们的**预期行为**，所以我们应该为此编写一个测试(伪代码风格):

```
@test
void divisionReturnsDouble(){
    assertThat(calculator.divide(3,4), 0.75));
} 
```

所以在我们的单元测试中，我们看到测试名声明了被测试内容的意图，而测试体只是我们需要获得的结果的断言。

因此，我们立即发现我们使用的参数具有错误的数据类型。

我们看到`Calculator`类接收两个整数形式的参数，所以，我们将它们改为浮点数，运行**我们的新测试**，我们看到现在它通过了。我们完了！我们修复了漏洞。或者我们有吗？

**回归和清理代码**

令我们惊讶的是，在运行了整个测试套件之后，我们声明只有我们的新测试通过了！！其他人都失败了！为什么？经过仔细观察，我们发现所有整数算术运算的结果都返回小数部分，而不是之前的整数值。这实际上是正确的，因为我们将参数类型改为了 float。3 现在是 3.0，6 是 6.0 等等。我们说我们引入了一个**回归**。在我们更改之后，不相关的代码片段的正确和预期的行为发生了变化，因此我们假定的修复是有缺陷的。这是已经准备好运行测试套件的主要优势之一:*您可以确保您的更改不会在代码中引入意想不到的副作用*。

**更小的范围，意味着更小的问题**

所以我们知道，由于**修复分部**而引入的代码变更正在导致一个新的 bug。这里的关键是，我们现在确切地知道是什么导致了错误，因为我们确切地知道我们改变了什么。由于这一点，我们可以恢复它，重新运行测试，并确保一切都按预期工作。这是使用 TDD 修复 bug 和作为可维护性工具的主要优势:

你在小的、原子范围的功能中工作，知道什么时候会出问题。通过测试，你可以重新控制你的代码

修复这种特定回归的理想场景是确保我们在代码中所做的改变模拟了被测试单元的范围:它需要尽可能的小。对于我们的例子来说，这可能意味着只在 division 的专用方法中更改数据类型，而保持代码的其余部分不变。粒度很重要，TDD 向我们展示了单元级别的粒度，这正是我们想要的，也是一个好的、经过深思熟虑的代码库的标志。

**结论**

希望您已经了解了 TDD 的好处以及它对代码库可维护性的重要性。这是一个非常有用的方法，虽然很难通过 TDD 来维护代码库，但是巨大的好处值得克服最终的障碍。
总结一下:

*   TDD 为您提供了非常细粒度的、单一用途的作用域，允许您:重现 bug，开始开发新特性，自信而快速地重构代码。

*   强制执行隐含的标准点质量:新开发人员将更快地达到速度，并将提高他们的代码质量以匹配他们第一次看到的。

*   对你自己的改变、拉动、合并等的快速反馈。您可以控制运行它的时间和方式。

希望你喜欢这篇文章，如果你有建议和/或意见，请随时在评论中提出！