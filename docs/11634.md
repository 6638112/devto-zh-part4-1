# 用代码交流

> 原文:[https://dev.to/jennapederson/communicating-with-code-4gja](https://dev.to/jennapederson/communicating-with-code-4gja)

你是否曾经不得不跳入一个你从未见过的代码库，并立即开始工作？作为一名自由职业者/咨询师，这几乎是我的谋生之道，而且可能会非常痛苦。到了我现在自动及时构建并“审核”我最初的客户评估的地步。

有时候这很棒。或者至少大部分是不疼的。启动和运行相对简单。有写得很好的代码，也有一些不错的测试。

我们正在为其他人编写这些代码，我们需要记住，我们有这些更高级的编程语言，使我们和我们的同事更容易阅读、编写和维护。当我第一次进入代码库并在其中工作时，这里是我寻找的一些品质。

# [](#the-code)代码

你如何命名类、函数和变量，你如何构建你的代码，以及它的复杂性都在交流中扮演着重要的角色。然而，这些并不一定传达为什么或者给出关于它的任何背景。

### [](#naming)命名

你有没有看过这样的代码库？还是这是你？请不要这样做！

```
for i in list do
  process(i)
end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

一个类、函数或变量的名字应该告诉我们它到底是什么。如果你需要添加一个注释来进一步解释它，它很可能没有揭示它的意图(见[干净代码](https://read.amazon.com/kp/embed?asin=B001GSTOAM&preview=newtab&linkCode=kpe&ref_=cm_sw_r_kb_dp_h6hoDb9RAKJTX&tag=612softwarefo-20))。在上面的例子中，我不知道`list`是什么或者`i`是什么或者`process`实际上是做什么的！

当我们在命名上松懈时，很难弄清楚发生了什么。我们通常从上到下阅读，但当我们阅读和使用代码时，我们的大脑必须深入每一层，从类到函数到变量，以及不同的可能代码路径(几乎无限数量的代码路径)，然后在我们开始跳出堆栈回到我们试图理解的原始功能时保留所有这些。如果我们试图跟踪像`i`和`list`这样的变量和名为`process()`的函数，以及我们过于复杂、结构不良的代码在做什么，我们会让工作变得更加困难。

我们从意图揭示代码中获得的另一个很酷的好处是我们的 IDE 中更好的代码完成，这减少了我们必须理解函数做什么和参数需要是什么的跳跃。

### [](#structure-amp-complexity)结构&复杂

除了质量之外，代码的结构和复杂性也增加了理解它在做什么和应该做什么的难度。我们的类和函数应该小而简单，并且专注于一件事(参见[单一责任原则](https://en.wikipedia.org/wiki/Single_responsibility_principle))。您的类、文件和对象不需要有四个滚动页面那么长。如果你的应用程序有一个 app.js 文件，不要把所有东西都塞进去，祈祷好运。

### [](#dead-code)死代码

删除死代码是自由的！动手吧。当我遇到未使用的代码时会感到困惑，当它留在代码库中时会更加有害。它经常被置之不理(因为如果它在生产中甚至不可执行，你如何维护它？).将它留在代码库中是有开销的。我们有版本控制。如果你发现你需要复活它，你有工具做到这一点。

### [](#standards-and-conventions-and-consistency)标准、惯例和一致性

标准、惯例和一致性是关键。除了使设置、配置甚至使用对我们来说更容易之外，标准和惯例还为我们提供了如何做某事或它如何工作的线索。但是有时候你不能或不想遵循一个惯例或标准。你一直这样做并不意味着你也要一直这样做(请不要落入那个陷阱)。也许它不适合这个特殊的用例。也许你想尝试一种新的实现方式，因为这将节省你的团队时间。也许你想偏离，因为它会为你的使用提供巨大的性能改进。不管是什么原因，确保有一个原因，并有意偏离这个决定。当你偏离时，记录下这个决定背后的原因。

# [](#the-comments)评论

注释有多种形式——关于您正在做什么、为什么要做的注释，作为代码和文档生成器的元数据——但有时它们会被过度使用，或者以一种弊大于利的方式使用。

我个人的偏好是将写得好的代码(结构、复杂性和命名)与清晰、简洁的注释结合起来，为我无法与实际代码交流的“为什么”添加上下文。

注释的好处是增加了关于你为什么采取特定方法的背景。虽然注释不是机器的指令，但它们与代码共存，并一起受到版本控制和维护。当代码更新时，它们也需要更新。悬空的评论和陈旧的评论实际上比没有评论更有害。

### [](#examples)例子

#### [](#not-great)不伟大

这是要我一发现某 _gem 的 bug 或者想升级就咬我一口。

```
gem 'some_gem', git: 'https://github.com/some_gem/some_gem.git' 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

#### [](#still-not-great)仍然不爽

也好不到哪里去。它仍然会咬我，但至少对未来的我有一个线索，我会有一些额外的工作要做。也许我甚至可以提前将这段时间纳入我的客户评估中。

```
# gem not maintained
gem 'some_gem', git: 'https://github.com/some_gem/some_gem.git' 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

#### [](#even-better)更好

现在，这更有帮助了。当我不得不解决这个问题时，我有一个看什么的想法，并且有一个小背景，为什么我们从 github 而不是 rubygems.org 拉。

```
# gem not maintained; try some_gem/some_better_gem for updates or migrate to best_gem
gem 'some_gem', git: 'https://github.com/some_gem/some_gem.git' 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#the-tests)测试

曾几何时，我痴迷于测试驱动的开发和自动化测试，并达到 100%的测试覆盖率。以至于我的名片上写着“软件工程师、技术领导和自动化测试狂热者”。从那以后，我从一直测试所有东西的非常教条的观点转向了更实用的测试方法。一个我在需要的时候测试什么的地方。我写测试来理解代码。我编写测试来创建更好的代码。我编写测试来传达意图。我编写测试来防止将来在代码中特别困难或关键的地方出现倒退。

与软件中的所有事情一样，测试什么以及何时测试取决于您自己的情况(这一点我将留到另一篇博文中讨论)。然而，当我接手一个新项目时，我首先要做的事情之一就是测试。我不仅用它来评估代码库的健康状况，还用它来学习更多关于业务以及代码如何满足那些业务规则的知识。如果我进入一个新项目，进行一系列测试，比如:

```
require 'test_helper'

class MyDomainModelTest < ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

当我需要改变`MyDomainModel`中的底层代码时会发生什么？我没有过去决策的背景，可能还没有完全理解业务，所以我对自己的改变没有信心。

但是如果我进入一个项目，对困难的部分、关键的部分或者不经常改变的部分进行一些测试，我可以学到一些关于这个代码库的东西，这些东西在我开始改变它的时候会很有帮助。

我可以了解一些更复杂的逻辑在哪里。我可以了解关键业务逻辑是在哪里处理的。我甚至可以了解到代码库中频繁更改或不频繁更改的部分。利用这些信息，我可以决定如何进行下一轮变革。我会写一些新的测试来学习代码吗？以确保我没有打破现有的逻辑？还是有足够多的测试可以直接投入进去？

不过，测试并不是传达代码中发生了什么的灵丹妙药。它们需要像注释和其他文档一样进行维护。它们需要是正确的，如果开发人员没有完全理解问题，那么测试不会帮助你。

# [](#the-readme)自述

自述文件是您的代码报告的一部分。这是对这个特定代码库的介绍，可能是新开发人员看到的第一样东西。让它有用。当我看到默认的 Rails 自述文件时，我畏缩了。这没有帮助。

```
# README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ... 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

你构建了一个“标准的 Rails 应用程序”,这很好，但是如果有一些定制的东西，开始(即使对于已经做了多年的人来说)可能会很痛苦。面对现实吧。你已经构建了定制软件，所以会有一些定制的东西。我从来没有发现一个 Rails 项目没有偏离“标准”设置，即使以前的开发人员告诉我它没有任何特别之处。

我们必须记住，人们对技术以及他们如何构建和部署技术有自己的看法。还记得整个[制表符 vs 空格的争论](https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/)吗？我们还没解决这个问题呢！当与缺乏经验的人一起工作时，他们可能不知道每一个标准或惯例(或者可能他们没有为团队记录)。所以仅仅因为它是一个标准或惯例并不意味着它被遵循。

那么部署呢？是手动部署还是自动部署？什么时候？在合并到母版时还是在测试成功运行时？当你按下一个按钮。你设置好 Heroku 管道了吗？或者您可能将一些部署到 AWS，一些部署到数字海洋。如果其中一些是针对 Firebase 数据存储运行的，会怎么样？这些都是运行你的应用程序并在代码库中工作的全栈开发人员可能需要知道的细节，以便进行真正的工作。由于截止日期的原因，忽略这些细节可能会感觉更快，但是当你习惯写下这些细节时，实际上会变得更容易和更快，并且长期的好处会得到回报。为了你和你的客户。

这些只是我在现有代码库中接手一个项目或者从零开始时寻找的一些东西。这有助于我理解这个系统，当我不能参与最初的决策并自己构建它的时候。当我每隔几个小时或几天就在不同的项目、客户和技术栈之间切换时，这是对我有帮助的。我们有很多东西需要加快速度(并记住)——从技术堆栈、语言和语法到如何连接在一起，如何与其他系统集成，为什么要做出某些技术决策来理解业务领域和系统的实际功能。在决定评论与否、记录与否、偏离与否、如何命名和构建代码、测试什么以及为什么测试时，要始终如一并有意识地做出这些决定，并在您的环境、团队和产品的上下文中做出这些决定。

* * *

*最初发布于[https://www.jennapederson.com](https://www.jennapederson.com/blog/2019/7/24/communicating-with-code)2019 年 7 月 24 日。*