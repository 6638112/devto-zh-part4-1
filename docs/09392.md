# 模块化编程的下一步

> 原文:[https://dev . to/gite den/the-next-step-in-modular-programming-395 f](https://dev.to/giteden/the-next-step-in-modular-programming-395f)

模块化很重要，这是毫无疑问的。模块化代码允许关注点的分离、代码的可重用性、更容易的维护、更容易的协作、更容易的测试和调试，这样的例子不胜枚举。

前端组件、微服务、函数编程、微前端等。这些都是这一重要概念的体现。它们的存在是因为模块化的思想得到了社区的认可和接受。

另一方面，我们到处都能看到整体代码的症状。修改代码是一件可怕的事情——你改变一件事情，整个事情就崩溃了(还记得“Stackers”吗？).在开发团队中吸收新成员是一件困难的事情。在单独的代码片段上协作(孤立地)是极其困难的。我们花了太多时间从零开始构建东西，或者打包代码以供重用。

那么，到底发生了什么？

我们当前的版本控制系统根本不适合真正的模块化代码。我们可以尽可能模块化地编写我们的代码，但是它们都在同一个单一的存储库中(而不是那么模块化)。为了使我们的代码真正模块化，我们可能会选择转向多个存储库，但是我们知道如果我们这样选择，等待我们的将是一场噩梦。

有几种尝试来解决单片库的问题( [Lerna](https://lerna.js.org/) ， [git 子模块](https://git-scm.com/book/en/v2/Git-Tools-Submodules)等)。)但是，依我看，它们离在多个项目中构建、协作和消费多个组件或模块的简单、直观和无缝的工作流程还很远(这些项目中的每一个都可能有自己的单一存储库，但它应该只代表真正独立的模块的特定组合)。

还有其他新的平台和工具旨在解决这个问题( [Bit.dev](https://bit.dev/) 等)。)-时间会证明他们是否能给出一个更完整的解决方案。