# 你我和 package.json

> 原文:[https://dev.to/xabadu/you-me-and-package-json-1dc2](https://dev.to/xabadu/you-me-and-package-json-1dc2)

*？你可以在这里找到这篇文章的译本:[你，我，还有 package.json](https://medium.com/noders/t%C3%BA-yo-y-package-json-9553929fb2e3)*

如果您曾经在 Node.js 或客户端 JavaScript 项目中工作过，那么您很有可能见过一个名为 **package.json** 的文件，并且您已经研究过它的内容。即使里面有很多你可能非常熟悉的东西，你也可能碰到一些不完全确定它是什么意思的东西，甚至不知道它最初是如何出现在那里的。

在本文中，我们将详细介绍这个文件中的每一个东西的含义，可以放入什么样的内容，以及它如何帮助您在开发项目时变得更加高效。

但首先要做的是:

## [](#what-is-the-packagejson-file)什么是 package.json 文件？

从历史上看，Node 一直使用名为 **npm** 的工具来管理包和依赖项。该工具通常安装在 Node 上，有两个主要任务:

*   将您的项目发布到 npm 的公共注册表*(以便其他用户可以将其作为他们项目的依赖项下载)*。
*   管理您自己项目的依赖关系。

为了能够做到这一点，npm 客户端创建并使用一个名为 **package.json** 的文件。该文件包含有关项目的信息，例如:

*   姓名。
*   版本。
*   依赖性。
*   知识库。
*   作者。
*   执照。

还有更多。

此外，除了保留记录，通过使用该文件，可以为获得副本的每个人保证项目的完整性。这意味着任何用户，在任何时间点，都将能够访问同一组**相似的兼容依赖关系**。在某种程度上，我们可以将 **package.json** 文件视为我们项目的宣言。这里需要记住的一点是，虽然 package.json 文件中列出的依赖项应该与原始依赖项相似并兼容，但如果自原始声明以来已经过了相当长的时间，则不能保证项目能够运行而不出现任何问题(可能是在不同版本的包中引入了更改，该包也被认为是兼容的，但可能会破坏某些功能)。为此，建议使用 [**锁定文件**](https://docs.npmjs.com/files/package-lock.json) 。

让我们通过考虑以下场景来看一个例子:

两个开发人员在做同一个项目，在他们自己的电脑里有独立的副本。Dev #1 决定为了完成新特性，他需要在项目中使用一个新的库。

如果没有任何依赖管理，他将需要做两件事情中的一件:

*   手动将库下载到项目的目录中，并在其中保留一个副本，该副本必须包含在项目存储的任何位置，这可能会增加新开发人员在获得副本时需要传输的数据量。
*   下载库的副本，但不保留副本，而是让每个参与项目*(现在和将来)*的人知道他们需要得到一份副本，并确保他们使用的是完全相同的版本。*(结交新朋友的好方法，但在时间管理方面不太好)*。

有了依赖管理工具，比如 npm，这两个步骤都不再需要了。任何获得项目副本的人，现在和永远*(只要包没有被发布)*，将能够安装每一个依赖项，而不需要转移它们的实际副本。因此，存储在存储库中并共享的实际项目要轻得多，冗余数据也不会被传输。

值得一提的是，尽管 package.json 文件中包含的许多信息似乎是特定于在 npm 注册表中发布项目的，但我们仍然可以使用 npm 来管理永远不会在那里发布的其他类型的项目，如 Web 和/或移动应用程序、游戏等。

关于依赖管理的最后一点，不久前，我在脸书的好朋友们(注意:他们并不知道我们是朋友...然而:()推出了一个类似的工具，名为 **yarn** ，对于本文的所有意图和目的来说，它能够完成我们上面提到的相同的两个任务，并且它对 package.json 文件的使用是相同的，除非明确声明。

## [](#how-to-create-a-packagejson-file)如何创建 package.json 文件

### [](#one-rule-to-ring-them-all-)一个规则，把他们都圈(？)

在创建 package.json 文件之前，需要知道一条规则:文件必须是有效的 json 格式，并且必须遵守 [JSON 样式规范。](https://google.github.io/styleguide/jsoncstyleguide.xml)

记住这一点，有两种不同的方法来创建文件:手动或使用 npm/yarn cli:

### [](#creating-the-packagejson-manually)手工创建 package.json

如果由于任何原因，使用 npm/yarn cli 的选项不可用，并且我们确实需要手动创建一个文件，我们将需要添加一个新文件*(名为 **package.json** )* 到项目的根目录，包含以下字段:

*   `name`。
*   `version`。

每隔一个字段*(在下一节中列出)*是可选的，尽管是推荐的。

### [](#creating-a-packagejson-using-the-npmyarn-cli)使用 npm/yarn cli 创建 package.json

这是推荐的做法。创建 package.json 文件可以通过在项目的根目录下运行以下命令来完成(取决于您使用的包管理器):

```
npm init 
```

或者

```
yarn init 
```

根据使用的是 npm 还是 yarn，在创建文件之前必须提供某些信息:

<figure>

[![Creating a package.json using npm](../Images/fb0248fa90db37df399f1e5da68ce45f.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--tSqBce8H--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/jf7jkvdg6ea81kwq1l3j.png)

<figcaption>Creating a package.json using npm</figcaption>

</figure>

<figure>

[![Creating a package.json using yarn](../Images/72dac56ca20a204e123f1f4b24aa7236.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--CWt4LWby--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/ipoopvrwgk1hibx68wr9.png)

<figcaption>Creating a package.json using yarn</figcaption>

</figure>

一旦完成，一个全新的 **package.json** 文件将在项目的根目录下创建。

**快速提示**:如果需要快速创建带有默认值的 package.json 文件，可以运行:

```
npm init -y 
```

或者

```
yarn init -y 
```

## package . JSON 文件的各个部分

在创建 package.json 文件之后，无论是手动还是使用 cli，我们都会在一个大对象中找到不同的键和值*(就像本文的初始图片)*。此外，还包括久而久之和新的依赖项/配置，此处还将包括新的键和值。以下是我们可能在某个时间点遇到的最常见问题的列表:

**注** :本清单仅包括 npm 正式申报并支持的财产。有多个外部库也支持从 package.json 文件*(即 Jest 和属性“jest”)*

### [](#name)名称

这是需要包含在文件*(以及版本)*中的两个必填字段之一。它是一个字符串，表示当前项目的名称，如果项目在注册表中发布，它还可以作为唯一的标识符。

#### [](#rules)规则:

*   该名称必须小写，并且不能以句点或下划线开头。
*   名称的最大长度为 214 个字符，并且必须是 URL 安全的*(关于 URL 安全字符的更多信息可以在[这里找到](https://www.ietf.org/rfc/rfc3986.txt)，第 2.3 节)*。

其他一些需要记住的事情:

*   如果项目将在 npm 注册表中发布，名称必须是唯一且可用的*(在使用相同名称之前没有发布其他项目)*。
*   尽管如果包属于某种技术*，使用相关的名称被认为是一个好的做法(就像使用 **react-{something}** 用于 react 库)*，但是也建议不要在名称中使用**节点**或 **js** 。

### [](#version)版本

另一个必填字段，以及名称。它是一个字符串，表示项目的当前版本。Node.js 和 JavaScript 项目通常遵循语义版本化*(或 semver)* 中定义的约定，为版本定义了以下结构:

```
MAJOR.MINOR.PATCH 
```

更多关于 semver 的信息。

### [](#description)描述

一个字符串，包含对项目内容的简短说明。如果软件包曾经发布过，这个文本也将与搜索结果相关。

### [](#keywords)关键词

与 description 相同，但它不是文本，而是一个字符串数组，其中包含可用于搜索包的相关术语。

### [](#homepage)首页

包含项目网站的有效 URL 的字符串。

### [](#bugs)虫子

具有有效 URL 的字符串，用户可以在该字符串中报告在项目中发现的问题。通常， **issues** 存储库 URL 用于此目的。

### [](#license)执照

一个字符串，它指定发布此项目的许可证类型。这可以是个人的、商业的、开放的或私有的。

关于可用许可证的更多信息。

### [](#author)作者

它可以是一个字符串，也可以是一个包含项目创建者信息的对象。

如果是一个对象，必须采用以下格式:

*   姓名。
*   电子邮件。
*   网址。

如果是字符串:

```
"Name <email> (URL)" 
```

### [](#contributors)贡献者

与 author 类似，它是一个对象数组*(或字符串数组)*，包含项目参与者的信息。

### [](#files)文件

字符串或模式的数组*(如*。js)* 包含在项目中的文件，如果它曾经在注册表中发布的话。如果这个部分没有被定义，每一个文件*(即没有被明确排除在一个文件之类的。gitignore)* 会被收录。

#### [](#some-things-to-keep-in-mind-about-this)关于这一点要记住的一些事情:

*   默认情况下，**中列出的每个文件。gitignore** 将被排除在发布之外。
*   不是添加一个*文件*段，而是一个**。npmignore** 文件可以包含在项目的根中，并带有一个从发布中排除的文件列表*(类似于什么。【gitignore does)。*
*   一些文件**将总是包含在**中，不管是否明确排除。这些文件包括:package.json、README、CHANGES / CHANGELOG / HISTORY、LICENSE/LICENSE、NOTICE 和定义为应用程序入口点的文件*(下一节将详细介绍)*
*   一些文件**将总是被忽略**，不管是否明确包含。这些文件的清单可以在[这里](https://docs.npmjs.com/files/package.json#files)找到。

### [](#main)主

定义项目入口点的字符串。如果项目是一个包/库，这就是当有人需要它时将被导入的文件。例如:

如果你的项目叫做**超级棒的库**，用户安装了它，然后在他们的应用程序中安装:

```
const superAwesomeLibrary = require("super-awesome-library"); 
```

变量**superawesomeblibrary**将包含您的主文件正在导出的内容，所以如果您的 package.json 文件有一个声明，比如:

```
{  "main":  "lib/foo.js"  } 
```

然后`superAwesomeLibrary`变量将包含在`lib/foo.js`中导出的内容。

如果省略这一部分，那么将使用项目根目录中的`index.js`文件的内容。

### [](#bin)斌

一个字符串*(如果只有一个)*或一个对象*(如果有多个)*定义将要安装的脚本，这些脚本可以作为路径中的命令使用。软件包安装完成后，将会创建一个从 **/usr/local/bin** 到项目中相应文件的符号链接，并且可以作为命令行程序使用。

例如，假设我们的项目中有一个名为 *cli.js* 的文件，我们希望用户可以从他们的终端直接调用它。实现它的方法是在 package.json 中包含一个字符串作为 **bin** ，如下所示:

```
{  "name":  "super-awesome-library",  "bin":  "cli.js"  } 
```

现在 *cli.js* 的内容可以通过运行我们在终端
中放置的项目**名称**来使用

```
super-awesome-library 
```

当用户运行这个友好的名字时，实际上，类似这样的事情正在发生*【幕后】* :

```
node cli.js 
```

然后该文件上的任何内容都将运行。

如果不是这样，我们有多个文件想要转换成可执行脚本，我们可以使用对象格式。这将为每个*键-值*对添加一个符号链接，使用**键**作为以后可用的命令:

```
{  "bin":  {  "script-1":  "super-h4x0r-script1.js",  "script-2":  "on-your-left.js"  }  } 
```

有了那个对象，**“脚本-1”**和**“脚本-2”**都将包含在路径中，各自指向各自的。js 文件，这是它们在 bin 对象中的配对。

这是许多已知的包，如 *nodemon* 或 *react-native* 所包含的，因此我们可以直接将它们用作终端命令，而不必运行*node——无论文件路径是什么——是*。

### [](#man)男人

一个字符串或字符串数组，定义一个*(或多个)*文件，如果为该项目运行 **man** 命令，该文件将可用/显示。

### [](#directories)目录

一个对象，它定义项目的结构以及特定部分的每个文件夹的位置。最常见的有*斌*、 *doc* 、*例*、*库*、*人*、*考*。

```
{  "bin":  "./bin",  "doc":  "./doc",  "lib":  "./lib"  } 
```

### [](#repository)储存库

一个对象，定义此项目的存储位置，可以找到它进行贡献。该对象具有以下格式:

```
{  "type":  string,  "url":  string  } 
```

其中**类型**是指存储库的类型*(如 svn 或 git)* ， **URL** 是可以找到它的有效 URL。

示例:

```
{  "type":  "git",  "url":  "https://github.com/my-user/super-awesome-project"  } 
```

### [](#scripts)脚本

定义命令的对象，这些命令可与项目的 npm/yarn cli 一起使用。有些脚本是预定义和保留的，无需定义即可使用，例如**启动、安装、预安装、预测试、测试和后测试**等等。*(完整名单见[此处](https://docs.npmjs.com/misc/scripts) )* 。

同样，我们可以定义自己的脚本，并为它们使用自定义名称和指令。这对于创建快捷方式和/或组合任务非常有用，无需每次都记住完整的命令和/或参数。

例如，假设我们有一个应用程序需要在创建新版本之前运行一个任务来缩小 JS 文件，我们使用一个位于 **tasks/minify.js** 中的脚本来完成这个任务，并传递一个内部使用的标志或参数。通常，每当我们想要实现这个*(我们还需要记住标志的名字)*，我们就会运行**节点 tasks/minify . js-some flag-maybe another**。然而，如果我们改为将它添加到 npm 脚本中，我们可以这样做:

```
"scripts":  {  "minify":  "node tasks/minify.js --someflag --maybeanother"  } 
```

然后运行:

```
npm run minify 
```

这实现了完全相同的结果。最酷的是，我们不仅不必记住每次需要运行的确切命令，而且 npm 脚本可以组合并按顺序执行，因此我们可以创建复杂的任务，甚至可以自动触发一些任务，如果我们使用任何一个*【钩子】*(如 pretest 或 prepublish)* 。*

 *例如，让我们说，我们想要运行相同的 minify 任务，以及通过 linter 运行我们的代码，就在我们运行应用程序的测试之前。为此，我们可以添加类似这样的东西*(假装我们的应用程序代码位于 **src** 文件夹中)* :

```
"scripts":  {  "pretest":  "node tasks/minify.js --someflag --maybeanother && eslint src"  } 
```

或者我们可以直接把它作为**测试**脚本*的一部分(这个例子使用 jest，但是你可以用 mocha/ava/tape/etc 或者你选择的工具来代替它)* :

```
"scripts":  {  "test":  "node tasks/minify.js --someflag --maybeanother && eslint src && jest"  } 
```

关于这一点，最后要注意的是，这些脚本需要作为 **npm 运行‘脚本’**运行，除非它是 npm *(列在本节开头)*预定义/保留的脚本之一。然而，如果你使用 yarn，你可以完全省略**运行**部分，只做**yarn‘脚本’**，不管它是不是预定义的脚本。

### [](#config)配置

一个对象，其中的值可以设置为用作环境变量，以后可以从代码中访问这些变量。

要设置一个配置值，我们可以在 package.json 文件中这样做:

```
{  "name":  "my-app",  "config":  {  "port":  8000  }  } 
```

然后，可以使用**process . env . NPM _ package _ config _ { value }**从代码中引用值，就像这样:

```
const express = require('express');
const app = express();
const port = process.env.npm_package_config_port;

app.get('/', (req, res) => res.send('Hello!'));

app.listen(port, () => console.log(`App listening on port ${port}!`)); 
```

通过执行以下命令，可以随时从 package.json 文件外部更改这些配置值:

`npm config set {name of the project}:{config key} {config value}`

对于我们之前的例子，我们可以这样做:

```
npm config set my-app:port 3000 
```

### [](#dependencies)依赖关系

一个对象，存储项目历史中安装的*(和保存的)*的每个依赖项的名称和版本。每当有人得到这个项目的新副本并运行 **npm install** 时，所有这些依赖项都会被安装*(带有最新的兼容版本)*。这些依赖项，以及接下来的两个类别，用下面的格式定义:

```
"name-of-the-dependency":  "(^|~|version)|url" 
```

一些例子:

```
"dependencies":  {  "backbone":  "1.0.0",  "lodash":  "^4.6.1",  "mocha":  "~3.5.3",  "super-mega-library":  "https://example.com/super-mega-library-4.0.0.tar.gz"  } 
```

这些依赖项可以有已安装并保存的版本，也可以有一个有效的 URL，在该 URL 上可以获得当前版本的包*(该 URL 也可以是同一台计算机内的本地路径)*。

#### [](#what-are-the-and-symbols-at-the-beginning-of-the-versions)版本开头的^和~符号是什么？

安装的每个依赖项都可以有一个字符来定义可接受的兼容版本的范围。这两个是最常见的，但是完整的列表可以在这里找到。

换句话说，这些字符添加了关于下次发生 **npm 安装**时应该如何处理这种依赖性的指令:

*   **如果版本有脱字符号`(^)` :** 允许安装不同的版本，只要是微小的改动*(版本的第二个数字)*。如果没有找到不同的次要版本，将安装相同的版本。
*   **如果版本有波浪号`(~)` :** 允许安装不同的版本，只要只是补丁更改*(版本的最后一个数字)*。如果没有找到不同的修补程序，将安装相同的版本。
*   **如果版本只有数字而没有字符**:必须安装定义的完全相同的版本。

例如，对于上面指定的依赖项，如果我们运行 **npm install** 并且有新版本可用:

*   **主干**和**超大型图书馆**将继续使用相同的版本(分别为 1.0.0 和 4.0.0)。
*   **lodash** 可以安装同一个版本，也可以安装 **4.6.1** 和 **4.9.9** 之间的任何版本，但决不能安装等于 **5.x.x** 或更高版本。
*   摩卡可以安装相同的版本，也可以安装 **3.5.3** 和 **3.5.9** 之间的任何版本，但不能安装高于此版本的任何版本。

### [](#devdependencies)依赖关系

与上面列出的依赖项格式相同，但是这一部分将包括项目使用但生产环境*不需要的所有依赖项(如测试工具、本地开发服务器、优化工具等)。)*。任何获得该项目的副本并且将 **production** 设置为 **NODE_ENV** 变量的计算机都不会安装本节中列出的依赖项。

### [](#peerdependencies)对等依赖

这也使用相同的格式，但这些依赖项虽然不一定安装，但定义了此应用程序/包正确工作所需的兼容性。例如，如果我们正在开发一个只与 React 16 版本兼容的库，我们需要做这样的事情:

```
"peerDependencies":  {  "react":  "16.0.0"  } 
```

npm *(1 和 2)* 的旧版本曾经自动安装这些对等依赖，但现在不再是这样了。从版本 3 开始，如果在安装该项目时没有找到兼容的版本，将会触发警告。

### [](#engines)引擎

一个对象，我们可以在其中定义该项目支持的节点和 npm 的最低版本。它的定义格式如下:

```
"engines":  {  "node":  ">= 6.0.0",  "npm":  ">= 3.0.0"  } 
```

安装项目时，将运行检查以确保兼容性。如果不满足这一要求，安装过程将停止。

和依赖关系一样，我们可以使用范围*(比如`**>=**`、`**^**`、`**~**`等)。)*定义兼容版本。

## [](#more-information)更多信息

尽管这些是我们将在 package.json 文件中找到和使用的最常见的东西，但仍然有一些额外的东西值得一查。对于其他参考资料，我建议定期查看 npm 的官方文档，因为每当新版本发布时，它都会不断更新。

有用的链接:

*   来自 npm 的官方 package.json 文档。
*   npm 脚本文档。
*   npm 配置文档。

最初发表在我的博客上 [xabadu.dev](https://xabadu.dev/you-me-and-package-json/)*