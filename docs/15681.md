# 让随叫随到不那么糟糕

> 原文:[https://dev.to/molly/making-on-call-not-suck-490](https://dev.to/molly/making-on-call-not-suck-490)

当我们的团队还很小的时候，我们组织了一次随叫随到的轮换。每个开发人员都在轮换中，每次待命一周。当我们第一次开始轮换时，我们的团队有 5 名开发人员。一年又一年过去了，尽管我们的团队成长了，我们仍然坚持单一的轮换。最终，团队变得如此庞大，以至于人们每 3-4 个月就要待命一次。这看起来像是梦想成真，但实际上，远非如此。

# [](#a-broken-oncall-system)一个破碎的待命系统

由于各种各样的原因，单一的随叫随到的轮换对几乎所有人来说都是痛苦的。

### [](#large-rotation)大旋转

大规模的轮换意味着随叫随到的转变是如此的不频繁，以至于开发人员无法获得他们需要的经验和代表来知道如何有效地处理随叫随到的问题。此外，我们的代码库有了巨大的增长，同时开发了如此多的东西，以至于当出现问题时，随叫随到的开发人员很可能对问题或导致问题的代码一无所知。

这导致惊慌失措的开发人员经常求助于[站点可靠性工程](https://dev.to/molly_struve/what-it-means-to-be-a-site-reliability-engineer-32ki) (SRE)团队来解决问题。不断地参与并帮助解决随叫随到的问题很快就开始消耗 SRE 团队的大量时间和资源。本质上，团队开始表现得好像他们 24/7 随叫随到。持续不断的问题和请求几乎耗尽了整个团队的精力，夺走了他们从事自己项目所需的宝贵时间。

### [](#no-ownership)没有所有权

除了 SRE 团队筋疲力尽、效率低下之外，另一个开发人员对随叫随到的抱怨是，开发人员觉得他们对自己支持的代码没有所有权。一个人写代码，另一个人调试代码。这个应用程序太大了，以至于任何人都不可能对产品代码有一种拥有感，因为代码太多了，他们被期望支持所有的代码。

### [](#3-teams-one-application)3 个团队，一个应用

由于我们工程组织的规模，我们现在有 3 个独立的开发团队。每个团队有 5-7 名开发人员和一名经理。每个团队也有自己的一套项目。然而，我们的主要应用程序仍然是一个单一的整体式 Rails 应用程序。所有三个团队在整个代码库中平等地工作。不像其他应用程序，它们有非常独立的后端组件，归各个团队所有，没有清晰或明显的所有权界限。解决这个问题将被证明是最困难的任务，当谈到修复我们的待命制度。

# [](#the-solution)解

### [](#3-rotations)3 次旋转

我们知道，如果我们想继续增长，就必须打破这种循环，但问题是怎么做？尽管所有的开发人员都在一个应用程序上工作，没有明确定义的所有权线，但我们设计了一个计划，将我们的单个轮换分成 3 个，3 个开发团队各一个。这导致更短的轮换，这意味着更多的开发代表。虽然听起来有些落后，但更多的随叫随到是一种好处，因为开发人员已经变得更加适应它，并且能够真正找到最适合他们的策略。

### [](#divided-application-ownership)划分应用所有权

3 轮换制允许开发人员得到更多随时待命的代表，但这仍然留下了最大的问题，那就是所有权的问题。没有人愿意支持他们觉得不属于自己的东西。为了实现这一点，我们选择在 3 个开发团队之间划分随叫随到的应用程序所有权。这不是一夜之间发生的，但是通过几次会议和大量的团队讨论，我们能够在 3 个团队之间分解应用程序中的所有内容。

*   我们解散了所有的后台工作人员，例如:
    *   小组 1:索引作业
    *   团队 2:通宵报告工作
    *   团队 3:客户沟通工作
*   我们分解了所有单独的服务警报，例如:
    *   团队 1: Redis 警报，队列备份警报
    *   团队 2:弹性搜索警报、API 流量警报
    *   团队 3: MySQL 警报、用户加载页面警报
*   我们分解了应用程序组件，例如:
    *   团队 1:用户和警报模型和控制器
    *   团队 2:资产和漏洞模型和控制器
    *   团队 3:报告并通过电子邮件发送模型和控制器

一旦划定了界限，我们一定要向每个开发团队强调，尽管我们尽了最大努力来平衡代码，但我们仍然可能不得不移动一些东西。这向开发人员表明，我们完全致力于确保这一新的随叫随到轮换对每个人都是公平和更好的。

代码被拆分后，SRE 团队花时间与每个开发团队坐下来，彻底检查他们现在拥有的应用程序组件、工作人员和警报。我们检查了所有的东西，从常见问题到每段代码到底做了什么，以及它如何影响应用程序的其余部分。这些会议让开发人员对他们处理随叫随到情况的能力更有信心，因为他们现在对自己拥有什么以及如何处理有了清晰的了解。即使他们自己没有构建一些代码，他们也知道它是如何工作的，它在做什么。

除了让每个团队了解他们的代码部分，我们还利用了 [Gitlab 的 CODEOWNERS](https://docs.gitlab.com/ee/user/project/code_owners.html) 文件。CODEOWNERS 文件允许您指定组织中谁或什么团队拥有一个文件。当该文件被 PR 中的任何人更新时，该文件的所有者将被自动标记为审阅。

### [](#reasonable-fallbacks)合理的退让

最初，SRE 团队是随叫随到的开发人员的后备。如果随叫随到的开发人员有问题或需要帮助，他们会与那周随叫随到的 SRE 团队成员交谈。我们的 SRE 团队目前只有 3 名成员，所以你可以看到为什么我们被不断的后备力量耗尽。有了这个新系统，3 个待命的开发人员都成为彼此的后援。如果他们中的任何人不知所措或在某个问题上卡住了，我们鼓励他们向其他待命开发人员寻求帮助。

### [](#more-focus)更加专注

除了上面的变化，我们还删除了待命开发人员的一些职责。在这些随叫随到的轮换变更之前，随叫随到的开发人员负责确定在事故期间是否需要状态页面或任何客户消息。此后，我们将这一职责移交给了支持团队。支持团队最接近客户，因此最有能力沟通任何问题。当发生影响客户的事故时，支持团队会收到通知，并负责确定是否需要状态页面或任何客户通信。将这一职责交给支持团队可以让开发人员专注于诊断和解决手头的问题。

# [](#the-payoff)胜负

### [](#improved-alerting)强化警戒

最初，SRE 团队设置了所有的警报和监控工具。然而，一旦我们把警报交给每个开发团队，他们就拿着警报跑了。因为每个团队对他们的警报都有了新的主人翁意识，所以他们开始改进和发展它们。他们不仅发出了更多的警报，还提高了现有警报的准确性。

### [](#sense-of-ownership)归属感

即使一个团队可能编辑另一个团队支持的代码，支持团队仍然有强烈的主人翁意识。支持团队几乎就像他们代码部分的领域专家。使用 CODEOWNERS 文件可以确保支持团队了解并能够签署其他团队所做的任何更改。因为一个团队支持的每个代码块都很小，他们实际上可以学习和支持所有的代码，而不像以前那样任何人都无法处理。

### [](#faster-incident-response)更快的事件响应

三个开发人员同时待命，每个人专注于应用程序的一小部分，他们可以更快地发现问题。每个团队还希望确保当事情确实出错时，他们能被迅速发现，这就是为什么许多人选择调整他们的警报，以比最初设置的更快的速度警告他们问题。

分类和找出问题的根本原因也快了很多。团队非常熟悉他们的警报和他们拥有的代码片段，这使他们能够比以前更快地解决问题。

### [](#never-alone)永不落单

同时有三个开发人员待命意味着他们不会感到孤独。如果应用程序的某个部分出现问题，拥有该部分的开发人员知道，如果需要的话，还有另外两个部分可以提供帮助。当你随叫随到的时候，仅仅知道你有一个容易接近的人就能对你的信心产生奇迹。

### [](#improved-crossteam-communication)改进跨团队沟通

正如我之前所说的，3 个开发团队中的每一个都在整个应用程序中工作。这意味着有时一个团队可能会处理代码，最终导致另一个团队发出警报。

例如，假设一个高负载 Redis 警报响起。不能保证拥有该警报的团队也拥有导致问题的应用程序部分。但是，由于 Redis 警报团队对警报经验丰富，他们知道如何快速有效地对其进行分类。然后，分类团队可以很容易地将其移交给拥有问题组件的团队。这种跨团队的交流有助于团队了解彼此的最新工作，但是他们从来不觉得他们必须修改其他团队的代码。

# [](#oncall-shouldnt-suck)随叫随到不该吸

这个行业的许多人害怕随叫随到，但这不应该成为现实。如果人们害怕随叫随到，那么你的系统出了问题。当然，每个人在某个时候都会被深夜或周末的页面困扰，但这种困扰不应该成为常态。如果随叫随到让人一直想拔毛，那你就要搞清楚问题，解决问题。