# 快速反馈

> 原文:[https://dev.to/janvanryswyck/fast-feedback-1oo0](https://dev.to/janvanryswyck/fast-feedback-1oo0)

测试驱动开发是一个已经存在了近二十年的学科。不幸的是，直到今天，它仍然不是没有争议。大多数专业开发人员都知道，编写某种形式的自动化测试对任何类型的代码库都非常有益。但是仍然有争议的是，是在产品代码完成之前还是之后编写测试。这种讨论似乎每隔一天就会在许多论坛和社交媒体上出现。

有些人坚定地遵循“红、绿、重构”的口头禅，在通过添加一两行产品代码之前编写一个失败的测试。其他人不管出于什么原因都不喜欢遵循这种严格的过程，他们更喜欢在编写了部分或完整的实现之后再编写测试。就我个人而言，我喜欢先写测试。但是我也想强调，我写这篇文章并不是要对任何人做任何评价。对于这篇文章，我只想从一个稍微不同的角度来探讨这个话题。

有人是在实现之前还是之后编写测试，这不是一个真正有用的讨论。我认为有价值的是短反馈循环的概念。这是推动我们前进的动力。在我们深入到反馈循环的话题之前，我想提一个小故事。

我曾经采访过一个软件开发人员，他声称自己是 TDD 和测试优先方法的坚定信徒。面试时，我们坐在一起写了一些代码。在我解释了需求之后，他打开了一个新的源文件，并开始为一个域类上的新方法编写一个简单的单元测试。这个新方法最终会验证一些不变量，并改变它的一些内部状态。他写的第一个单元测试验证了快乐路径场景。由于这个新方法还没有实现，单元测试显然失败了。编写这个失败的测试只花了几分钟。然后他切换到领域类。他不仅编写了足够的产品代码来通过单元测试。他还根据作业编写了该方法的完整实现！这总共花了他大约 20 分钟，写了很多代码。然后，他运行之前的单一单元测试，并通过了测试。很明显，有几个测试用例根本不存在。他*不仅没有真正*遵循“红绿重构”的过程。他完全忽略了简短反馈流程的重要性。

术语“反馈回路”定义如下:

> 控制系统的一部分，它允许反馈和自校正，并根据实际输出和期望输出或最佳输出之间的差异来调整其操作。

*—免费词典*

对我来说，软件系统最重要的方面是它能够尽可能快地提供反馈。我们有工作系统吗？它的所有部分都正确集成了吗？我们现在能部署系统吗？它能在部署它的任何环境中正确运行吗？这个系统为用户服务得好吗？这些都是重要的问题。但是真正好的部分是我们是否能眨眼间回答这些问题。同样的道理也适用于我们实际开发软件的时候。

我们不仅想知道生产代码是否符合我目前对业务需求的理解。我们还想要关于系统设计的快速反馈，以及单元测试本身的正确性。不管你是先写单元测试还是在事后写单元测试，我们都不应该相信测试，直到我们看到它失败。我们应该总是确保看到测试因为正确的原因而失败。首先编写测试比在实现之后编写测试更有效率，因为我们开始的前提是看到测试失败。但是我也见过一些开发人员，虽然不是很多，他们已经非常精通在生产代码之后编写测试，同时确保另一种形式的简短反馈过程。

他们首先编写少量的产品代码，然后编写测试。他们看到测试通过，注释掉刚刚添加的代码，然后看到测试失败。然后他们再次取消对代码的注释，并看到测试(再次)通过。同样，这有点低效，甚至可能比简单地遵循传统的“红绿重构”需要更多的训练。但是这仍然是一个有价值的反馈循环。所以没有判断。

最重要的是能够快速验证我们正在取得进展，我们正朝着正确的方向前进。这就是我发现测试驱动开发如此吸引人的地方。

但是为什么就此打住呢？测试驱动开发是我们在大多数知名平台上使用的最佳方法。但是也有其他形式的反馈回路非常有益。以围绕 Clojure 编程语言的工具为例。他们有一种叫做 REPL 驱动开发的东西，开发人员不断地在 REPL 中执行小块代码。有时，出于回归或集成的目的，会在之后添加一些自动化测试。但是大多数情况下，当会话关闭时，来自 REPL 的调用代码会丢失。我真的发现 REPL 驱动的开发过程非常迷人，因为代码的执行只需要几秒钟，而不是几分钟。这种方法可以应用于大多数 LISP 系列编程语言。

如果你有兴趣了解更多，这篇[优秀的文章](http://blog.cognitect.com/blog/2017/6/5/repl-debugging-no-stacktrace-required)设法提供了一个关于这个过程的良好的第一印象。我必须承认，能够见证一个熟练使用 Clojure 的开发者，更是令人印象深刻。

总而言之，对我来说，评估新技术、方法和途径的最有价值的指标是它们为我提供快速反馈的能力。学习、讨论和改进这些反馈循环是最重要的。