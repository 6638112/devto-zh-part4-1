# 原因——一个编程语言特性概念

> 原文：<https://dev.to/aaronc81/causes-a-programming-language-feature-concept-2ag0>

# 简介

典型的编程语言的标准库通常充满了明显互补的方法。

操作方法和谓词方法之间有一个清晰而常见的关系，如果操作已经发生，谓词方法就会变为真。例如，在 Ruby `Array`实例上调用`clear`方法后，`empty?`谓词立即变为真。有很多其他方法可以改变数组，使其满足`empty?`谓词，但是`clear`每次只需一次方法调用就能保证满足它。总结一下:调用`clear`导致`empty?`为真。

我们现在已经确定了这些方法之间的关系。如果我们可以向语言声明这样的关系会怎么样，这对程序员和语言本身会有什么好处呢？

# 提出一种包含原因的语言

让我们来看看一个理论语言，它允许像这样的关系被声明。我们将这些关系称为*原因*，因为调用一个方法*导致*另一个谓词变为真。

我将编写 Ruby 风格的伪代码，因为使用 Ruby 的元编程功能实现像这样的复杂功能似乎是可行的。

下面是如何在`Array`类中声明`empty?`和`clear`方法，并给出了`clear` :
的原因

```
class Array
  # ...other definitions...

  def empty?
    length.zero?
  end

  causes { empty? } # <-- Here's our defined cause
  def clear
    each do |item|
      delete(item)
    end
  end
end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这段代码将关联`empty?`和`clear`方法，指定对`clear`的调用导致谓词`empty?`变为真。

根据传递给方法的参数，这也可以扩展到更复杂的原因。例如，如果一个项目刚刚被追加到一个数组中(在 Ruby 中使用`<<`),那么它一定是该数组中的最后一个项目。

这个原因的定义如下:

```
cause { |item| last == item } 
def <<(item)
  # ...array append logic...
end 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这里，谓词不仅仅是一个简单的方法调用——`last`方法被调用，并将其结果与要追加的项进行比较。

# 这样做有什么收获？

在编写代码时，考虑一个方法的原因似乎是另一个障碍，所以为什么要这么麻烦呢？

## 毫不费力的等幂

因为它确切地指定了调用它们时会发生什么，所以可以幂等地调用带有原因的简单方法。也就是说，如果它们的效果已经发生了，就不应该再发生了。

假设您有一个由用户提供的名为`bytes`的字节数组，并且您打算以一种要求末尾有一个空终止符的方式来处理它。用户可能包括也可能不包括这个空终止符。在传统的 Ruby 代码中，可以这样做:

```
bytes << 0 unless bytes.last == 0 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

在我们的语言中引入一个幂等调用语法，我们在方法名前添加一个前缀`?`，我们可以这样做:

```
bytes ?<< 0 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

这是可能的，因为通过正式指定一个方法导致什么，我们确切地知道`<<`将做什么，因此可以确定是否需要调用它。这个特定的代码片段将评估在`<<`的原因中指定的谓词；回想一下，这个谓语是`|item| last == item`。如果该谓词为假，即最后一项不为 0，则`<<`将被执行。

## 将声明式编程引入过程语言

如果知道一个方法满足什么条件，那么也有能力翻转这个信息。给定一个我们想要满足的条件，我们可以找到一个方法来实现它。

假设我们在语言的数组类型上定义了多种排序算法，每种算法都指定了一个原因，使得数组在调用它们之后满足一个`sorted?`谓词。为了对数组实例进行排序，我们可以编写代码，使用`satisfy`关键字:
，要求语言满足`sorted?`谓词

```
array = [4, 3, 7, 2]
satisfy array.sorted?
p array # => [2, 3, 4, 7] 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

该语言知道哪些方法将满足`sorted?`谓词，并可以相应地选择一个，也许使用智能解释器，该解释器随着时间的推移尝试每个候选方法，并确定哪个方法对于特定实例更快。

## 免费额外断言

每个原因可以选择性地充当后置条件断言，在关联的方法被调用后运行。这类似于 Eiffel 或 d 中内置的契约特性。例如，在`clear`和`empty?`示例中，当`clear`返回时，该语言将验证列表是否真的为空，如果不是，则抛出断言错误。这有助于更早地捕捉到漏洞。

## 易于阅读的代码

每个原因都可以作为文档，向阅读代码的程序员展示一个方法会有什么含义。此外，因为原因可以充当断言，所以可以保证这些蕴涵是真实的。

# 结论

我认为用一种语言实现 causes 可能是一种干净、简单的方法，可以使代码更具表现力、更易于阅读。你怎么想呢?